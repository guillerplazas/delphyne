# A demonstration with conditionals, which involves abducting an additional assumption
- strategy: prove_program_by_saturation
  args:
    prog: |
      use int.Int

      let example1 () diverges =
        let ref x = any int in
        let ref y = 3 in
        let ref z = 0 in
        assume { x < 0 };
        while x < 10 do
          x <- x + 1;
          z <- z - 1;
          if z < 0 then y <- y + 1
        done;
        assert { x <> y }
  tests:
    - run | success
  queries: 
    - query: SuggestInvariants
      args:
        unproved:
          name: VC for example1 (assertion)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }  (* GOAL *)
          goal_formula: not x = y
      answers:
        - example: true
          answer:
            suggestions:
              - [clearly_true, "z <= 0"]
              - [propose_post, "x <> y"]
          justification: |
            Explanations:
              - Since `z` is only decremented and starts at `0`, invariant `z <= 0` clearly holds. It is also likely to be useful since it shows that the conditional statement within the loop body always executes.
              - The post-condition `x <> y` is true initially. It is also preserved by the loop body since the conditional statement is always executed (and so both `x` and `y` are incremented at each iteration). Thus, proposing it as an invariant is reasonable.
    - query: SuggestInvariants
      args:
        unproved:
          name: VC for example1 (loop invariant preservation)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                invariant { x <> y }  (* GOAL, premise *)
                x <- x + 1;  (* premise *)
                z <- z - 1;  (* premise *)
                if z < 0 then y <- y + 1  (* premise *)
              done;
              assert { true }
          goal_formula: not (x + 1) = y
      answers:
        - example: true
          answer:
            suggestions:
              - [cond_guard, "z <= 0"]
          justification: |
            Explanations:
            - From the shown obligation, Why3 cannot prove that `x <> y` is preserved by the loop body. However, this is true since the conditional statement is always executed, and thus both `x` and `y` are incremented at each iteration. In turn, the conditional statement is always executed since `z` starts at `0` and is only decremented. This suggests adding `z <= 0` as an invariant.