# A demonstration with conditionals, which involves abducting an additional assumption
- strategy: prove_program_by_saturation
  args:
    prog: |
      use int.Int

      let example1 () diverges =
        let ref x = any int in
        let ref y = 3 in
        let ref z = 0 in
        assume { x < 0 };
        while x < 10 do
          x <- x + 1;
          z <- z - 1;
          if z < 0 then y <- y + 1
        done;
        assert { x <> y }
  tests:
    - run | success
  queries: 
    - query: SuggestInvariants
      args:
        unproved:
          name: VC for example1 (assertion)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }  (* GOAL *)
          goal_formula: not x = y
      answers:
        - example: true
          answer:
            obligation_kind: post
            obligation: "INVS -> x >= 10 -> x <> y"
            tricks: ["abduction", "simple"]
            suggestions: ["x <> y", "z <= 0"]
          justification: |
            Explanations:
            - From the proof obligation name containing "assertion" and from the final assertion being annotated with "(* GOAL *)", we know that this obligation is about proving the final assertion. Thus, `obligation_kind=post`.
            - The exact obligation is `INVS -> x >= 10 -> x <> y`. Here, `x >= 10` denotes the negation of the loop guard.
            - One way to prove this obligation is by adding the postcondition itself (`x <> y`) to INVS. We suggest doing that (`abduction` trick).
            - Also, we can see that `z` is only decremented in the program and so `z <= 0` is clearly a valid invariant. This looks like a useful invariant to have since it shows that the conditional within the loop is always executed (`simple` trick).
    - query: SuggestInvariants
      args:
        unproved:
          name: VC for example1 (loop invariant preservation)
          proved: false
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                invariant { x <> y }  (* GOAL, premise *)
                x <- x + 1;  (* premise *)
                z <- z - 1;  (* premise *)
                if z < 0 then y <- y + 1  (* premise *)
              done;
              assert { true }
          goal_formula: not (x + 1) = y
      answers:
        - example: true
          answer:
            obligation_kind: preserved
            obligation: "INVS -> z - 1 >= 0 -> x + 1 <> y"
            tricks: ["abduction"]
            suggestions: ["z <= 0"]
          justification: |
            Explanations:
            - From the proof obligation name containing "loop invariant preservation" and from the invariant being annotated with "(* GOAL *)", we know that this obligation is about proving the preservation of the loop invariant. Thus, `obligation_kind=preserved`.
            - The exact obligation is `INVS -> z - 1 >= 0 -> x + 1 <> y`. This is because...