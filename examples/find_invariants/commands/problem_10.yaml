# delphyne-command

command: run_strategy
args:
  strategy: prove_program
  args:
    prog: |
      use int.Int

      let main () diverges =
        let ref x = any int in
        let ref y = any int in
        assume { x >= 0 };
        assume { x <= 2 };
        assume { y <= 2 };
        assume { y >= 0 };
        while any bool do
          x <- x + 2;
          y <- y + 2
        done;
        if y = 0 then
          assert { x <> 4 }
  policy: prove_program_policy
  policy_args: {}
  num_generated: 1
  budget:
    num_requests: 60
outcome:
  status: completed
  diagnostics: []
  result:
    success: false
    raw_trace:
      nodes:
        "1": nested(0, $main)
        "2": child(1, query{@1})
        "3": nested(2, cands)
        "4": nested(3, next(nil))
        "5": child(4, cands{@2})
        "6": child(3, next(nil){%5})
        "7": child(2, cands{%6})
        "8": child(7, query{@3})
        "9": nested(3, next(next(nil){%5}[1]))
        "10": child(9, cands{@4})
        "11": child(10, cands{@5})
        "12": child(3, next(next(nil){%5}[1]){%11})
        "13": child(2, cands{%12})
        "14": child(13, query{@6})
        "15": child(14, nil)
        "16": nested(15, cands)
        "17": nested(16, next(nil))
        "18": child(17, cands{@8})
        "19": child(16, next(nil){%18})
        "20": child(15, cands{%19})
        "21": child(20, query{@9})
        "22": child(21, nil)
        "23": nested(22, cands)
        "24": nested(16, next(next(nil){%18}[1]))
        "25": child(24, cands{@11})
        "26": child(25, cands{@12})
        "27": child(16, next(next(nil){%18}[1]){%26})
        "28": child(15, cands{%27})
        "29": child(28, query{@13})
        "30": nested(3, next(next(next(nil){%5}[1]){%11}[1]))
        "31": child(30, cands{@14})
        "32": child(31, cands{@15})
        "33": child(30, cands{@16})
        "34": child(33, cands{@17})
        "35": child(30, cands{@18})
        "36": child(30, cands{@19})
        "37": child(36, cands{@20})
        "38": child(30, cands{@21})
        "39": child(38, cands{@22})
        "40": child(3, next(next(next(nil){%5}[1]){%11}[1]){%39})
        "41": child(2, cands{%40})
        "42": child(41, query{@23})
        "43": nested(3, next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]))
        "44": child(43, cands{@24})
        "45": child(44, cands{@26})
        "46": child(3, next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45})
        "47": child(2, cands{%46})
        "48": child(47, query{@27})
        "49": child(48, nil)
        "50": nested(49, cands)
        "51": nested(50, next(nil))
        "52": child(51, cands{@29})
        "53": child(50, next(nil){%52})
        "54": child(49, cands{%53})
        "55": child(54, query{@30})
        "56": nested(50, next(next(nil){%52}[1]))
        "57": child(56, cands{@31})
        "58": child(57, cands{@32})
        "59": child(50, next(next(nil){%52}[1]){%58})
        "60": child(49, cands{%59})
        "61": child(60, query{@33})
        "62": nested(23, next(nil))
        "63": child(62, cands{@34})
        "64": child(23, next(nil){%63})
        "65": child(22, cands{%64})
        "66": child(65, query{@35})
        "67": child(66, nil)
        "68": nested(3, next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]))
        "69": child(68, cands{@37})
        "70": child(69, cands{@38})
        "71": child(3, next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70})
        "72": child(2, cands{%71})
        "73": child(72, query{@39})
        "74": child(73, nil)
        "75": nested(74, cands)
        "76": nested(75, next(nil))
        "77": child(76, cands{@41})
        "78": child(75, next(nil){%77})
        "79": child(74, cands{%78})
        "80": child(79, query{@42})
        "81": child(80, nil)
        "82": nested(81, cands)
        "83": nested(75, next(next(nil){%77}[1]))
        "84": child(83, cands{@44})
        "85": child(84, cands{@47})
        "86": child(83, cands{@48})
        "87": child(83, cands{@49})
        "88": child(87, cands{@50})
        "89": child(83, cands{@51})
        "90": child(89, cands{@52})
        "91": child(75, next(next(nil){%77}[1]){%90})
        "92": child(74, cands{%91})
        "93": child(92, query{@53})
        "94": nested(82, next(nil))
        "95": child(94, cands{@54})
        "96": child(82, next(nil){%95})
        "97": child(81, cands{%96})
        "98": child(97, query{@55})
        "99": child(98, nil)
        "100": nested(23, next(next(nil){%63}[1]))
        "101": nested(82, next(next(nil){%95}[1]))
        "102": child(100, cands{@57})
        "103": child(101, cands{@58})
        "104": child(103, cands{@60})
        "105": child(102, cands{@61})
        "106": child(23, next(next(nil){%63}[1]){%105})
        "107": child(22, cands{%106})
        "108": child(107, query{@62})
        "109": child(101, cands{@63})
        "110": child(109, cands{@64})
        "111": child(82, next(next(nil){%95}[1]){%110})
        "112": child(81, cands{%111})
        "113": child(112, query{@65})
        "114": nested(3, next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1]))
        "115": child(114, cands{@66})
        "116": child(115, cands{@67})
        "117": child(114, cands{@68})
        "118": child(117, cands{@69})
        "119": child(3, next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1]){%118})
        "120": child(2, cands{%119})
        "121": child(120, query{@70})
        "122": child(121, nil)
        "123": nested(122, cands)
        "124": nested(123, next(nil))
        "125": child(124, cands{@72})
        "126": child(123, next(nil){%125})
        "127": child(122, cands{%126})
        "128": child(127, query{@73})
        "129": nested(123, next(next(nil){%125}[1]))
        "130": child(129, cands{@74})
        "131": child(130, cands{@75})
        "132": child(123, next(next(nil){%125}[1]){%131})
        "133": child(122, cands{%132})
        "134": child(133, query{@76})
        "135": nested(3, next(next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1]){%118}[1]))
        "136": child(135, cands{@77})
        "137": child(136, cands{@78})
        "138": child(3, next(next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1]){%118}[1]){%137})
        "139": child(2, cands{%138})
        "140": child(139, query{@79})
        "141": nested(3, next(next(next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1]){%118}[1]){%137}[1]))
        "142": child(141, cands{@80})
      queries:
        - node: 1
          space: query
          answers:
            "1":
              mode: null
              text: |
                error:
                obligations:
                  - name: VC for main (assertion)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 4
          space: cands
          answers:
            "2":
              mode: null
              text: |-
                The task here is to ensure that the assertion `assert { x <> 4 }` can be verified after the loop. The assumptions give us the range of values for `x` and `y` before entering the loop. Since both `x` and `y` are incremented by 2 in each loop iteration, we can identify their parity as an important factor to maintain in our invariants.

                Given the premises:
                - \(0 \leq x \leq 2\)
                - \(0 \leq y \leq 2\)

                Both `x` and `y` start as even numbers and maintain their even parity throughout the loop, as they are both incremented by 2.

                To help Why3 verify the assertion, let's establish invariants involving the modulo of `x` and `y`.

                ### Suggested Loop Invariants

                1. `x mod 2 = 0`  - Ensures `x` remains even.
                2. `y mod 2 = 0`  - Ensures `y` remains even.

                ```yaml
                ["x mod 2 = 0", "y mod 2 = 0"]
                ```
        - node: 7
          space: query
          answers:
            "3":
              mode: null
              text: |
                error: 'File line 11, characters 18-21: unbound function or predicate symbol ''mod'''
                obligations: []
        - node: 9
          space: cands
          answers:
            "4":
              mode: null
              text: |-
                To ensure that the proof can be completed, we need to provide loop invariants that will help Why3 deduce the relation between `x` and `y`. Given the loop and that both `x` and `y` are incremented by 2 in each iteration, we can derive an invariant expressing some relationship between `x` and `y`.

                Let's analyze the facts:
                - Initially, `x` and `y` are both in the range [0, 2].
                - The loop doesn't change their relative difference as both are incremented equally.
                - We can deduce that they will always differ by the same amount throughout execution.

                A suitable invariant could be an expression that reflects the constancy of `x - y` or `x - y` itself. Given the initial conditions, this invariant could look like `x = y` since they can start the same, or any constant difference that might have been present initially, but since initial values are arbitrary (`any int`) yet constrained by premises, we have to ensure they stay harmonized.

                The invariant that reflects the symmetry at every step based on premises is `x = y`. This invariant, if true initially, should stay true since both increment equally. Moreover, if `y = 0`, `x` must also equal 0, ensuring that `x` cannot be equal to 4.

                Here's the invariant suggestion:

                ```yaml
                [
                    "x = y"
                ]
                ```
        - node: 10
          space: cands
          answers:
            "5":
              mode: null
              text: |-
                Yes, the new formula `(x = y)` is distinct from the blacklisted formula `(x mod 2 = 0) && (y mod 2 = 0)`. 

                The blacklisted formula checks if both `x` and `y` are even numbers, i.e., both are divisible by 2 without any remainder. The new formula `(x = y)` checks whether `x` is equal to `y`. These are fundamentally different conditions: one checks for equality between `x` and `y`, while the other checks whether both `x` and `y` satisfy a specific condition (being even).

                Thus, the new formula is novel and not equivalent to the blacklisted formula.

                ```
                yes
                ```
        - node: 13
          space: query
          answers:
            "6":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 14
          space: eval
          answers:
            "7":
              mode: null
              text: |-
                To analyze the annotations and identify issues:

                1. **Invariant not holding initially:**
                   - The loop invariant given is `x = y`.
                   - Before the loop begins, it's assumed that `0 ≤ x ≤ 2` and `0 ≤ y ≤ 2`.
                   - However, there is no direct assumption or operation ensuring that `x = y` holds before the loop starts.
                   - The failing proof obligation `VC for main (loop invariant init)` specifically checks if the invariant holds initially (before the first iteration), suggesting the invariant might not initially hold.

                2. **Redundant Invariants:**
                   - The invariant `x = y` is the only invariant provided for the loop.
                   - There are no other invariants to compare and identify redundancy since only one invariant is given.

                Based on this analysis:

                - The failing proof obligation likely indicates that the invariant `x = y` does not initially hold. The presence of the failing VC strongly suggests this is incorrect as there is no evidence from the premises to conclude `x = y` initially.

                - Since there is only a single invariant provided, the question of redundancy doesn't arise here.

                ```yaml
                prob_incorrect: 1.0
                prob_redundant: 0.0
                ```
        - node: 17
          space: cands
          answers:
            "8":
              mode: null
              text: |-
                To understand the verification problem, let's analyze the program:

                1. There are two variables `x` and `y` both of which are initialized to any integer value within defined bounds.
                2. Four key assumptions specify the bounds: 
                   - `0 <= x <= 2`
                   - `0 <= y <= 2`
                3. The loop invariant is stated as `x = y`, aiming to ensure these two variables remain equal throughout the execution.
                4. In each loop iteration, both `x` and `y` are incremented by 2.

                Given the assumptions, both `x` and `y` start at a value between 0 and 2. However, the invariant `x = y` may not hold initially when entering the loop, since `x` and `y` might start with different values that respect the bounds independently. 

                To fix the proof obligation, we need an invariant that holds before the first iteration of the loop. Since both `x` and `y` start within the bounds and there's no prior condition ensuring they are equal before the loop starts, a simple solution is to add an invariant guaranteeing that initially `x - y` does not change by loop iterations.

                To ensure the invariant holds initially and is maintained by the loop, we can add the invariant `x - y = c` for some constant `c` in the range of possible value differences. Since the operation `x <- x + 2` and `y <- y + 2` maintains `x - y` unchanged, the invariant `x - y = c` remains true for all iterations.

                Thus, adding `x - y = c` for some appropriate constant `c` (which can be deduced using the initial bounds) will help ensure the proof of the invariant `x = y`. A suitable choice for `c` is any integer from the set { -2, -1, 0, 1, 2 }, considering possible initial differences under the assumed bounds.

                We can choose simple invariant as `x - y = 0` since it would guarantee their equality. But this assumption might help in achieving `x = y` as per the present state of outer environment in while loop.

                Here's the change with the additional loop invariant:

                ```yaml
                - "x - y >= -2"
                - "x - y <= 2"
                ```
        - node: 20
          space: query
          answers:
            "9":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* GOAL *)
                          invariant { x - y <= 2 }
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* GOAL *)
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* GOAL, premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* GOAL, premise *)
                          invariant { x = y }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 21
          space: eval
          answers:
            "10":
              mode: null
              text: |-
                To understand why the proof obligation failed, let us review the loop invariants being used and their initial conditions:

                1. **Loop invariants**:
                   - \( x - y \geq -2 \)
                   - \( x - y \leq 2 \)
                   - \( x = y \)

                2. **Assumed initial conditions**:
                   - \( 0 \leq x \leq 2 \)
                   - \( 0 \leq y \leq 2 \)

                The specific invariant that failed is `x = y` during initialization. Given \( 0 \leq x \leq 2 \) and \( 0 \leq y \leq 2 \), it is not guaranteed that \( x = y \). This clearly indicates that `x = y` is not satisfied initially for arbitrary values of \( x \) and \( y \) within their respective range.

                Now, let us consider redundancy among the invariants:
                - The invariants \( x - y \geq -2 \) and \( x - y \leq 2 \) form a range constraint \(-2 \leq x - y \leq 2\). However, adding \( x = y \) actually makes existing inequalities \( x - y \geq -2 \) and \( x - y \leq 2 \) redundant since \( x = y \) implies these, being much stronger. 

                Therefore:
                - **Probability that the invariant is incorrect** is high because \( x = y \) does not generally hold given arbitrary initial values \( x \) and \( y \).
                - **Probability of redundancy** is also high, considering how \( x = y \) implies the other inequalities about \( x - y \).

                Here is the YAML configuration reflecting this analysis:

                ```yaml
                prob_incorrect: 0.9
                prob_redundant: 0.8
                ```
        - node: 24
          space: cands
          answers:
            "11":
              mode: null
              text: |-
                The issue in the current annotated program lies in establishing an appropriate invariant that shows `x = y` holds at the start of the loop. The existing invariants do not ensure that `x` begins equal to `y` when the loop starts.

                Given the assumptions:
                - `0 <= x <= 2`
                - `0 <= y <= 2`

                And considering the assertion to prove is `x = y`, the common initial value that both variables might take is the lower bound, which is `0`. It suggests that an invariant we could use is `x = y = 0` initially.

                The loop modifies both `x` and `y` by adding `2` in each iteration. If `x` starts equal to `y`, they remain equal as both are incremented by the same amount. To prove the initial loop invariant, we should state that:

                - `x = y initially`, with `x = y` starting at `0`.

                Given this understanding, we should propose the following invariant as part of potential solutions that could help Why3 verify the goal:

                ```yaml
                - 'x = y = 0'
                ```
        - node: 25
          space: cands
          answers:
            "12":
              mode: null
              text: |-
                To determine if the new formula `(x = y = 0)` is equivalent to the blacklist formula `(x - y >= -2) && (x - y <= 2)`, we must compare their logical meanings.

                The blacklist formula `(x - y >= -2) && (x - y <= 2)` means that the difference between `x` and `y` lies within the range of `-2` to `2`, inclusive. This implies any pair of integers where the absolute difference between them is 2 or less, i.e., `x - y` can be `-2, -1, 0, 1, or 2`.

                The new formula `(x = y = 0)` is a compound equation form, which can be interpreted typically in two parts: 
                1. `x = 0`
                2. `y = 0`

                This means both `x` and `y` are exactly zero. The interpretation `x = y = 0` can sometimes be considered ambiguous in mathematical texts but in programming and logical contexts, it often will represent a conjunction of both variables being zero.

                To determine if these formulas are equivalent, consider:
                - The blacklist formula `(x - y >= -2) && (x - y <= 2)` allows for:
                  - `x = y = -2, -1, 0, 1, 2`
                  - and any combinations where absolute difference is 2: `(x=0, y=2)`, `(x=2, y=0)`, etc.
                  
                - The new formula `(x = y = 0)` specifically represents just the condition where both `x` and `y` are zero.

                Therefore, `(x = y = 0)` is a specific case of the general condition `(x - y >= -2) && (x - y <= 2)` but not equivalent since the latter includes more cases.

                Thus, the new formula is novel, distinct from the listed ones.

                ```
                yes
                ```
        - node: 28
          space: query
          answers:
            "13":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y = 0 }  (* GOAL *)
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y = 0 }  (* premise *)
                          invariant { x = y }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y = 0 }  (* GOAL, premise *)
                          invariant { x = y }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y = 0 }  (* premise *)
                          invariant { x = y }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y = 0 }  (* premise *)
                          invariant { x = y }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 30
          space: cands
          answers:
            "14":
              mode: null
              text: |-
                To fix the proof and enable Why3 to verify the assertion, we need to introduce loop invariants that capture the relationship between `x` and `y` throughout the loop execution. Analyzing the premises and the behavior within the loop:

                Initially, both `x` and `y` can be either 0, 1, or 2. The loop increments both `x` and `y` by 2 during each iteration, meaning they both maintain the same parity and increase by the same amount. The loop invariant can capture this behavior:

                1. We know that both `x` and `y` start at values between 0 and 2, inclusive.
                2. Both `x` and `y` are incremented by 2 on each iteration.
                3. Thus, the difference between `x` and `y` stays constant throughout the loop.

                Given that we want to verify the assertion `assert { x <> 4 }` when `y = 0`, consider that if `y` were 0 after the loop, then considering the initial assumptions and the invariants, it would imply that `x` would have been incremented by the same amount starting from a value that makes it impossible to become 4, due to staying within the bounds given by the assumptions.

                So, the potential crucial invariant could be maintaining the difference `x - y`:

                ```yaml
                - 'x - y = 0'
                ```

                This suggests that the difference between `x` and `y` remains constant throughout their incrementation, helping prove that the assertion holds under the given assumptions.
            "16":
              mode: null
              text: |-
                To address the proof obligation failure in the program, we need to ensure that the assertion `x <> 4` holds whenever `y = 0`. Given that the loop increments both `x` and `y` by 2, and considering the initial values of `x` and `y` are both within the range [0, 2], we should focus on maintaining the relationship between `x` and `y` such that `y = 0` can never co-occur with `x = 4`.

                From the assumptions provided, we know:
                - `0 <= x <= 2` initially
                - `0 <= y <= 2` initially
                - Both `x` and `y` are incremented by 2 in each iteration of the loop.

                Since `x` and `y` are incremented by the same amount, their difference remains constant throughout the loop. To ensure the assertion holds, we need to capture the invariant relationship between `x` and `y` throughout the loop's execution.

                The proposition is that if `y = 0`, then the difference between `x` and `y` prevents `x` from being 4, given the initial constraints. Initially, we have several possible pairs for `(x, y)`: (0,0), (0,2), (2,0), (2,2). With both `x` and `y` being incremented by 2 each time, `y` being 0 means it must have started at 0 and its difference to `x` should always be even.

                The missing invariant relates specifically to maintaining the parity and sum constraints on x and y to avoid the forbidden (4,0) state.

                Here’s a reasonable invariant to suggest:

                ```yaml
                ["x - y = 0 || x - y = 2"]
                ```

                This invariant helps to ensure that if `y` ever becomes 0 again, `x` would be constrained to maintain the invariant involving their constant difference, so `x` cannot become 4 starting from their possible initializations.
            "18":
              mode: null
              text: |-
                To address the failed proof, we need to focus on the values of `x` and `y` as the program executes and ensure useful properties of these variables are maintained. The loop modifies both variables in the same way: it adds `2` to both `x` and `y`. Also, considering the invariants `x >= 0`, `x <= 2`, `y <= 2`, and `y >= 0`, and knowing that both `x` and `y` start within this range, it suggests a relation or constant difference between them could be maintained.

                To solve the problem, we must prevent `x` from reaching 4 when `y` equals 0. From the initialization assumptions, it seems that any further increment keeps `x` and `y` equal. Thus, for `y = 0` to hold post-loop, maintaining the invariant `x = y + c` for a constant `c` could help guarantee the required condition.

                Analyzing the initial premises, possible invariants that could assist in proving the post-condition include:
                - `x <= y + 2`: This accounts for ensuring that even as both variables increment, `x` doesn't exceed a bound related to `y`.

                Adding these invariants to the loop should assist in Why3 completing the verification.

                ```yaml
                - 'x <= y + 2'
                ```
            "19":
              mode: null
              text: |-
                To help Why3 prove the assertion, we should add appropriate loop invariants that capture the relationship between `x` and `y` in every iteration of the loop. Let's examine the situation:

                1. Initially, we know through the assumptions:
                   - \( x \) and \( y \) both start in the range [0, 2].
                   - After each loop iteration, both `x` and `y` are incremented by 2.

                2. We have to prove:
                   - If \( y = 0 \), then \( x \neq 4 \).

                Let's evaluate the situation where \( y = 0 \):
                - Given \( y \) starts between 0 and 2 and increments by 2, it can go through values: 0, 2, 4, ...
                - Assuming \( y = 0 \) means no increment occurred, implying `x` must also not have incremented to reach the value of 4.

                Thus, \( x \) must remain within the starting range unless it increments. To facilitate this, a relevant loop invariant could be that \( x \) and \( y \) remain in synchronized increments:

                - \( |x - y| \) is invariant over the execution of the loop since both `x` and `y` are incremented by the same amount.

                This reasoning leads to a possible loop invariant:

                - \( x - y = k \) for some initial state difference \( k \) (here, we can choose \( k = 0 \), since initially \( x \geq 0 \), \( x \leq 2 \) and \( y \geq 0 \), \( y \leq 2 \)).

                Here is a suitable invariant suggestion:

                ```yaml
                [
                  "x - y = 0"
                ]
                ```
            "21":
              mode: null
              text: |-
                To solve this issue, we need to identify a loop invariant that can help prove the assertion. The premises state that both `x` and `y` initially range between 0 and 2. The loop increases both `x` and `y` by 2 iteratively. If `y` is 0, it must have remained 0 through the loop (as 0 is unchanged with increments of 2), implying `x` would remain constant (at 2 or below, according to premises), thus can't become 4.

                However, since `y = 0` implies it hasn't changed, and `x` starts with 0, 1 or 2, the line `assert { x <> 4 }` will hold.

                To support this, here are a couple of invariant suggestions you might try:

                - Ensure `y` and `x` maintain certain properties related to their starting values or relationship to each other.

                ```yaml
                - 'x + y <= 4'
                - 'x <= 2'
                ``` 

                These invariants help ensure that even as the loop progresses, `x` and `y` together do not increase beyond a reachable sum, considering initial assumptions and increments made during the loop.
        - node: 31
          space: cands
          answers:
            "15":
              mode: null
              text: |-
                Let's analyze the formulas.

                1. Blacklist formula: `(x = y)`
                   - This formula denotes that the value of `x` is equal to the value of `y`.

                2. New formula: `(x - y = 0)`
                   - When `x - y = 0`, it means that `x` and `y` are equal, as subtracting `y` from `x` results in zero. This is logically equivalent to saying `x = y`.

                The new formula `(x - y = 0)` is logically equivalent to the blacklisted formula `(x = y)`.

                Therefore, the new formula is not distinct from the blacklisted formulas.

                ```
                no
                ```
        - node: 33
          space: cands
          answers:
            "17":
              mode: null
              text: |-
                To assess whether the new formula is equivalent to any of the blacklisted formulas, let's evaluate both concepts individually:

                1. The first blacklisted formula is `(x mod 2 = 0) && (y mod 2 = 0)`: This indicates that both `x` and `y` are even numbers.

                2. The second blacklisted formula is `(x = y)`: This indicates that `x` is equal to `y`.

                Now, examining the new formula `(x - y = 0 || x - y = 2)`:

                - The condition `x - y = 0` implies that `x` is equal to `y`. This part of the new formula directly matches the second blacklisted formula `(x = y)`.

                - The condition `x - y = 2` states that the difference between `x` and `y` is 2, which is not covered by either of the blacklisted formulas on its own.

                However, since the new formula includes the sub-condition `x - y = 0`, which is equivalent to the blacklisted formula `(x = y)`, the new formula is not novel and matches part of one of the existing blacklisted formulas.

                Thus, the new formula is not distinct from the blacklisted ones. 

                ```
                no
                ```
        - node: 36
          space: cands
          answers:
            "20":
              mode: null
              text: |-
                To determine whether the new formula `(x - y = 0)` is equivalent to any of the blacklisted formulas, we will examine each blacklist item:

                1. **Blacklist Formula 1**: `(x mod 2 = 0) && (y mod 2 = 0)` 

                   This formula checks if both `x` and `y` are even numbers. It has no direct relation to the formula `(x - y = 0)`, which checks the equality of `x` and `y`. Therefore, they are not equivalent.

                2. **Blacklist Formula 2**: `(x = y)`

                   This formula checks if `x` is equal to `y`. The formula `(x - y = 0)` simplifies to the same condition because subtracting `y` from `x` resulting in zero implies that `x` is equal to `y`. Therefore, these formulas are equivalent.

                Since the new formula `(x - y = 0)` is equivalent to the blacklisted formula `(x = y)`, the new formula is not distinct from the blacklist.

                ```
                no
                ```
        - node: 38
          space: cands
          answers:
            "22":
              mode: null
              text: |-
                To determine if the new formula `(x + y <= 4) && (x <= 2)` is equivalent to the listed formulas, let's analyze each formula:

                1. **Formula 1**: `(x mod 2 = 0) && (y mod 2 = 0)`
                   - This formula states that both `x` and `y` are even numbers.
                   - It specifies a condition on the parity of `x` and `y`, but does not specify any particular limits on the sum `x + y` or specific values for `x`.
                   - The new formula `(x + y <= 4) && (x <= 2)` involves constraints on the sum of `x` and `y` and a maximum value for `x`. There is no restriction on the parity of `x` and `y`, only on their magnitude.
                   - Therefore, the new formula is not equivalent to this one.

                2. **Formula 2**: `(x = y)`
                   - This formula states that `x` and `y` have the same value.
                   - It does not involve the conditions `x + y <= 4` or `x <= 2`.
                   - The new formula imposes upper limits on the sum of `x` and `y` and restricts `x` to be less than or equal to 2.
                   - The constraints are not inherently about equivalence between `x` and `y`, and there are numerous scenarios where `x` and `y` are not equal but still satisfy the new formula.
                   - Therefore, the new formula is not equivalent to this one.

                Since the new formula does not match any of the conditions present in either blacklisted formula, it is distinct from both.

                ```
                yes
                ```
        - node: 41
          space: query
          answers:
            "23":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x + y <= 4 }  (* GOAL *)
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x + y <= 4 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x + y <= 4 }  (* GOAL, premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x + y <= 4 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x + y <= 4 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 43
          space: cands
          answers:
            "24":
              mode: null
              text: |-
                To help prove the failed assertion in the program, we need to suggest invariants that help show that `x` is not equal to `4` if `y` equals `0` after the loop. Based on the provided premises and failed attempts, it seems that the problem might be related to the growth of `x` and `y` within the loop in relation to the given premises.

                The loop increments both `x` and `y` by `2`. Given the initial constraints (both start at `0`, `1`, or `2`), `x` and `y` are both even numbers throughout the loop execution. Thus, for `y` to be `0` at the end, it must not have been incremented, and `x` should not have been incremented beyond its starting point (`x <= 2`).

                Let's consider invariants related to their difference and an implication with respect to `y` being `0`:

                1. The simplest useful invariants can consider that because `x` and `y` increment equally, their difference should remain constant, related to their initial values.
                2. `x - y` can help define a range that does not allow `x` to equal `4` when `y` is `0`.

                Given these constraints, we will define the following invariants:

                ```yaml
                ['x - y <= 2', 'x <= 2']
                ```
        - node: 44
          space: cands
          answers:
            "25":
              mode: null
              text: |-
                To determine if the new formula `(x - y <= 2) && (x <= 2)` is equivalent to any of the blacklisted formulas, let's analyze the logical conditions:

                1. **New Formula:**
                   - `(x - y <= 2)` indicates the difference between `x` and `y` is at most 2.
                   - `(x <= 2)` restricts `x` to be at most 2.

                2. **Blacklist Formulas:**
                   - `(x mod 2 = 0) && (y mod 2 = 0)`: This condition ensures both `x` and `y` are even numbers. It doesn't directly relate to the new formula.
                   - `(x = y)`: This is a specific equality condition, which is more restrictive than `(x - y <= 2)`. The new formula allows differences within 2 units, so they aren't equivalent.
                   - `(x + y <= 4) && (x <= 2)`: This can be compared more directly.
                     - The condition `(x <= 2)` is the same in both formulas.
                     - The condition `(x + y <= 4)` restricts the sum of `x` and `y`. To transform this into a similar form as `(x - y <= 2)`, we consider possible values:
                       - Given `x <= 2`, valid tuples for `(x, y)` matching `(x + y <= 4)` are `(0, 0)`, `(1, 0)`, `(1, 1)`, `(2, 0)`, `(2, 1)`, `(2, 2)`.
                       - For the new formula `(x - y <= 2)`, valid tuples matching `x <= 2` are all those in which `x` is at most 2 more than `y`.

                By evaluating some specific instances, the tuples that satisfy `(x - y <= 2) && (x <= 2)` are a superset of those that satisfy `(x + y <= 4) && (x <= 2)`. For example, the tuple `(2, 3)` satisfies `(x - y <= 2)` but does not satisfy `(x + y <= 4)`. Therefore, they are not equivalent.

                Thus, the new formula is distinct from every condition in the blacklist. 
                ```no```
            "26":
              mode: null
              text: |-
                To determine if the new formula `(x - y <= 2) && (x <= 2)` is equivalent to any of the blacklisted formulas, let's analyze each one:

                1. **Blacklist formula**: `(x mod 2 = 0) && (y mod 2 = 0)`
                   - This formula checks if both `x` and `y` are even numbers.
                   - The new formula does not make any assertions about the parity (evenness or oddness) of `x` or `y`, so it cannot be equivalent to this blacklisted formula.

                2. **Blacklist formula**: `(x = y)`
                   - This formula checks if `x` is equal to `y`.
                   - The new formula involves a difference, `(x - y <= 2)`, allowing `x` and `y` to differ by up to 2, but it also contains the condition `(x <= 2)`, thus possibly restricting some values. However, there is no constraint that forces `x` to be equal to `y` for all integer values, particularly for values like `x = 2`, `y = 0`, where `x != y`. Therefore, it cannot be equivalent to the statement that `x = y` necessarily.

                3. **Blacklist formula**: `(x + y <= 4) && (x <= 2)`
                   - The blacklisted formula imposes constraints on the sum of `x` and `y` and the value of `x`.
                   - The new formula does not directly constrain the sum of `x + y`, but it does impose restrictions involving `x - y`. They are two separate, although somewhat related conditions.
                   - Let's consider an evaluation:
                     - In the new formula, if we take `x = 2`, the limit for `y` based on `(x - y <= 2)` is `y >= 0`.
                     - Thus for `x = 2`, `y` can be `0, 1, 2, 3...`.
                     - For `x = 2`, the blacklisted formula would allow values only up to `y = 2` for their sum to be at most 4, i.e., `(x + y = 4)`.
                   - This shows that while there might be overlap for certain domain values (like `x = 1 or 0`), generally they aren't the same condition, particularly evident when considering the introduction of positive values for `y` while observing their sums in the blacklisted object.

                Given that none of the blacklisted formulas fully encapsulates the conditions imposed by the new formula, we conclude that the new formula is distinct from those on the blacklist.

                ```
                yes
                ```
        - node: 47
          space: query
          answers:
            "27":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* GOAL *)
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* GOAL, premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 48
          space: eval
          answers:
            "28":
              mode: null
              text: |-
                To determine the issue with the failing proof obligation for the loop invariant preservation, we need to check if the given invariants are correctly maintained throughout the loop execution. Specifically, we look at the logic inside the loop and verify against the invariants.

                1. **Loop Logic Analysis:**
                   - The loop invariants provided are `x - y <= 2` and `x <= 2`.
                   - Inside the loop, the operations `x <- x + 2` and `y <- y + 2` are executed.

                2. **Invariant Check:**
                   - Invariant `x <= 2` will not hold after the first iteration if initially `x <= 2` and `x` is incremented by 2, given the proposition that `x` can start as 2.
                   - However, the invariant `x - y <= 2` should hold since both `x` and `y` increase equally by 2.

                3. **Invariants Redundancy Check:**
                   - The invariant `x <= 2` is not redundant but incorrectly maintained. The invariant `x - y <= 2` is necessary to ensure a consistent relationship between `x` and `y`.
                   - No redundancies are immediately obvious since the two invariants address different aspects: one about the absolute value of `x` and the other about the relationship between `x` and `y`.

                **Conclusion:**
                The failing proof obligation (loop invariant preservation) suggests that not all invariants are preserved by the loop body. Specifically, the `x <= 2` invariant cannot be preserved through loop iterations, indicating it is likely incorrect after `x` is updated. Thus, it should be revisited or potentially removed or adjusted. There's no clear redundancy, but any removal or modification of invariants should be done to ensure correctness without redundancy.

                ```yaml
                prob_incorrect: 0.9
                prob_redundant: 0.1
                ```
        - node: 51
          space: cands
          answers:
            "29":
              mode: null
              text: |-
                The proof obligation that failed is the preservation of the loop invariant `x <= 2`. The issue likely arises because the assignment `x <- x + 2` could potentially invalidate this condition since `x` can increase beyond the value of 2 during the loop.

                To fix the situation, we need to revise or complement the invariants to account for the assignment to `x`. The loop invariants should ensure that the modifications done within the loop do not violate the goals upon iterations.

                One possible invariant that may help establish the preservation of `x <= 2` is one that tracks the changes in `x` and `y` relative to the loop's body:

                - As `x` and `y` are increased by 2 together, we could track their difference.
                - Since the difference `x - y` is already invariant within the bounds 2 as `x` and `y` are changed uniformly, this differential can be maintained to aid additional proofs.

                From these observations, we want to introduce an invariant that helps in maintaining the assertion and constraints across iterations. An invariant `x <= y` could be added to maintain the relation, as the initial assumptions and assignments maintain this relation.

                Let's list the invariants we deduced to close the proof obligation:

                ```yaml
                - "x - y <= 2"
                - "x <= 2"
                - "x <= y"
                ```
        - node: 54
          space: query
          answers:
            "30":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* GOAL *)
                          invariant { x <= 2 }
                          invariant { x <= y }
                          invariant { x - y <= 2 }
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL *)
                          invariant { x <= y }
                          invariant { x - y <= 2 }
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          invariant { x <= y }  (* GOAL *)
                          invariant { x - y <= 2 }
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          invariant { x <= y }  (* premise *)
                          invariant { x - y <= 2 }  (* GOAL *)
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          invariant { x <= y }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* GOAL, premise *)
                          invariant { x <= 2 }  (* premise *)
                          invariant { x <= y }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL, premise *)
                          invariant { x <= y }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          invariant { x <= y }  (* GOAL, premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          invariant { x <= y }  (* premise *)
                          invariant { x - y <= 2 }  (* GOAL, premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          invariant { x <= y }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          invariant { x <= y }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 56
          space: cands
          answers:
            "31":
              mode: null
              text: |-
                From the information you provided, the loop is increasing both `x` and `y` by 2 in each iteration. The assumptions indicate the initial bounds on `x` and `y`, and the invariants given try to express the relationship between `x` and `y`.

                The failed goal is to maintain `x <= 2` as an invariant, which obviously becomes impossible since `x` is incremented by 2 within every iteration of the loop. Given these premises and considering what has already been attempted, we need to seek a different invariant that represents the relationship of `x` and `y` as they increment equally.

                Let's try an invariant that captures an invariant relationship between `x` and `y` during this loop. Noting both are incremented by exactly 2 in every iteration, that means that their difference remains a constant number from its initial value, thus yielding a valid invariant:

                ```yaml
                [
                  "x - y = 0"
                ]
                ```
        - node: 57
          space: cands
          answers:
            "32":
              mode: null
              text: |-
                To determine if the new formula `(x - y = 0)` is equivalent to the blacklisted formula `(x - y <= 2) && (x <= 2) && (x <= y)`, we need to consider the logical constraints expressed by each formula:

                1. **New Formula:** `(x - y = 0)`:
                   - This formula simply means that `x` is equal to `y`.

                2. **Blacklisted Formula:** `(x - y <= 2) && (x <= 2) && (x <= y)`:
                   - `(x - y <= 2)` means that `x` is at most 2 units greater than `y`.
                   - `(x <= 2)` means that `x` itself is at most 2.
                   - `(x <= y)` means that `x` is less than or equal to `y`, or in other words, `y` is greater than or equal to `x`.

                The blacklisted formula allows for several possibilities within the constraints:
                - Since `x - y <= 2` and `x <= y`, `x` can be equal to `y`, but it could also be less than `y` by up to 2 units.
                - The condition `x <= y` is critical because it restricts `x` to be less than or equal to `y`, but not necessarily equal unless `x` is truly equal to `y`.

                In contrast, the new formula strictly requires `x` to be equal to `y` with no deviation. Given this analysis, the new formula is distinct because the blacklisted formula allows for more cases (where `x` can be strictly less than `y`), while the new formula only matches when `x` is exactly equal to `y`.

                Therefore, the new formula is distinct from the blacklisted one.

                ```
                yes
                ```
        - node: 60
          space: query
          answers:
            "33":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y = 0 }  (* GOAL *)
                          invariant { x - y <= 2 }
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y = 0 }  (* premise *)
                          invariant { x - y <= 2 }  (* GOAL *)
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y = 0 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y = 0 }  (* GOAL, premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y = 0 }  (* premise *)
                          invariant { x - y <= 2 }  (* GOAL, premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y = 0 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y = 0 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 62
          space: cands
          answers:
            "34":
              mode: null
              text: |-
                To resolve the failed proof obligation `VC for main (loop invariant init)`, we need to establish a correct set of loop invariants that hold true at the beginning and throughout the execution of the loop.

                From the given premises:
                - `x >= 0` 
                - `x <= 2` 
                - `y <= 2`
                - `y >= 0`

                And the loop specification:
                - `x - y >= -2`
                - `x - y <= 2`

                We are trying to ensure that `x = y` is a valid invariant at the beginning of the loop and throughout.

                Since both `x` and `y` are incremented by `2` in each loop iteration, whatever relationship holds between `x` and `y` once, will continue to hold. To address the failed invariant initialization, we need to ensure that `x = y` holds true from the start.

                From the given assumptions, both `x` and `y` can take the values `0, 1, or 2` initially. For the invariant `x = y` to hold from the start, we need to add an initial condition that explicitly sets `x` equal to `y`.

                Here's the list of new loop invariants to try:

                ```yaml
                [
                  "x = y"
                ]
                ```
        - node: 65
          space: query
          answers:
            "35":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* GOAL *)
                          invariant { x - y >= -2 }
                          invariant { x - y <= 2 }
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }
                          invariant { x - y >= -2 }  (* GOAL *)
                          invariant { x - y <= 2 }
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* GOAL *)
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* GOAL, premise *)
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* premise *)
                          invariant { x - y >= -2 }  (* GOAL, premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* premise *)
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* GOAL, premise *)
                          invariant { x = y }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* premise *)
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* premise *)
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 66
          space: eval
          answers:
            "36":
              mode: null
              text: |-
                The failure of the proof obligation `VC for main (loop invariant init)` suggests that the issue lies in establishing that the loop invariants hold initially, before entering the loop.

                Now, let's examine the loop invariants that are stated in the program:

                1. `invariant { x = y }`
                2. `invariant { x - y >= -2 }`
                3. `invariant { x - y <= 2 }`
                4. `invariant { x = y }`

                Given the initial assumptions:
                - `x >= 0`
                - `x <= 2`
                - `y >= 0`
                - `y <= 2`

                1. Invariant: `{ x = y }`
                   - With the premises, we have `0 <= x, y <= 2`. However, there is no guarantee that `x` and `y` are equal initially. Thus, `x = y` as an invariant is not guaranteed to hold initially, suggesting a potential issue.

                2. Invariant: `{ x - y >= -2 }`
                   - Since both `x` and `y` are between `0` and `2`, the difference `x - y` initially can range from `-2` to `2`. Hence, the invariant `x - y >= -2` is satisfied initially.

                3. Invariant: `{ x - y <= 2 }`
                   - Similar reasoning as above shows that this invariant also holds initially since `x - y` is at most `2`.

                4. Redundancy check:
                   - Invariant `x = y` appears twice, which is unnecessary redundancy.
                   - Considering redundancy about the differences, with `x = y`, the other conditions `x - y >= -2` and `x - y <= 2` are automatically fulfilled. Thus, `x = y` alone is a stronger condition than the other two, implying these two are redundant if `x = y` could hold.

                From the analysis, it appears:
                - The invariant `x = y` does not necessarily hold initially and is likely incorrect.
                - Invaraints `{ x - y >= -2 }` and `{ x - y <= 2 }` are redundant if `x = y` would be a valid invariant.

                Thus, most likely reasons for Why3 failing to prove the initial holding of invariants are:
                - `x = y` holding initially is false.
                - Redundant invariants also exist in the provided annotations.

                ```yaml
                prob_incorrect: 0.9
                prob_redundant: 0.8
                ```
        - node: 68
          space: cands
          answers:
            "37":
              mode: null
              text: |-
                Based on the premises provided and the failure to prove the assertion `x <> 4`, the problem seems to relate to maintaining specific properties of `x` and `y` that could prevent `x` from ever reaching 4 even if `y` could become 0.

                Given the premises:
                - `x` and `y` both start in the range `[0, 2]`.
                - In each iteration of the loop, we add 2 to both `x` and `y` simultaneously.

                To prevent `x` from reaching 4 when `y` equals 0, we need to ensure a relationship between `x` and `y` that guarantees if `y = 0`, `x` will never equal 4.

                Notice that `x` and `y` always move together: they start at the same parity because they only differ by at most 2 initially, and they move in lock-step increments of 2. A useful invariant could be a linear relationship or constraint that leverages this fact.

                The key here is to ensure a certain difference or function of `x` and `y` remains bounded such that the condition `x = 4` is not possible when `y` becomes 0.

                Let's try utilizing the initial bounded differences and propose an invariant that confines the changes allowed in `x` and `y`:

                ```yaml
                [
                  "0 <= x - y <= 2"
                ]
                ```
        - node: 69
          space: cands
          answers:
            "38":
              mode: null
              text: |-
                To determine if the new formula is distinct from the blacklisted formulas, let's analyze both the blacklisted formulas and the new formula:

                1. Blacklisted Formulas:
                   - `(x mod 2 = 0) && (y mod 2 = 0)`: This checks if both `x` and `y` are even numbers.
                   - `(x = y)`: This checks if `x` is equal to `y`.
                   - `(x + y <= 4) && (x <= 2)`: This checks if the sum of `x` and `y` is less than or equal to 4, and if `x` is less than or equal to 2.
                   - `(x - y <= 2) && (x <= 2)`: This checks if the difference between `x` and `y` is less than or equal to 2, and if `x` is less than or equal to 2.

                2. Analyzing New Formula:
                   - `(0 <= x - y <= 2)`: This checks if the difference between `x` and `y` is between 0 and 2, inclusive. In other words, this checks if `x` is greater than or equal to `y` and less than or equal to `y + 2`.

                Comparison:
                - The new formula checks that the difference `x - y` is between 0 and 2. This implies `y <= x <= y + 2`.
                - The blacklisted formula `(x - y <= 2) && (x <= 2)` checks that the difference `x - y` is at most 2 and `x` is at most 2, but it does not ensure `x >= y`. 

                The new formula is not equivalent to any of the blacklisted formulas. Therefore, it is distinct.

                ```
                yes
                ```
        - node: 72
          space: query
          answers:
            "39":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 73
          space: eval
          answers:
            "40":
              mode: null
              text: |-
                In this problem, the failing proof obligation is `VC for main (loop invariant init)`, which indicates that the loop invariant does not hold initially. 

                The loop invariant is given as:

                ```ml
                invariant { 0 <= x - y <= 2 }
                ```

                We need to check this invariant with the initial assumptions:

                ```ml
                assume { x >= 0 };
                assume { x <= 2 };
                assume { y <= 2 };
                assume { y >= 0 };
                ```

                For the invariant `0 <= x - y <= 2` to hold initially, we need:

                1. \(0 \leq x - y\) meaning:
                   - \(x \geq y\)

                2. \(x - y \leq 2\) meaning:
                   - \(x \leq y + 2\)

                Observe the combinations:

                - From `x >= 0` and `y <= 2`, it implies x - y can be at least \(0 - 2 = -2\), therefore, the left part of the first condition might fail initially.

                Given the constraints:
                - \(x \leq 2\)
                - \(y \geq 0\)

                The actual value of \(x - y\) lies between -2 to 2. 

                Since \(x\) and \(y\) can be equal to 0, and there's no guarantee of their equality or their initial values, the invariant's condition (\(x \geq y\)) might not be initially true (invalid).

                This means that the invariant is likely incorrect since it doesn't necessarily hold true with the given constraints at the start.

                Now, the consideration of redundant invariants comes into play:
                The current program shows only a single invariant:
                - `0 <= x - y <= 2`

                There isn’t another invariant that could potentially make it redundant, unless `x` and `y` are symmetrically involved in the invariant where the invariant inherently cannot be made any smaller by itself. Since there is only this single invariant explicitly mentioned, it does not appear redundant by itself.

                Given these observations, here are the assessments:

                ```yaml
                prob_incorrect: 1.0
                prob_redundant: 0.0
                ```
        - node: 76
          space: cands
          answers:
            "41":
              mode: null
              text: |-
                The goal here is to provide an invariant for the initialization of the loop in order to prove the loop invariant holds initially. Examining the premises and the loop invariant, we can consider the following logical invariant for the loop:

                1. The invariant `0 <= x - y <= 2` must hold during the loop.
                2. Initially, we have the information from assumptions that `x >= 0`, `x <= 2`, `y >= 0`, and `y <= 2`.

                From these assumptions, it follows that `x - y` starts between `0` and `2` after initialization because both `x` and `y` are initialized to values within the [0, 2] range. 

                Thus, we need to assert that this relation holds initially, which is precisely the loop invariant. To further strengthen this, we can additionally conclude from the premises that `x - y >= 0`. This provides us with additional assurance that `x - y` falls within the range [0, 2] from the start. 

                Let's add this invariant explicitly to help the proof. 

                ```yaml
                [
                    "0 <= x - y <= 2"
                ]
                ```
        - node: 79
          space: query
          answers:
            "42":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 80
          space: eval
          answers:
            "43":
              mode: null
              text: |-
                The failing proof obligation `VC for main (loop invariant init)` indicates that the problem lies with the loop invariant not holding initially, not after the execution of the loop has modified any variables.

                The invariants given are:

                1. `0 <= x - y <= 2`
                2. `0 <= x - y <= 2` (repeated)

                To ensure the invariants hold initially, we must establish that, before entering the loop, the conditions for the invariants are satisfied with the initial values of `x` and `y`.

                From the assumptions, we know:
                - `0 <= x <= 2`
                - `0 <= y <= 2`

                We need `0 <= x - y <= 2` to hold, which means:

                - For `0 <= x - y`: Given `0 <= x` and `0 <= y`, `x - y` could theoretically be negative if `y > x`. This part of the proof obligation fails unless `x >= y`. However, this constraint is not given by the assumptions. Thus, the invariant `0 <= x - y` does not hold with the premises given, indicating that this loop invariant is indeed incorrect.

                - The upper bound `x - y <= 2` seems feasible given `x <= 2` and `y >= 0`.

                Thus, the problem indeed lies with the lower bound of the invariant, specifically "0 <= x - y," not holding initially due to lack of a guarantee that `x >= y`.

                Regarding redundancy, the second invariant `0 <= x - y <= 2` is exactly the same as the first and therefore is redundant. 

                Based on the program analysis, our confidence scores are:

                ```yaml
                prob_incorrect: 1
                prob_redundant: 0.9
                ```
        - node: 83
          space: cands
          answers:
            "44":
              mode: null
              text: |-
                To address the failed proof obligation `VC for main (loop invariant init)`, we need to ensure that the loop invariant is preserved at the beginning and at each iteration of the loop. The key is to identify a suitable loop invariant that covers the transitions of `x` and `y`.

                The initial conditions provided are `0 <= x <= 2` and `0 <= y <= 2`. The loop updates the variables by adding 2 to both `x` and `y` in every iteration. These updates will affect the initial invariant `0 <= x - y <= 2`, which holds.

                We need an additional invariant that can express how `x` and `y` evolve within the loop while still covering the permissible range as per the initial assumptions. A suitable invariant might involve maintaining the relative differences or equating their increments.

                Here's a suitable loop invariant that takes the relative increment pattern into account:

                1. Maintain the relationship between `x` and `y` by expressing it through an equality.
                2. Ensure the lower bound for x and y individually to maintain consistency and range.

                Given these points, the invariant can be:

                1. The difference between `x` and `y` should always be a multiple of 2.
                2. Both `x` and `y` are still in their initial range of `[0, 2]`.

                The proposed invariant that captures these conditions:

                ```yaml
                [
                  "0 <= x <= 2",
                  "0 <= y <= 2",
                  "x mod 2 = y mod 2"
                ]
                ```

                This invariant ensures `x` and `y` are within bounds and have the same parity, reflecting their simultaneous updates by 2, maintaining the relationship throughout the loop.
            "48":
              mode: null
              text: |-
                To understand the failure, let's first analyze the loop invariants and the assumptions provided:

                Before entering the loop, the assumptions give us:
                - `0 <= x <= 2`
                - `0 <= y <= 2`

                The failed invariant is `0 <= x - y <= 2`, which might not be initially maintained with every choice for `x` and `y` within their respective ranges.

                To prove loop invariants, we must ensure they hold upon entering the loop (initially), are maintained throughout the loop, and ensure the postcondition holds at termination.

                When the loop continues to work on variables `x` and `y`, they are incremented by 2:
                - `x <- x + 2`
                - `y <- y + 2`

                Initially, `x - y` could be between `-2` and `2` given the ranges for `x` and `y`. To maintain the invariant `0 <= x - y <= 2`, we need additional conditions to avoid negative values on initialization and also to hold as the loop continues.

                ### Key Observations:
                - Initially, the expression `x - y` could be negative when `x` is lower than `y`.
                - The current invariant does not cover the possibility that `x` and `y` are equal or that their relationship in values stays within bounds as both are incremented by 2 during the loop.

                A more suitable invariant should align the initial state and successive state updates:
                - `x - y` should indeed start between 0 and 2 considering the updates by 2.

                By re-evaluating the problem, a potential missing invariant considering initial setup could be:
                - `y <= x`

                This ensures that, initially, `0 <= x - y`, addressing the lower bound correctly given the assumption.

                Let's suggest this solution with the YAML configuration:

                ```yaml
                - "x >= y"
                ```
            "49":
              mode: null
              text: |-
                To address the issue with the failure of the `VC for main (loop invariant init)`, we need to ensure that the loop invariants are correctly initialized and preserved throughout the loop execution. The existing invariant `0 <= x - y <= 2` captures part of the needed constraint, but it may be insufficient or not precise enough to describe the state of all variables accurately.

                Given the assumptions that `0 <= x <= 2` and `0 <= y <= 2`, upon loop entry, it is necessary to establish invariants that capture the relationships between variables `x` and `y` that consider these initial conditions. The fact that `x` and `y` are incremented by 2 in every loop iteration can also provide valuable insights for defining a suitable invariant.

                Here is a suggestion for a new invariant that aligns with logical interpretations of the code's behavior:

                - An invariant that explicitly maintains both variable bounds and their relation: `0 <= x <= 2 && 0 <= y <= 2 && x - y = 0`. The first part `0 <= x <= 2 && 0 <= y <= 2` ensures that both variables start within their given bounded ranges, and the part `x - y = 0` conceptualizes that both `x` and `y` should increment proportionally, initially corresponding to the valid range `x - y = 0` when starting at `any bool`.

                ```yaml
                [
                    "0 <= x <= 2",
                    "0 <= y <= 2",
                    "x - y = 0"
                ]
                ```
            "51":
              mode: null
              text: |-
                The proof obligation `VC for main (loop invariant init)` indicates that an initial or an intermediate loop invariant is not sufficient to establish the correctness of the program at the start of the loop. The existing invariants are about the relationship between `x` and `y`. However, the program modifies `x` and `y` in each iteration, and both start from some arbitrary values within the assumed bounds.

                To diagnose the invariant issue:
                - \( x \) and \( y \) can both start at values between 0 and 2.
                - After one iteration, both \( x \) and \( y \) are incremented by 2.
                  
                Given these updates, one idea is to explicitly express the bounded nature of \( x \) and \( y \) through the iterations of the loop as invariants. This could be accomplished by bounding \( x \) (and thus indirectly, \( y \)) between their potential initial maximum and the maximum possible after any number of increments. Since \( x \) and \( y \) can maximum initial be 2 and increment every cycle by 2, \( x \le 2 \times n \) (where \( n \) is the number of loop iterations). Ensuring these bounds are considered may help establish the validity of \( x \) and \( y \)'s ranges throughout the loop.

                Let's try adding this invariant regarding each of `x` and `y`'s individual relationships by themselves:

                ```yaml
                [
                  "0 <= x <= 2*n + 2",
                  "0 <= y <= 2*n + 2"
                ]
                ```
        - node: 84
          space: cands
          answers:
            "45":
              mode: null
              text: |-
                To determine if the new formula `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)` is equivalent to the blacklisted formula `(0 <= x - y <= 2)`, we should analyze each part.

                1. **Blacklisted Formula**: This formula specifies that the difference between `x` and `y` is either 0, 1, or 2. This can be rewritten as: 
                   - `x = y`,
                   - `x = y + 1`, or
                   - `x = y + 2`.

                2. **New Formula**: 
                   - `0 <= x <= 2` indicates `x` can be 0, 1, or 2.
                   - `0 <= y <= 2` indicates `y` can be 0, 1, or 2.
                   - `x mod 2 = y mod 2` implies that `x` and `y` must both be either even or odd, i.e., they share the same parity.

                We need to verify if the constraints imposed by both formulas are equivalent.

                **Checking Equivalence**:
                - **Case 1**: `x = y`: Both are equivalent as in both, `x` and `y` can take values (0,0), (1,1), or (2,2) satisfying both mariginal constraints and shared parity.
                - **Case 2**: `x = y + 1`: The new formula can satisfy this if `x = 1` and `y = 0` (both can be true as (0 is even and 1 is odd. So overall they are not equal to each other).
                - **Case 3**: `x = y + 2`: The new formula can satisfy this if `x = 2` and `y = 0`, or `x = 2` and `y = 1`. Again both satisfy both the individual and parity constraints.
                  
                For each case, we see that the new formula holds only if the blacklisted formula does as well, and vice versa. They represent the same conditions. 

                Hence, the new formula is not distinct; it is equivalent to the blacklisted formula.

                ```no```
            "46":
              mode: null
              text: |
                To determine if the new formula `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)` is distinct from the blacklisted formula `(0 <= x - y <= 2)`, we need to analyze both formulas.

                1. **Analyzing the blacklisted formula `(0 <= x - y <= 2)`**:
                   - This implies \( x - y = 0 \), \( x - y = 1 \), or \( x - y = 2 \).
                   - Possible pairs \((x, y)\) satisfying this are:
                     - \( x = y \)
                     - \( x = y + 1 \)
                     - \( x = y + 2 \)

                2. **Analyzing the new formula `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)`**:
                   - The conditions \(0 \leq x \leq 2\) and \(0 \leq y \leq 2\) indicate that both \(x\) and \(y\) can be 0, 1, or 2.
                   - The condition \(x \mod 2 = y \mod 2\) implies:
                     - Both \(x\) and \(y\) must be either even or both must be odd.

                Let's list the possibilities for \((x, y)\) given this constraint and the ranges:

                - \(x = 0, y = 0\)
                - \(x = 1, y = 1\)
                - \(x = 2, y = 0\)
                - \(x = 0, y = 2\)
                - \(x = 2, y = 2\)

                Now we need to check if these pairs \((x, y)\) satisfy the blacklisted condition:

                - For \((x = 0, y = 0)\), \(x - y = 0\), satisfies \(0 \leq x - y \leq 2\).
                - For \((x = 1, y = 1)\), \(x - y = 0\), satisfies \(0 \leq x - y \leq 2\).
                - For \((x = 2, y = 0)\), \(x - y = 2\), satisfies \(0 \leq x - y \leq 2\).
                - For \((x = 0, y = 2)\), \(x - y = -2\), does not satisfy \(0 \leq x - y \leq 2\).
                - For \((x = 2, y = 2)\), \(x - y = 0\), satisfies \(0 \leq x - y \leq 2\).

                The pair \((x = 0, y = 2)\) does not satisfy the blacklisted condition while satisfying the new formula. Thus, the new formula is distinct from the blacklisted ones.

                ```no```
            "47":
              mode: null
              text: |-
                To determine if the new formula is equivalent to any formula in the blacklist, let's analyze both the blacklisted formula and the new formula.

                1. **Blacklisted formula `(0 <= x - y <= 2)`:**

                   This formula implies that `x` and `y` are such that their difference is between 0 and 2, inclusive. In other terms:
                   - `x` can be equal to `y`, `y + 1`, or `y + 2`.

                2. **New formula `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)`:**

                   - It restricts `x` to be between 0 and 2, inclusive.
                   - It restricts `y` to be between 0 and 2, inclusive.
                   - It requires `x` and `y` to have the same parity (`x mod 2 = y mod 2`), meaning both are even or both are odd.

                Let's analyze possible values of `x` and `y` for the new formula:

                - If `x = 0` and `y` should be `0` to have the same parity (both even):
                  - Modulo condition: `0 mod 2 = 0 mod 2`.
                - If `x = 1` and `y` should be `1` to have the same parity (both odd):
                  - Modulo condition: `1 mod 2 = 1 mod 2`.
                - If `x = 2` and `y` should be `2` to have the same parity (both even):
                  - Modulo condition: `2 mod 2 = 2 mod 2`.

                For the new formula, possible pairs `(x, y)` are therefore: `(0, 0)`, `(1, 1)`, `(2, 2)`.

                Now, let's check if these pairs satisfy the blacklisted formula:
                - `(0 <= x - y <= 2)` is true for each pair:
                  - `(0, 0)`: `0 - 0 = 0`, which satisfies `0 <= 0 <= 2`.
                  - `(1, 1)`: `1 - 1 = 0`, which satisfies `0 <= 0 <= 2`.
                  - `(2, 2)`: `2 - 2 = 0`, which satisfies `0 <= 0 <= 2`.

                Given that the set of ordered pairs satisfying each formula is identical, the new formula is not novel.

                ```
                no
                ```
        - node: 87
          space: cands
          answers:
            "50":
              mode: null
              text: |-
                To determine if the new formula is equivalent to the blacklisted formula, let's analyze both:

                1. **Blacklisted Formula**: 
                   - `(0 <= x - y <= 2)`: 
                     This formula defines a range for the difference between `x` and `y`, allowing values `0`, `1`, and `2` for `(x - y)`.

                2. **New Formula**: 
                   - `(0 <= x <= 2) && (0 <= y <= 2) && (x - y = 0)`: 
                     This formula imposes the following constraints:
                     - `x` is between `0` and `2` inclusive.
                     - `y` is between `0` and `2` inclusive.
                     - `x - y = 0`, which implies `x = y`.

                Combining these constraints, the new formula ensures both `x` and `y` are within the range [0, 2] and `x` must be equal to `y`. This means that for any values of `x` and `y` satisfying the new formula, we have `(x - y) = 0`, which is a specific case of the general range defined by the blacklisted formula `(0 <= x - y <= 2)`.

                Thus, since `(x - y = 0)` is covered in the range specified by `0 <= x - y <= 2`, the new formula is actually a subset of the blacklisted formula.

                Therefore, the new formula is not distinct; it is included in the constraints of the blacklisted formula.

                ```
                no
                ```
        - node: 89
          space: cands
          answers:
            "52":
              mode: null
              text: |-
                To determine whether the new formula `(0 <= x <= 2*n + 2) && (0 <= y <= 2*n + 2)` is equivalent to the blacklisted formula `(0 <= x - y <= 2)`, we need to analyze the expressions:

                1. Blacklisted formula: `(0 <= x - y <= 2)`
                   - This describes a range for the difference between `x` and `y`. It implies that `x` can be at most 2 units greater than `y`.

                2. New formula: `(0 <= x <= 2*n + 2) && (0 <= y <= 2*n + 2)`
                   - This describes a bounded range for both `x` and `y`. Both `x` and `y` can independently take values from `0` to `2*n + 2`.

                To check for equivalence:
                - The blacklisted formula allows for `x` and `y` such that `x` is at most 2 units greater than `y`, providing a relation between `x` and `y`.
                - The new formula constrains `x` and `y` to be within a certain range but has no explicit relationship between `x` and `y`.

                The constraints of the blacklisted formula and the new formula are fundamentally different:
                - The new formula does not impose any restrictions on the relationship between `x` and `y`, unlike the blacklisted formula which directly relates `x` and `y`.
                - Due to this lack of relationship constraint in the new formula, it is possible to have situations where the new formula allows combinations of `x` and `y` that the blacklisted formula does not, and vice versa.

                Thus, the new formula is distinct from the blacklisted one because it is possible to have pairs of `x` and `y` satisfying the new formula that do not satisfy the blacklisted formula. Therefore, the new formula is novel.

                ```
                yes
                ```
        - node: 92
          space: query
          answers:
            "53":
              mode: null
              text: |
                error: 'File line 11, characters 28-29: unbound function or predicate symbol ''n'''
                obligations: []
        - node: 94
          space: cands
          answers:
            "54":
              mode: null
              text: |-
                The proof obligation failure indicates that Why3 is unable to establish the given invariant `0 <= x - y <= 2` at the start of the loop, based on the assumptions provided before the loop begins. This suggests that the initial conditions, namely the assumptions, somehow do not logically lead to the loop invariants at the beginning of the loop.

                Let's analyze the condition `0 <= x - y <= 2`. The initial values for `x` and `y` must satisfy this invariant from the very beginning. In other words, we need to show that given the assumptions `x >= 0`, `x <= 2`, `y >= 0`, `y <= 2`, the initial value of `x - y` satisfies the given invariant `0 <= x - y <= 2`.

                However, from the assumptions:
                - The largest value `x` can be is `2`.
                - The smallest value `y` can be is `0`.

                Therefore, the largest initial value for `x - y` is `2`, and the smallest initial value for `x - y` is `0`. Thus, the initial value of `x - y` indeed satisfies `0 <= x - y <= 2`.

                Since Why3 still fails the verification initially, we need to restate or strengthen our invariants so that the verification condition can propagate accurately through the system. Specifically, we can express the above reasoning explicitly as an invariant, or improve the structure of the current one.

                Let's add one invariant that can help with the proof:

                ```yaml
                - "x >= y"
                - "x <= y + 2"
                ```
        - node: 97
          space: query
          answers:
            "55":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* GOAL *)
                          invariant { x <= y + 2 }
                          invariant { 0 <= x - y <= 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* premise *)
                          invariant { x <= y + 2 }  (* GOAL *)
                          invariant { 0 <= x - y <= 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* premise *)
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* premise *)
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* GOAL, premise *)
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* premise *)
                          invariant { x <= y + 2 }  (* GOAL, premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* premise *)
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* premise *)
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* premise *)
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 98
          space: eval
          answers:
            "56":
              mode: null
              text: |-
                To analyze the given program, we need to evaluate both the conditions under which the loop invariants hold initially and whether some invariants are unnecessarily redundant.

                ### Checking for Incorrect Invariant Initialization

                The proof obligation that fails is `VC for main (loop invariant init)`, which means one or more loop invariants do not hold initially (before entering the loop). Here, we have to check these invariants against the assumptions given for `x` and `y`.

                1. **Invariant: `x >= y`**
                   - From assumptions: `x >= 0` and `y >= 0`, but there is no direct guarantee that `x >= y` unless `x = y` is explicitly assumed, which is not the case.

                2. **Invariant: `x <= y + 2`**
                   - From assumptions: `x <= 2` and `y >= 0`, it can be deduced that `x <= y + 2` since the maximum value of `y + 2` is also 2 when `y = 0`.

                3. **Invariant: `0 <= x - y <= 2`**
                   - From assumptions: `x >= 0`, `y <= 2`, it suffices to show that `x - y` ranges between `0` and `2`.
                   - This is equivalent to requiring `x >= y` and `x <= y + 2`, which together are already covered by the other two invariants, effectively making this one redundant.

                4. **Duplicate Invariant: `0 <= x - y <= 2`**
                   - This is a direct duplicate of the previous one and clearly redundant. 

                ### Identifying Redundant Invariants

                Given the analysis above, redundancy exists:
                - The invariants `x <= y + 2` and `0 <= x - y <= 2` in essence are conveying the same constraint because, given `x >= y`, `x <= y + 2` ensures `0 <= x - y <= 2`. Therefore, one of them is redundant.
                - Specifically, the additional copy of `0 <= x - y <= 2` is a straightforward redundancy, being a direct repeat.

                Thus, the only incorrect invariant seems to be `x >= y`, which doesn't hold given the assumptions on entering the loop.

                Here's the final evaluation:

                ```yaml
                prob_incorrect: 0.9
                prob_redundant: 0.8
                ```
        - node: 100
          space: cands
          answers:
            "57":
              mode: null
              text: |-
                To debug the situation, let's analyze the problem. The loop invariant `x = y` did not prove successful, which means that the initialization of this invariant isn't possible with the given assumptions. The premises before the loop indicate that `x` and `y` are in the range from 0 to 2.

                The invariant `x = y` is too strong; it requires `x` to always be equal to `y`, but this may not hold before the loop starts due to the initial arbitrary values (`any int`) that `x` and `y` receive. Since we have `x >= 0`, `x <= 2`, `y >= 0`, and `y <= 2`, one thing we know is that they are both constrained to be within that range, but not necessarily equal.

                Upon examination, `x = y` needs to be relaxed. An alternative would be to assert the constraints that are consistent before the loop starts: the difference between `x` and `y` must be a multiple of 2. Thus, instead of enforcing strict equality, we can make use of the other two invariants `x - y >= -2` and `x - y <= 2`. These indicate that `x` and `y` are close to each other.

                Let's try a different invariant: that the difference between `x` and `y` is consistently a multiple of 2. This naturally follows from the loop, as both `x` and `y` are incremented by the same value, maintaining the difference invariant in this way.

                ```yaml
                ["(x - y) mod 2 = 0"]
                ```
        - node: 101
          space: cands
          answers:
            "58":
              mode: null
              text: |-
                The problem seems to occur with the initialization of the loop invariant on the first iteration. The loop invariants given (specifically `x >= y` and `x <= y + 2`) may not be sufficient to cover the state when the loop starts. 

                To solve this issue, we need to ensure that these invariants are satisfied from the start, given the assumptions about `x` and `y`. We should also consider the relationship between `x` and `y` established by any code before the loop.

                Given the initial assumptions `x >= 0`, `x <= 2`, `y >= 0`, and `y <= 2`, we can infer that `0 <= x - y <= 2` is an invariant that holds initially.

                Additionally, the invariant `0 <= x - y <= 2` appears twice in the code, indicating redundancy, and more clarity might help Why3 in proving it. Let's consider an appropriate invariant set that combines all these ideas.

                Here are the invariants which should help complete the proof:

                ```yaml
                [
                  "x >= y",
                  "x <= y + 2",
                  "0 <= x - y",
                  "x - y <= 2"
                ]
                ```
            "63":
              mode: null
              text: |-
                To address the failing proof obligation, we should ensure that the initial values satisfy the loop invariant in every possible case, given the assumptions.

                **Analysis:**

                Given the assumptions:
                - `0 <= x <= 2`
                - `0 <= y <= 2`

                We need to establish an invariant for the initialization of the loop that can hold true across the valid range of these variables for every iteration, especially at the beginning.

                The invariant `x >= y` might not hold if `x < y` from the beginning under the assumptions, hence, it failed before. The primary point of failure lies in the initial relationship between `x` and `y`. Therefore, we need to rethink our loop invariants considering the values that `x` and `y` can take.

                **Adding New Invariants:**

                Given the updated guidance, we ought to specify what could be true initially. Since assumptions already tell us bounds, let's consider an alternative invariant that directly makes use of `x` and `y`'s initial constraints.

                Given that:
                - `0 <= x - y`, and the initial assumptions about range,
                  
                We can replace or add to the invariant set by narrowing the differences between `x` and `y`:

                To verify the start and maintain consistency, the difference between `x` and `y` in terms of explicit boundaries could be emphasized:

                ```yaml
                - "x <= y + 1"
                - "y <= x + 1"
                ```

                These constraints ensure that, initially and at every loop step, the values of `x` and `y` could only differ slightly according to initial assumptions and should adaptively hold through the transformations applied within the loop. 

                ```yaml
                - "x <= y + 1"
                - "y <= x + 1"
                ```
        - node: 102
          space: cands
          answers:
            "59":
              mode: null
              text: |-
                To determine if the new formula `((x - y) mod 2 = 0)` is equivalent to the blacklisted formula `(x = y)`, we need to interpret the meaning of each formula. 

                1. The blacklisted formula `(x = y)` simply states that `x` is equal to `y`. 

                2. The new formula `((x - y) mod 2 = 0)` means that the difference between `x` and `y` is an even number (because any integer `n` is even if `n mod 2` equals `0`).

                Let's analyze when these two formulas would produce the same results:

                - **(x = y)**:
                  - This holds true when both `x` and `y` take the same integer value.

                - **((x - y) mod 2 = 0)**:
                  - This holds true when `x` and `y` are either both even or both odd (i.e., their difference is an even integer), but it does not require `x` and `y` to be equal.

                For example:
                - If `x = 2` and `y = 2`, both formulas would be true.
                - If `x = 3` and `y = 3`, both formulas would be true.
                - If `x = 2` and `y = 4`, the formula `((x - y) mod 2 = 0)` is true, but `(x = y)` is false.
                - If `x = 3` and `y = 1`, the formula `((x - y) mod 2 = 0)` is true, but again `(x = y)` is false.

                Therefore, the new formula `((x - y) mod 2 = 0)` is not equivalent to `(x = y)` since they produce different results for different inputs, especially when one of the variables is even and the other is odd.

                ```no```
            "61":
              mode: null
              text: |-
                To determine if the new formula is equivalent to any formula on the blacklist, let's analyze what each formula represents.

                1. Blacklisted formula: `(x = y)`
                   - This formula implies that `x` is exactly equal to `y`.

                2. New formula: `((x - y) mod 2 = 0)`
                   - This formula means that the difference between `x` and `y` is an even number. In more detail, `x - y` is divisible by 2, indicating that `x` and `y` are either both even or both odd.

                Now, let's compare these formulas:

                - The formula `(x = y)` is stricter than `((x - y) mod 2 = 0)`. For `(x = y)` to hold, both `x` and `y` must be the same exact number.
                - For `((x - y) mod 2 = 0)`, `x` and `y` do not need to be identical; they only need to have the same parity (both even or both odd).

                Therefore, these two formulas are not equivalent. The new formula permits more combinations of `x` and `y`, such as `(x, y) = (2, 4)` or `(x, y) = (3, 5)`, whereas the blacklisted formula only holds true when `x` is exactly equal to `y`.

                Thus, the new formula is distinct from the blacklisted formula `(x = y)`.

                ```
                yes
                ```
        - node: 103
          space: cands
          answers:
            "60":
              mode: null
              text: |-
                To determine if the new formula is equivalent to one from the blacklist, we can simplify both formulas to see if they are logically the same.

                Let's first consider the blacklisted formula:
                - `(x >= y) && (x <= y + 2)`

                This simply checks if `x` is between `y` and `y + 2`, inclusive.

                Now, for the new formula:
                - `(x >= y) && (x <= y + 2) && (0 <= x - y) && (x - y <= 2)`

                We can observe the following:
                - The first two parts `(x >= y)` and `(x <= y + 2)` are identical to the blacklisted formula.
                - The additional clauses `(0 <= x - y)` and `(x - y <= 2)` are equivalent to `(x >= y)` and `(x <= y + 2)`, respectively.

                Thus, the new formula `(x >= y) && (x <= y + 2) && (0 <= x - y) && (x - y <= 2)` simplifies logically to:
                - `(x >= y) && (x <= y + 2)`

                It is clear that the new formula does not introduce any additional constraints compared to the blacklisted one, and it describes exactly the same set of circumstances.

                Hence, the new formula is effectively equivalent to the blacklisted formula.

                ```
                no
                ```
        - node: 107
          space: query
          answers:
            "62":
              mode: null
              text: |
                error: 'File line 11, characters 24-27: unbound function or predicate symbol ''mod'''
                obligations: []
        - node: 109
          space: cands
          answers:
            "64":
              mode: null
              text: |-
                To evaluate whether the new formula is distinct from the blacklisted formula, we should compare their logical implications under integer arithmetic.

                1. **Blacklisted formula:** `(x >= y) && (x <= y + 2)`
                   - This means `x` can take any of the integer values `y`, `y+1`, or `y+2`.

                2. **New formula:** `(x <= y + 1) && (y <= x + 1)`
                   - Breaking this down:
                     - `(x <= y + 1)` implies `x` is at most `y+1`.
                     - `(y <= x + 1)` implies `y` is at most `x+1`, i.e., `x` is at least `y-1`.

                   Combining both parts:
                   - `y - 1 <= x <= y + 1`

                   This means `x` can be `y-1`, `y`, or `y+1`.

                Let's list the allowed integer values for `x` for both formulas:

                - **Blacklisted formula:** `x` can be `y`, `y+1`, `y+2`.
                - **New formula:** `x` can be `y-1`, `y`, `y+1`.

                Comparing the sets of possible values for `x`:
                - The blacklisted formula allows `{y, y+1, y+2}`.
                - The new formula allows `{y-1, y, y+1}`.

                Since these sets are not the same, the new formula is distinct from the blacklisted one.

                ```
                yes
                ```
        - node: 112
          space: query
          answers:
            "65":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 1 }  (* GOAL *)
                          invariant { y <= x + 1 }
                          invariant { 0 <= x - y <= 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 1 }  (* premise *)
                          invariant { y <= x + 1 }  (* GOAL *)
                          invariant { 0 <= x - y <= 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 1 }  (* premise *)
                          invariant { y <= x + 1 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 1 }  (* premise *)
                          invariant { y <= x + 1 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 1 }  (* GOAL, premise *)
                          invariant { y <= x + 1 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 1 }  (* premise *)
                          invariant { y <= x + 1 }  (* GOAL, premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 1 }  (* premise *)
                          invariant { y <= x + 1 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 1 }  (* premise *)
                          invariant { y <= x + 1 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 1 }  (* premise *)
                          invariant { y <= x + 1 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          invariant { 0 <= x - y <= 2 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 114
          space: cands
          answers:
            "66":
              mode: null
              text: |-
                To solve the problem, let's examine the relevant parts of the code and existing assumptions. The loop increments both `x` and `y` by 2 continuously. Our challenge is to ensure that after the loop, if `y = 0`, then `x` should not equal 4.

                Given the provided assumptions and the unsuccessful attempts, we can deduce:
                - Initially, `0 <= x <= 2` and `0 <= y <= 2`.
                - The loop increments both `x` and `y` by 2 each time, keeping them even.
                - The condition `y = 0` implies that `y` was even or became even during execution.
                  
                Thus, if `y = 0` post-loop, it could only reach zero if it started even. Given the even increment, starting at an even value ensures it will remain even. Similarly, `x` could not have reached an even number larger than 2 if it was not even initially, and its original maximum was 2.

                This observation gives us an invariant that correlates a potential zero value for `y` to a limitation on `x`: when `y = 0`, it must have started from 0 due to loop behaviour constraints, thus not allowing `x` to reach 4.

                Let's try the following invariants:

                ```yaml
                [
                  "y >= 0",
                  "x >= 0",
                  "x <= y + 2"
                ]
                ```
            "68":
              mode: null
              text: |-
                To prove the assertion `assert { x <> 4 }` at the end of the loop, we need to ensure that the value of `x` after the loop will never be 4 if `y` is 0.

                Let's break down the situation:
                - Initially, `x` is between 0 and 2, and `y` is between 0 and 2.
                - In each iteration of the loop, both `x` and `y` are incremented by 2.
                - We need to ensure that, after any sequence of increments that would result in `y = 0`, `x` is not 4.

                If `y = 0` at the end, given `y` increases by 2 in every loop iteration, it must have been 0 at the beginning since we do not have subtraction operations. Thus, the number of increments applied to both `x` and `y` must be zero, meaning neither `x` nor `y` would have changed. Therefore, `x` remains within its initial range (0 to 2), and it can never be 4.

                Given this reasoning, a useful invariant could be:
                - The relationship between the number of increments of `x` and `y` and their initial values ensures that `x` doesn't ever reach 4 if `y` ends up at 0.

                So the invariant to add could be:
                - `x <= 2 || y <> 0`.

                This invariant maintains that if `x` reaches values beyond its initial bound (i.e., `x > 2`), then `y` will not be zero, helping to prove the assertion at the end. 

                Here's the formal annotation to help Why3 with this logic:

                ```yaml
                ["x <= 2 || y <> 0"]
                ```
        - node: 115
          space: cands
          answers:
            "67":
              mode: null
              text: |-
                To determine if the new formula `(y >= 0) && (x >= 0) && (x <= y + 2)` is equivalent to any of the blacklisted ones, I'll analyze and compare them:

                1. **Blacklist Formula 1:** `(x mod 2 = 0) && (y mod 2 = 0)`
                   - This expression requires that both `x` and `y` are even numbers. The new formula does not imply any particular parity for `x` or `y`, so these formulas are not equivalent.

                2. **Blacklist Formula 2:** `(x = y)`
                   - This formula states that `x` and `y` are identical. The new formula permits `x` and `y` to differ by up to 2, so they are not equivalent.

                3. **Blacklist Formula 3:** `(x + y <= 4) && (x <= 2)`
                   - This formula restricts the sum of `x` and `y` and also requires `x` to be less than or equal to 2. The new formula does not correspondingly limit the sum of `x` and `y`, thus they are not equivalent.

                4. **Blacklist Formula 4:** `(x - y <= 2) && (x <= 2)`
                   - This expression indicates that `x` can be at most 2 units greater than `y`, with `x` also constrained to be at most 2. The new formula appears similar due to the comparison `(x <= y + 2)`. Still, there is no explicit restriction that `x` must be less than or equal to 2, so these are not fully equivalent.

                5. **Blacklist Formula 5:** `(0 <= x - y <= 2)`
                   - This formula effectively states that `x` is between `y` and `y + 2`, inclusive. The new formula also states that `x <= y + 2` while including restrictions of `y >= 0` and `x >= 0`, which do not contradict the range relationship `0 <= x - y <= 2`. Thus, the new formula essentially describes the same relationship among `x` and `y`.

                The analyzed comparison shows that the new formula `(y >= 0) && (x >= 0) && (x <= y + 2)` is essentially expressing the same bound as the blacklisted condition `(0 <= x - y <= 2)`, given the context of integer variables. 

                Therefore, the new formula is not distinct from the blacklisted formulas.

                ```
                no
                ```
        - node: 117
          space: cands
          answers:
            "69":
              mode: null
              text: |-
                Yes, the new formula `(x <= 2 || y <> 0)` is distinct from all the blacklisted formulas. Let's break down the comparison:

                1. `(x mod 2 = 0) && (y mod 2 = 0)`: Checks if both `x` and `y` are even, unrelated to comparisons using `<=`, `=`, or `<>`.

                2. `(x = y)`: Checks for equality. The new formula allows inequality.

                3. `(x + y <= 4) && (x <= 2)`: Conditions involving specific limits on `x` and `x+y`, without involving `y <> 0`.

                4. `(x - y <= 2) && (x <= 2)`: Involves a condition on the difference between `x` and `y`, not directly related to `<=` or `<>` checks.

                5. `(0 <= x - y <= 2)`: Checks if `x` is slightly larger than or equal to `y` and also within 2 units, unlike the new formula.

                Since the new formula is based on `x <= 2` or `y <> 0` which doesn't fit the pattern or logic of the existing blacklist entries, it is novel.

                ```
                yes
                ```
        - node: 120
          space: query
          answers:
            "70":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= 2 || y <> 0 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 121
          space: eval
          answers:
            "71":
              mode: null
              text: |-
                Given the program, the failing proof obligation concerns the preservation of the loop invariant across iterations of the loop. The invariant is:

                ```mlw
                invariant { x <= 2 || y <> 0 }
                ```

                Let's analyze each aspect:

                1. **Invariant Initially Holding**: For the invariant to hold initially, we need to verify the starting conditions when the loop is entered.
                   
                   - From the assumptions, we know that `x >= 0`, `x <= 2`, `y >= 0`, and `y <= 2`. Thus, initially: 
                     - `x <= 2` holds because it's explicitly assumed. Hence, `x <= 2 || y <> 0` is `True || y <> 0`, simplifying to `True`, which holds trivially.
                   - Consequently, the invariant does hold before entering the loop, and the issue is not with the invariant not holding initially.

                2. **Invariant Preservation**:
                   
                   - After one iteration of the loop:
                     - `x` becomes `x + 2`
                     - `y` becomes `y + 2`
                     - The invariant to check now becomes `(x + 2 <= 2) || (y + 2 <> 0)`, which simplifies to `x <= 0 || y + 2 <> 0`.
                   - However, `x` was initially between 0 and 2 (inclusively), so after the update `x + 2 >= 2`, which means the left condition `x <= 0` will generally not hold after the first iteration. Therefore, y must not be 0 to preserve the invariant, which aligns initially.

                   This analysis shows that as long as `y` is initially nonzero or `x <= 0`,`y` does not affect the loop condition unless initially zero, ensuring `(y + 2 <> 0)` is respected, reinforcing the obligation.

                3. **Redundancy**:
                   
                   - The loop invariant `x <= 2 || y <> 0` is not redundant with any other assumption or invariant since it establishes a condition that must remain true throughout the loop, crucial considering changes because y starts at zero potentially unless x is strictly 0 initially. This invariant plays a role in guaranteeing `x <= 2` or non-zero y across iterations, justifying the symmetry alone.

                In summary, since the invariant holds initially but fails to hold across iterations, particularly resulting in failure when `x` becomes greater than `2` post-initialization pair phase, it likely needs modification to accommodate iterative increases over given assumptions.

                ```yaml
                prob_incorrect: 0.2
                prob_redundant: 0.3
                ```
        - node: 124
          space: cands
          answers:
            "72":
              mode: null
              text: |-
                To fix this issue, we need to identify the missing invariants that will allow the loop invariant to be maintained through each iteration of the loop.

                Examining the code, the loop modifies `x` and `y` by adding 2 to each of them. The initial values of `x` and `y` are constrained by the assumptions: `0 <= x <= 2` and `0 <= y <= 2`.

                The existing invariant is `x <= 2 || y <> 0`. For each iteration, given that `x` and `y` are incremented by 2, we need an invariant that expresses the relationship between `x` and `y` to ensure that when `y = 0`, the condition `x <> 4` is maintained.

                Let's consider the following additional invariants:

                1. `x mod 2 = y mod 2`. This will ensure that the increments maintain parity between `x` and `y`, providing an implication that helps when `y` reaches 0.

                2. `x <= y + 2`. This initially holds true given the assumptions. Since both `x` and `y` are modified by the same value, the inequality is preserved across loop iterations.

                These invariants should provide sufficient information for the theorem prover to establish the correctness of the loop invariant and prove the final assertion.

                ```yaml
                - "x mod 2 = y mod 2"
                - "x <= y + 2"
                ```
        - node: 127
          space: query
          answers:
            "73":
              mode: null
              text: |
                error: 'File line 11, characters 18-21: unbound function or predicate symbol ''mod'''
                obligations: []
        - node: 129
          space: cands
          answers:
            "74":
              mode: null
              text: |-
                To resolve the proof obligation `VC for main (loop invariant preservation)`, we need to reason about how the values of `x` and `y` evolve across iterations of the loop, given the operations performed on them and their initial assumptions.

                Given:
                - Initial conditions: `0 <= x <= 2` and `0 <= y <= 2`
                - In each iteration: `x <- x + 2` and `y <- y + 2`
                - We need to ensure the loop invariant `x <= 2 || y <> 0` holds across iterations.

                The major challenge appears to be maintaining this invariant given the changes to `x` and `y`. Initially, both `x` and `y` are between `0` and `2`, and they are incremented by `2` each iteration. This suggests that the relationship between `x` and `y` could be crucial. Let's explore potential invariant forms that encapsulate this relationship:

                1. Since both `x` and `y` start below or equal to `2`, they increase in steps of `2`, and their difference maintains parity (`x - y` is always even, suggestive but not enforceable), both remain synchronously large or small. Therefore, we can propose a bound on the maximum value they reach.
                2. Enforcing direct constraints on their iterative increase may help; we notice they grow uniformly.

                The preservation of `x <= 2 || y <> 0` could be upheld through a combination of checking the synchronization via difference or bounding constraints going beyond the initial constraints.

                Here's a hypothesis:

                ```yaml
                [
                  "x <= y + 2",
                  "x <= 2 || y <> 0",
                  "x <= 4",
                  "y <= 4"
                ]
                ```

                This proposal adds bounds while trying to preserve the logical condition formed by `x` and `y` changes. 
        - node: 130
          space: cands
          answers:
            "75":
              mode: null
              text: |-
                First, let's analyze the blacklisted formula:

                - `(x mod 2 = y mod 2)` implies that `x` and `y` have the same parity. This condition is independent of specific range constraints on the values of `x` and `y`.
                - `(x <= y + 2)` restricts `x` to being at most 2 units greater than `y`. 

                Now, let's look at the new formula:

                - `(x <= y + 2)` matches directly with the second component of the blacklisted formula.
                - `(x <= 2 || y <> 0)` suggests some additional restrictions. This condition says either `x` must be at most 2, or `y` cannot be 0.
                - `(x <= 4)` and `(y <= 4)` are additional bounding conditions that restrict the maximum possible values for `x` and `y`.

                The blacklisted formula requires `x` and `y` to have the same parity and that `x` must be at most `2` more than `y`. 

                The new formula restricts `x <= y + 2`, similar to the blacklisted condition, and it further restricts the values with bounded conditions (`x <= 4` and `y <= 4`) and a disjunction that involves specific values of `x` and `y` (`x <= 2 || y <> 0`). However, the parity condition from the blacklisted formula doesn't appear to directly correspond in the new formula.

                To conclude, the new formula and the blacklisted formula contain constraints that intersect partially but differ because of the absent parity condition in the new formula and the additional bounding the new formula imposes. Thus, they cannot be considered equivalent.

                ```
                yes
                ```
        - node: 133
          space: query
          answers:
            "76":
              mode: null
              text: |
                error:

                obligations:
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* GOAL *)
                          invariant { x <= 2 || y <> 0 }
                          invariant { x <= 4 }
                          invariant { y <= 4 }
                          invariant { x <= 2 || y <> 0 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* GOAL *)
                          invariant { x <= 4 }
                          invariant { y <= 4 }
                          invariant { x <= 2 || y <> 0 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          invariant { x <= 4 }  (* GOAL *)
                          invariant { y <= 4 }
                          invariant { x <= 2 || y <> 0 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          invariant { x <= 4 }  (* premise *)
                          invariant { y <= 4 }  (* GOAL *)
                          invariant { x <= 2 || y <> 0 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant init)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          invariant { x <= 4 }  (* premise *)
                          invariant { y <= 4 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* GOAL, premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          invariant { x <= 4 }  (* premise *)
                          invariant { y <= 4 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                          invariant { x <= 4 }  (* premise *)
                          invariant { y <= 4 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          invariant { x <= 4 }  (* GOAL, premise *)
                          invariant { y <= 4 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: no
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          invariant { x <= 4 }  (* premise *)
                          invariant { y <= 4 }  (* GOAL, premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (loop invariant preservation)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          invariant { x <= 4 }  (* premise *)
                          invariant { y <= 4 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  - name: VC for main (assertion)
                    proved: yes
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= y + 2 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          invariant { x <= 4 }  (* premise *)
                          invariant { y <= 4 }  (* premise *)
                          invariant { x <= 2 || y <> 0 }  (* premise *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
        - node: 135
          space: cands
          answers:
            "77":
              mode: null
              text: |-
                To ensure that the assertion `x <> 4` is proven, we should consider how the loop affects the relationship between `x` and `y`. The key is to understand how `x` and `y` evolve by increments of 2 inside the loop. Since both start within the range `[0, 2]`, adding 2 repeatedly keeps them even. If `y = 0`, it likely means the loop didn't run at all. Thus, it's critical to capture the relationship established by starting conditions and the parity of `x` and `y` that persists through the loop because they are both increased by 2 simultaneously.

                Let's try adding an invariant that uses this understanding to preserve properties through the loop. 

                Here are some invariants that could help in this situation:

                ```yaml
                - "x mod 2 = y mod 2"
                ``` 

                This invariant asserts that `x` and `y` will always have the same parity, ensuring that post-loop, if `y = 0`, it logically follows that `x`, initialized within the same constraints and modified in tandem, can’t be 4. Combining this understanding with the starting conditions ensures that only certain values for `x` and `y` are possible when `y = 0` after the loop.
        - node: 136
          space: cands
          answers:
            "78":
              mode: null
              text: |-
                To determine if the new formula `(x mod 2 = y mod 2)` is equivalent to any formula in the blacklist, we must analyze what each formula represents:

                1. **`(x mod 2 = 0) && (y mod 2 = 0)`** represents both `x` and `y` being even numbers. The new formula checks if `x` and `y` have the same parity (both even or both odd), so it is not equivalent to only both being even.

                2. **`(x = y)`** checks if `x` and `y` are exactly equal. The new formula does not require `x` and `y` to be equal, only that they have the same parity.

                3. **`(x + y <= 4) && (x <= 2)`** is a condition on the sum and one of the variables, unrelated to their parity.

                4. **`(x - y <= 2) && (x <= 2)`** is a condition on the difference between `x` and `y`, again unrelated to parity directly.

                5. **`(0 <= x - y <= 2)`** is equivalent to the condition `(x - y) >= 0 && (x - y) <= 2`, meaning `y` can be `x`, `x-1`, or `x-2`. This does not directly check the parity, only their difference.

                6. **`(x <= 2 || y <> 0)`** checks a range and a non-equality, unrelated to parity equivalence.

                The new formula checks if both numbers `x` and `y` are either both even or both odd, which is distinctive from all conditions in the blacklist.

                Thus, none of the blacklisted formulas is equivalent to the new formula `(x mod 2 = y mod 2)`.

                ```
                yes
                ```
        - node: 139
          space: query
          answers:
            "79":
              mode: null
              text: |
                error: 'File line 11, characters 18-21: unbound function or predicate symbol ''mod'''
                obligations: []
        - node: 141
          space: cands
          answers:
            "80":
              mode: null
              text: |-
                To resolve this proof obligation, we need to ensure that the invariant leads to the conclusion that when `y = 0`, `x` cannot be equal to 4. 

                Given that both `x` and `y` start within the range [0, 2] and are incremented by 2 in each iteration of the loop, they will remain in sync with respect to their initial difference, which is zero or two, because they start within the same bounds.

                Let's analyze:
                - Initially, the difference between `x` and `y` is zero, i.e., `x - y = 0`.
                - If `x` is incremented by 2, so is `y`, maintaining `x - y = 0`.
                - Therefore, maintaining this invariant `x - y = 0` ensures `x` and `y` remain equal.

                Thus, if `y = 0`, it implies `x = 0` based on the invariant `x - y = 0`, leading to a contradiction if `x = 4`. Hence, an appropriate invariant is `x - y = 0`.

                Here's the suggested invariant:

                ```yaml
                ["x - y = 0"]
                ```
    log:
      - message: Answer received
        node: 4
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?
          answer: |-
            The task here is to ensure that the assertion `assert { x <> 4 }` can be verified after the loop. The assumptions give us the range of values for `x` and `y` before entering the loop. Since both `x` and `y` are incremented by 2 in each loop iteration, we can identify their parity as an important factor to maintain in our invariants.

            Given the premises:
            - \(0 \leq x \leq 2\)
            - \(0 \leq y \leq 2\)

            Both `x` and `y` start as even numbers and maintain their even parity throughout the loop, as they are both incremented by 2.

            To help Why3 verify the assertion, let's establish invariants involving the modulo of `x` and `y`.

            ### Suggested Loop Invariants

            1. `x mod 2 = 0`  - Ensures `x` remains even.
            2. `y mod 2 = 0`  - Ensures `y` remains even.

            ```yaml
            ["x mod 2 = 0", "y mod 2 = 0"]
            ```
      - message: Answer received
        node: 9
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
          answer: |-
            To ensure that the proof can be completed, we need to provide loop invariants that will help Why3 deduce the relation between `x` and `y`. Given the loop and that both `x` and `y` are incremented by 2 in each iteration, we can derive an invariant expressing some relationship between `x` and `y`.

            Let's analyze the facts:
            - Initially, `x` and `y` are both in the range [0, 2].
            - The loop doesn't change their relative difference as both are incremented equally.
            - We can deduce that they will always differ by the same amount throughout execution.

            A suitable invariant could be an expression that reflects the constancy of `x - y` or `x - y` itself. Given the initial conditions, this invariant could look like `x = y` since they can start the same, or any constant difference that might have been present initially, but since initial values are arbitrary (`any int`) yet constrained by premises, we have to ensure they stay harmonized.

            The invariant that reflects the symmetry at every step based on premises is `x = y`. This invariant, if true initially, should stay true since both increment equally. Moreover, if `y = 0`, `x` must also equal 0, ensuring that `x` cannot be equal to 4.

            Here's the invariant suggestion:

            ```yaml
            [
                "x = y"
            ]
            ```
      - message: Answer received
        node: 10
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`

                New formula: `(x = y)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            Yes, the new formula `(x = y)` is distinct from the blacklisted formula `(x mod 2 = 0) && (y mod 2 = 0)`. 

            The blacklisted formula checks if both `x` and `y` are even numbers, i.e., both are divisible by 2 without any remainder. The new formula `(x = y)` checks whether `x` is equal to `y`. These are fundamentally different conditions: one checks for equality between `x` and `y`, while the other checks whether both `x` and `y` satisfy a specific condition (being even).

            Thus, the new formula is novel and not equivalent to the blacklisted formula.

            ```
            yes
            ```
      - message: Answer received
        node: 14
        space: eval
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                I will show you an annotated program in which Why3 did not manage to prove a particular proof obligation. You must determine two things:

                1. Whether the failing proof obligation is about an invariant not holding initially. In this case, there is no hope to fix the proof by adding new invariants and so the invariant in question must be incorrect.
                2. Whether or not the shown program features redundant invariants. For example, having both invariants `x >= 1` and `x >= 2` is unnecessary since the second one is stronger and thus `x >= 1` is redundant. Similarly, having invariants `x > 0`, `y > 0` and `x + y > 0` is redundant since the first two invariants together imply the third one.

                You should terminate your answer with a triple-quoted code block containing a YAML object with fields `prob_incorrect` and `prob_redundant`. For each of those fields, you should provide a confidence score as a number between 0 and 1.
            - role: user
              content: |-
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x = y }  (* GOAL *)
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                Exactly one proof obligation failed, which is named: `VC for main (loop invariant init)`.
          answer: |-
            To analyze the annotations and identify issues:

            1. **Invariant not holding initially:**
               - The loop invariant given is `x = y`.
               - Before the loop begins, it's assumed that `0 ≤ x ≤ 2` and `0 ≤ y ≤ 2`.
               - However, there is no direct assumption or operation ensuring that `x = y` holds before the loop starts.
               - The failing proof obligation `VC for main (loop invariant init)` specifically checks if the invariant holds initially (before the first iteration), suggesting the invariant might not initially hold.

            2. **Redundant Invariants:**
               - The invariant `x = y` is the only invariant provided for the loop.
               - There are no other invariants to compare and identify redundancy since only one invariant is given.

            Based on this analysis:

            - The failing proof obligation likely indicates that the invariant `x = y` does not initially hold. The presence of the failing VC strongly suggests this is incorrect as there is no evidence from the premises to conclude `x = y` initially.

            - Since there is only a single invariant provided, the question of redundancy doesn't arise here.

            ```yaml
            prob_incorrect: 1.0
            prob_redundant: 0.0
            ```
      - message: Answer received
        node: 17
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x = y }  (* GOAL *)
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?
          answer: |-
            To understand the verification problem, let's analyze the program:

            1. There are two variables `x` and `y` both of which are initialized to any integer value within defined bounds.
            2. Four key assumptions specify the bounds: 
               - `0 <= x <= 2`
               - `0 <= y <= 2`
            3. The loop invariant is stated as `x = y`, aiming to ensure these two variables remain equal throughout the execution.
            4. In each loop iteration, both `x` and `y` are incremented by 2.

            Given the assumptions, both `x` and `y` start at a value between 0 and 2. However, the invariant `x = y` may not hold initially when entering the loop, since `x` and `y` might start with different values that respect the bounds independently. 

            To fix the proof obligation, we need an invariant that holds before the first iteration of the loop. Since both `x` and `y` start within the bounds and there's no prior condition ensuring they are equal before the loop starts, a simple solution is to add an invariant guaranteeing that initially `x - y` does not change by loop iterations.

            To ensure the invariant holds initially and is maintained by the loop, we can add the invariant `x - y = c` for some constant `c` in the range of possible value differences. Since the operation `x <- x + 2` and `y <- y + 2` maintains `x - y` unchanged, the invariant `x - y = c` remains true for all iterations.

            Thus, adding `x - y = c` for some appropriate constant `c` (which can be deduced using the initial bounds) will help ensure the proof of the invariant `x = y`. A suitable choice for `c` is any integer from the set { -2, -1, 0, 1, 2 }, considering possible initial differences under the assumed bounds.

            We can choose simple invariant as `x - y = 0` since it would guarantee their equality. But this assumption might help in achieving `x = y` as per the present state of outer environment in while loop.

            Here's the change with the additional loop invariant:

            ```yaml
            - "x - y >= -2"
            - "x - y <= 2"
            ```
      - message: Answer received
        node: 21
        space: eval
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                I will show you an annotated program in which Why3 did not manage to prove a particular proof obligation. You must determine two things:

                1. Whether the failing proof obligation is about an invariant not holding initially. In this case, there is no hope to fix the proof by adding new invariants and so the invariant in question must be incorrect.
                2. Whether or not the shown program features redundant invariants. For example, having both invariants `x >= 1` and `x >= 2` is unnecessary since the second one is stronger and thus `x >= 1` is redundant. Similarly, having invariants `x > 0`, `y > 0` and `x + y > 0` is redundant since the first two invariants together imply the third one.

                You should terminate your answer with a triple-quoted code block containing a YAML object with fields `prob_incorrect` and `prob_redundant`. For each of those fields, you should provide a confidence score as a number between 0 and 1.
            - role: user
              content: |-
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x - y >= -2 }  (* premise *)
                    invariant { x - y <= 2 }  (* premise *)
                    invariant { x = y }  (* GOAL *)
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                Exactly one proof obligation failed, which is named: `VC for main (loop invariant init)`.
          answer: |-
            To understand why the proof obligation failed, let us review the loop invariants being used and their initial conditions:

            1. **Loop invariants**:
               - \( x - y \geq -2 \)
               - \( x - y \leq 2 \)
               - \( x = y \)

            2. **Assumed initial conditions**:
               - \( 0 \leq x \leq 2 \)
               - \( 0 \leq y \leq 2 \)

            The specific invariant that failed is `x = y` during initialization. Given \( 0 \leq x \leq 2 \) and \( 0 \leq y \leq 2 \), it is not guaranteed that \( x = y \). This clearly indicates that `x = y` is not satisfied initially for arbitrary values of \( x \) and \( y \) within their respective range.

            Now, let us consider redundancy among the invariants:
            - The invariants \( x - y \geq -2 \) and \( x - y \leq 2 \) form a range constraint \(-2 \leq x - y \leq 2\). However, adding \( x = y \) actually makes existing inequalities \( x - y \geq -2 \) and \( x - y \leq 2 \) redundant since \( x = y \) implies these, being much stronger. 

            Therefore:
            - **Probability that the invariant is incorrect** is high because \( x = y \) does not generally hold given arbitrary initial values \( x \) and \( y \).
            - **Probability of redundancy** is also high, considering how \( x = y \) implies the other inequalities about \( x - y \).

            Here is the YAML configuration reflecting this analysis:

            ```yaml
            prob_incorrect: 0.9
            prob_redundant: 0.8
            ```
      - message: Answer received
        node: 24
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x - y >= -2 }  (* premise *)
                    invariant { x - y <= 2 }  (* premise *)
                    invariant { x = y }  (* GOAL *)
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x - y >= -2', 'x - y <= 2']
          answer: |-
            The issue in the current annotated program lies in establishing an appropriate invariant that shows `x = y` holds at the start of the loop. The existing invariants do not ensure that `x` begins equal to `y` when the loop starts.

            Given the assumptions:
            - `0 <= x <= 2`
            - `0 <= y <= 2`

            And considering the assertion to prove is `x = y`, the common initial value that both variables might take is the lower bound, which is `0`. It suggests that an invariant we could use is `x = y = 0` initially.

            The loop modifies both `x` and `y` by adding `2` in each iteration. If `x` starts equal to `y`, they remain equal as both are incremented by the same amount. To prove the initial loop invariant, we should state that:

            - `x = y initially`, with `x = y` starting at `0`.

            Given this understanding, we should propose the following invariant as part of potential solutions that could help Why3 verify the goal:

            ```yaml
            - 'x = y = 0'
            ```
      - message: Answer received
        node: 25
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x - y >= -2) && (x - y <= 2)`

                New formula: `(x = y = 0)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula `(x = y = 0)` is equivalent to the blacklist formula `(x - y >= -2) && (x - y <= 2)`, we must compare their logical meanings.

            The blacklist formula `(x - y >= -2) && (x - y <= 2)` means that the difference between `x` and `y` lies within the range of `-2` to `2`, inclusive. This implies any pair of integers where the absolute difference between them is 2 or less, i.e., `x - y` can be `-2, -1, 0, 1, or 2`.

            The new formula `(x = y = 0)` is a compound equation form, which can be interpreted typically in two parts: 
            1. `x = 0`
            2. `y = 0`

            This means both `x` and `y` are exactly zero. The interpretation `x = y = 0` can sometimes be considered ambiguous in mathematical texts but in programming and logical contexts, it often will represent a conjunction of both variables being zero.

            To determine if these formulas are equivalent, consider:
            - The blacklist formula `(x - y >= -2) && (x - y <= 2)` allows for:
              - `x = y = -2, -1, 0, 1, 2`
              - and any combinations where absolute difference is 2: `(x=0, y=2)`, `(x=2, y=0)`, etc.
              
            - The new formula `(x = y = 0)` specifically represents just the condition where both `x` and `y` are zero.

            Therefore, `(x = y = 0)` is a specific case of the general condition `(x - y >= -2) && (x - y <= 2)` but not equivalent since the latter includes more cases.

            Thus, the new formula is novel, distinct from the listed ones.

            ```
            yes
            ```
      - message: Answer received
        node: 30
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
          answer: |-
            To fix the proof and enable Why3 to verify the assertion, we need to introduce loop invariants that capture the relationship between `x` and `y` throughout the loop execution. Analyzing the premises and the behavior within the loop:

            Initially, both `x` and `y` can be either 0, 1, or 2. The loop increments both `x` and `y` by 2 during each iteration, meaning they both maintain the same parity and increase by the same amount. The loop invariant can capture this behavior:

            1. We know that both `x` and `y` start at values between 0 and 2, inclusive.
            2. Both `x` and `y` are incremented by 2 on each iteration.
            3. Thus, the difference between `x` and `y` stays constant throughout the loop.

            Given that we want to verify the assertion `assert { x <> 4 }` when `y = 0`, consider that if `y` were 0 after the loop, then considering the initial assumptions and the invariants, it would imply that `x` would have been incremented by the same amount starting from a value that makes it impossible to become 4, due to staying within the bounds given by the assumptions.

            So, the potential crucial invariant could be maintaining the difference `x - y`:

            ```yaml
            - 'x - y = 0'
            ```

            This suggests that the difference between `x` and `y` remains constant throughout their incrementation, helping prove that the assertion holds under the given assumptions.
      - message: Answer received
        node: 31
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`

                New formula: `(x - y = 0)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            Let's analyze the formulas.

            1. Blacklist formula: `(x = y)`
               - This formula denotes that the value of `x` is equal to the value of `y`.

            2. New formula: `(x - y = 0)`
               - When `x - y = 0`, it means that `x` and `y` are equal, as subtracting `y` from `x` results in zero. This is logically equivalent to saying `x = y`.

            The new formula `(x - y = 0)` is logically equivalent to the blacklisted formula `(x = y)`.

            Therefore, the new formula is not distinct from the blacklisted formulas.

            ```
            no
            ```
      - message: Answer received
        node: 30
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
          answer: |-
            To address the proof obligation failure in the program, we need to ensure that the assertion `x <> 4` holds whenever `y = 0`. Given that the loop increments both `x` and `y` by 2, and considering the initial values of `x` and `y` are both within the range [0, 2], we should focus on maintaining the relationship between `x` and `y` such that `y = 0` can never co-occur with `x = 4`.

            From the assumptions provided, we know:
            - `0 <= x <= 2` initially
            - `0 <= y <= 2` initially
            - Both `x` and `y` are incremented by 2 in each iteration of the loop.

            Since `x` and `y` are incremented by the same amount, their difference remains constant throughout the loop. To ensure the assertion holds, we need to capture the invariant relationship between `x` and `y` throughout the loop's execution.

            The proposition is that if `y = 0`, then the difference between `x` and `y` prevents `x` from being 4, given the initial constraints. Initially, we have several possible pairs for `(x, y)`: (0,0), (0,2), (2,0), (2,2). With both `x` and `y` being incremented by 2 each time, `y` being 0 means it must have started at 0 and its difference to `x` should always be even.

            The missing invariant relates specifically to maintaining the parity and sum constraints on x and y to avoid the forbidden (4,0) state.

            Here’s a reasonable invariant to suggest:

            ```yaml
            ["x - y = 0 || x - y = 2"]
            ```

            This invariant helps to ensure that if `y` ever becomes 0 again, `x` would be constrained to maintain the invariant involving their constant difference, so `x` cannot become 4 starting from their possible initializations.
      - message: Answer received
        node: 33
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`

                New formula: `(x - y = 0 || x - y = 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To assess whether the new formula is equivalent to any of the blacklisted formulas, let's evaluate both concepts individually:

            1. The first blacklisted formula is `(x mod 2 = 0) && (y mod 2 = 0)`: This indicates that both `x` and `y` are even numbers.

            2. The second blacklisted formula is `(x = y)`: This indicates that `x` is equal to `y`.

            Now, examining the new formula `(x - y = 0 || x - y = 2)`:

            - The condition `x - y = 0` implies that `x` is equal to `y`. This part of the new formula directly matches the second blacklisted formula `(x = y)`.

            - The condition `x - y = 2` states that the difference between `x` and `y` is 2, which is not covered by either of the blacklisted formulas on its own.

            However, since the new formula includes the sub-condition `x - y = 0`, which is equivalent to the blacklisted formula `(x = y)`, the new formula is not novel and matches part of one of the existing blacklisted formulas.

            Thus, the new formula is not distinct from the blacklisted ones. 

            ```
            no
            ```
      - message: Answer received
        node: 30
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
          answer: |-
            To address the failed proof, we need to focus on the values of `x` and `y` as the program executes and ensure useful properties of these variables are maintained. The loop modifies both variables in the same way: it adds `2` to both `x` and `y`. Also, considering the invariants `x >= 0`, `x <= 2`, `y <= 2`, and `y >= 0`, and knowing that both `x` and `y` start within this range, it suggests a relation or constant difference between them could be maintained.

            To solve the problem, we must prevent `x` from reaching 4 when `y` equals 0. From the initialization assumptions, it seems that any further increment keeps `x` and `y` equal. Thus, for `y = 0` to hold post-loop, maintaining the invariant `x = y + c` for a constant `c` could help guarantee the required condition.

            Analyzing the initial premises, possible invariants that could assist in proving the post-condition include:
            - `x <= y + 2`: This accounts for ensuring that even as both variables increment, `x` doesn't exceed a bound related to `y`.

            Adding these invariants to the loop should assist in Why3 completing the verification.

            ```yaml
            - 'x <= y + 2'
            ```
      - message: Answer received
        node: 30
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
          answer: |-
            To help Why3 prove the assertion, we should add appropriate loop invariants that capture the relationship between `x` and `y` in every iteration of the loop. Let's examine the situation:

            1. Initially, we know through the assumptions:
               - \( x \) and \( y \) both start in the range [0, 2].
               - After each loop iteration, both `x` and `y` are incremented by 2.

            2. We have to prove:
               - If \( y = 0 \), then \( x \neq 4 \).

            Let's evaluate the situation where \( y = 0 \):
            - Given \( y \) starts between 0 and 2 and increments by 2, it can go through values: 0, 2, 4, ...
            - Assuming \( y = 0 \) means no increment occurred, implying `x` must also not have incremented to reach the value of 4.

            Thus, \( x \) must remain within the starting range unless it increments. To facilitate this, a relevant loop invariant could be that \( x \) and \( y \) remain in synchronized increments:

            - \( |x - y| \) is invariant over the execution of the loop since both `x` and `y` are incremented by the same amount.

            This reasoning leads to a possible loop invariant:

            - \( x - y = k \) for some initial state difference \( k \) (here, we can choose \( k = 0 \), since initially \( x \geq 0 \), \( x \leq 2 \) and \( y \geq 0 \), \( y \leq 2 \)).

            Here is a suitable invariant suggestion:

            ```yaml
            [
              "x - y = 0"
            ]
            ```
      - message: Answer received
        node: 36
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`

                New formula: `(x - y = 0)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine whether the new formula `(x - y = 0)` is equivalent to any of the blacklisted formulas, we will examine each blacklist item:

            1. **Blacklist Formula 1**: `(x mod 2 = 0) && (y mod 2 = 0)` 

               This formula checks if both `x` and `y` are even numbers. It has no direct relation to the formula `(x - y = 0)`, which checks the equality of `x` and `y`. Therefore, they are not equivalent.

            2. **Blacklist Formula 2**: `(x = y)`

               This formula checks if `x` is equal to `y`. The formula `(x - y = 0)` simplifies to the same condition because subtracting `y` from `x` resulting in zero implies that `x` is equal to `y`. Therefore, these formulas are equivalent.

            Since the new formula `(x - y = 0)` is equivalent to the blacklisted formula `(x = y)`, the new formula is not distinct from the blacklist.

            ```
            no
            ```
      - message: Answer received
        node: 30
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
          answer: |-
            To solve this issue, we need to identify a loop invariant that can help prove the assertion. The premises state that both `x` and `y` initially range between 0 and 2. The loop increases both `x` and `y` by 2 iteratively. If `y` is 0, it must have remained 0 through the loop (as 0 is unchanged with increments of 2), implying `x` would remain constant (at 2 or below, according to premises), thus can't become 4.

            However, since `y = 0` implies it hasn't changed, and `x` starts with 0, 1 or 2, the line `assert { x <> 4 }` will hold.

            To support this, here are a couple of invariant suggestions you might try:

            - Ensure `y` and `x` maintain certain properties related to their starting values or relationship to each other.

            ```yaml
            - 'x + y <= 4'
            - 'x <= 2'
            ``` 

            These invariants help ensure that even as the loop progresses, `x` and `y` together do not increase beyond a reachable sum, considering initial assumptions and increments made during the loop.
      - message: Answer received
        node: 38
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`

                New formula: `(x + y <= 4) && (x <= 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula `(x + y <= 4) && (x <= 2)` is equivalent to the listed formulas, let's analyze each formula:

            1. **Formula 1**: `(x mod 2 = 0) && (y mod 2 = 0)`
               - This formula states that both `x` and `y` are even numbers.
               - It specifies a condition on the parity of `x` and `y`, but does not specify any particular limits on the sum `x + y` or specific values for `x`.
               - The new formula `(x + y <= 4) && (x <= 2)` involves constraints on the sum of `x` and `y` and a maximum value for `x`. There is no restriction on the parity of `x` and `y`, only on their magnitude.
               - Therefore, the new formula is not equivalent to this one.

            2. **Formula 2**: `(x = y)`
               - This formula states that `x` and `y` have the same value.
               - It does not involve the conditions `x + y <= 4` or `x <= 2`.
               - The new formula imposes upper limits on the sum of `x` and `y` and restricts `x` to be less than or equal to 2.
               - The constraints are not inherently about equivalence between `x` and `y`, and there are numerous scenarios where `x` and `y` are not equal but still satisfy the new formula.
               - Therefore, the new formula is not equivalent to this one.

            Since the new formula does not match any of the conditions present in either blacklisted formula, it is distinct from both.

            ```
            yes
            ```
      - message: Answer received
        node: 43
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
                - ['x + y <= 4', 'x <= 2']
          answer: |-
            To help prove the failed assertion in the program, we need to suggest invariants that help show that `x` is not equal to `4` if `y` equals `0` after the loop. Based on the provided premises and failed attempts, it seems that the problem might be related to the growth of `x` and `y` within the loop in relation to the given premises.

            The loop increments both `x` and `y` by `2`. Given the initial constraints (both start at `0`, `1`, or `2`), `x` and `y` are both even numbers throughout the loop execution. Thus, for `y` to be `0` at the end, it must not have been incremented, and `x` should not have been incremented beyond its starting point (`x <= 2`).

            Let's consider invariants related to their difference and an implication with respect to `y` being `0`:

            1. The simplest useful invariants can consider that because `x` and `y` increment equally, their difference should remain constant, related to their initial values.
            2. `x - y` can help define a range that does not allow `x` to equal `4` when `y` is `0`.

            Given these constraints, we will define the following invariants:

            ```yaml
            ['x - y <= 2', 'x <= 2']
            ```
      - message: Answer received
        node: 44
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`
                  - `(x + y <= 4) && (x <= 2)`

                New formula: `(x - y <= 2) && (x <= 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula `(x - y <= 2) && (x <= 2)` is equivalent to any of the blacklisted formulas, let's analyze the logical conditions:

            1. **New Formula:**
               - `(x - y <= 2)` indicates the difference between `x` and `y` is at most 2.
               - `(x <= 2)` restricts `x` to be at most 2.

            2. **Blacklist Formulas:**
               - `(x mod 2 = 0) && (y mod 2 = 0)`: This condition ensures both `x` and `y` are even numbers. It doesn't directly relate to the new formula.
               - `(x = y)`: This is a specific equality condition, which is more restrictive than `(x - y <= 2)`. The new formula allows differences within 2 units, so they aren't equivalent.
               - `(x + y <= 4) && (x <= 2)`: This can be compared more directly.
                 - The condition `(x <= 2)` is the same in both formulas.
                 - The condition `(x + y <= 4)` restricts the sum of `x` and `y`. To transform this into a similar form as `(x - y <= 2)`, we consider possible values:
                   - Given `x <= 2`, valid tuples for `(x, y)` matching `(x + y <= 4)` are `(0, 0)`, `(1, 0)`, `(1, 1)`, `(2, 0)`, `(2, 1)`, `(2, 2)`.
                   - For the new formula `(x - y <= 2)`, valid tuples matching `x <= 2` are all those in which `x` is at most 2 more than `y`.

            By evaluating some specific instances, the tuples that satisfy `(x - y <= 2) && (x <= 2)` are a superset of those that satisfy `(x + y <= 4) && (x <= 2)`. For example, the tuple `(2, 3)` satisfies `(x - y <= 2)` but does not satisfy `(x + y <= 4)`. Therefore, they are not equivalent.

            Thus, the new formula is distinct from every condition in the blacklist. 
            ```no```
          parse_error: No final code block found.
      - message: Answer received
        node: 44
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`
                  - `(x + y <= 4) && (x <= 2)`

                New formula: `(x - y <= 2) && (x <= 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula `(x - y <= 2) && (x <= 2)` is equivalent to any of the blacklisted formulas, let's analyze each one:

            1. **Blacklist formula**: `(x mod 2 = 0) && (y mod 2 = 0)`
               - This formula checks if both `x` and `y` are even numbers.
               - The new formula does not make any assertions about the parity (evenness or oddness) of `x` or `y`, so it cannot be equivalent to this blacklisted formula.

            2. **Blacklist formula**: `(x = y)`
               - This formula checks if `x` is equal to `y`.
               - The new formula involves a difference, `(x - y <= 2)`, allowing `x` and `y` to differ by up to 2, but it also contains the condition `(x <= 2)`, thus possibly restricting some values. However, there is no constraint that forces `x` to be equal to `y` for all integer values, particularly for values like `x = 2`, `y = 0`, where `x != y`. Therefore, it cannot be equivalent to the statement that `x = y` necessarily.

            3. **Blacklist formula**: `(x + y <= 4) && (x <= 2)`
               - The blacklisted formula imposes constraints on the sum of `x` and `y` and the value of `x`.
               - The new formula does not directly constrain the sum of `x + y`, but it does impose restrictions involving `x - y`. They are two separate, although somewhat related conditions.
               - Let's consider an evaluation:
                 - In the new formula, if we take `x = 2`, the limit for `y` based on `(x - y <= 2)` is `y >= 0`.
                 - Thus for `x = 2`, `y` can be `0, 1, 2, 3...`.
                 - For `x = 2`, the blacklisted formula would allow values only up to `y = 2` for their sum to be at most 4, i.e., `(x + y = 4)`.
               - This shows that while there might be overlap for certain domain values (like `x = 1 or 0`), generally they aren't the same condition, particularly evident when considering the introduction of positive values for `y` while observing their sums in the blacklisted object.

            Given that none of the blacklisted formulas fully encapsulates the conditions imposed by the new formula, we conclude that the new formula is distinct from those on the blacklist.

            ```
            yes
            ```
      - message: Answer received
        node: 48
        space: eval
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                I will show you an annotated program in which Why3 did not manage to prove a particular proof obligation. You must determine two things:

                1. Whether the failing proof obligation is about an invariant not holding initially. In this case, there is no hope to fix the proof by adding new invariants and so the invariant in question must be incorrect.
                2. Whether or not the shown program features redundant invariants. For example, having both invariants `x >= 1` and `x >= 2` is unnecessary since the second one is stronger and thus `x >= 1` is redundant. Similarly, having invariants `x > 0`, `y > 0` and `x + y > 0` is redundant since the first two invariants together imply the third one.

                You should terminate your answer with a triple-quoted code block containing a YAML object with fields `prob_incorrect` and `prob_redundant`. For each of those fields, you should provide a confidence score as a number between 0 and 1.
            - role: user
              content: |-
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x - y <= 2 }  (* premise *)
                    invariant { x <= 2 }  (* GOAL, premise *)
                    x <- x + 2;  (* premise *)
                    y <- y + 2  (* premise *)
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                Exactly one proof obligation failed, which is named: `VC for main (loop invariant preservation)`.
          answer: |-
            To determine the issue with the failing proof obligation for the loop invariant preservation, we need to check if the given invariants are correctly maintained throughout the loop execution. Specifically, we look at the logic inside the loop and verify against the invariants.

            1. **Loop Logic Analysis:**
               - The loop invariants provided are `x - y <= 2` and `x <= 2`.
               - Inside the loop, the operations `x <- x + 2` and `y <- y + 2` are executed.

            2. **Invariant Check:**
               - Invariant `x <= 2` will not hold after the first iteration if initially `x <= 2` and `x` is incremented by 2, given the proposition that `x` can start as 2.
               - However, the invariant `x - y <= 2` should hold since both `x` and `y` increase equally by 2.

            3. **Invariants Redundancy Check:**
               - The invariant `x <= 2` is not redundant but incorrectly maintained. The invariant `x - y <= 2` is necessary to ensure a consistent relationship between `x` and `y`.
               - No redundancies are immediately obvious since the two invariants address different aspects: one about the absolute value of `x` and the other about the relationship between `x` and `y`.

            **Conclusion:**
            The failing proof obligation (loop invariant preservation) suggests that not all invariants are preserved by the loop body. Specifically, the `x <= 2` invariant cannot be preserved through loop iterations, indicating it is likely incorrect after `x` is updated. Thus, it should be revisited or potentially removed or adjusted. There's no clear redundancy, but any removal or modification of invariants should be done to ensure correctness without redundancy.

            ```yaml
            prob_incorrect: 0.9
            prob_redundant: 0.1
            ```
      - message: Answer received
        node: 51
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x - y <= 2 }  (* premise *)
                    invariant { x <= 2 }  (* GOAL, premise *)
                    x <- x + 2;  (* premise *)
                    y <- y + 2  (* premise *)
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant preservation)`. Can you fix this?
          answer: |-
            The proof obligation that failed is the preservation of the loop invariant `x <= 2`. The issue likely arises because the assignment `x <- x + 2` could potentially invalidate this condition since `x` can increase beyond the value of 2 during the loop.

            To fix the situation, we need to revise or complement the invariants to account for the assignment to `x`. The loop invariants should ensure that the modifications done within the loop do not violate the goals upon iterations.

            One possible invariant that may help establish the preservation of `x <= 2` is one that tracks the changes in `x` and `y` relative to the loop's body:

            - As `x` and `y` are increased by 2 together, we could track their difference.
            - Since the difference `x - y` is already invariant within the bounds 2 as `x` and `y` are changed uniformly, this differential can be maintained to aid additional proofs.

            From these observations, we want to introduce an invariant that helps in maintaining the assertion and constraints across iterations. An invariant `x <= y` could be added to maintain the relation, as the initial assumptions and assignments maintain this relation.

            Let's list the invariants we deduced to close the proof obligation:

            ```yaml
            - "x - y <= 2"
            - "x <= 2"
            - "x <= y"
            ```
      - message: Answer received
        node: 56
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x - y <= 2 }  (* premise *)
                    invariant { x <= 2 }  (* GOAL, premise *)
                    x <- x + 2;  (* premise *)
                    y <- y + 2  (* premise *)
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant preservation)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x - y <= 2', 'x <= 2', 'x <= y']
          answer: |-
            From the information you provided, the loop is increasing both `x` and `y` by 2 in each iteration. The assumptions indicate the initial bounds on `x` and `y`, and the invariants given try to express the relationship between `x` and `y`.

            The failed goal is to maintain `x <= 2` as an invariant, which obviously becomes impossible since `x` is incremented by 2 within every iteration of the loop. Given these premises and considering what has already been attempted, we need to seek a different invariant that represents the relationship of `x` and `y` as they increment equally.

            Let's try an invariant that captures an invariant relationship between `x` and `y` during this loop. Noting both are incremented by exactly 2 in every iteration, that means that their difference remains a constant number from its initial value, thus yielding a valid invariant:

            ```yaml
            [
              "x - y = 0"
            ]
            ```
      - message: Answer received
        node: 57
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x - y <= 2) && (x <= 2) && (x <= y)`

                New formula: `(x - y = 0)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula `(x - y = 0)` is equivalent to the blacklisted formula `(x - y <= 2) && (x <= 2) && (x <= y)`, we need to consider the logical constraints expressed by each formula:

            1. **New Formula:** `(x - y = 0)`:
               - This formula simply means that `x` is equal to `y`.

            2. **Blacklisted Formula:** `(x - y <= 2) && (x <= 2) && (x <= y)`:
               - `(x - y <= 2)` means that `x` is at most 2 units greater than `y`.
               - `(x <= 2)` means that `x` itself is at most 2.
               - `(x <= y)` means that `x` is less than or equal to `y`, or in other words, `y` is greater than or equal to `x`.

            The blacklisted formula allows for several possibilities within the constraints:
            - Since `x - y <= 2` and `x <= y`, `x` can be equal to `y`, but it could also be less than `y` by up to 2 units.
            - The condition `x <= y` is critical because it restricts `x` to be less than or equal to `y`, but not necessarily equal unless `x` is truly equal to `y`.

            In contrast, the new formula strictly requires `x` to be equal to `y` with no deviation. Given this analysis, the new formula is distinct because the blacklisted formula allows for more cases (where `x` can be strictly less than `y`), while the new formula only matches when `x` is exactly equal to `y`.

            Therefore, the new formula is distinct from the blacklisted one.

            ```
            yes
            ```
      - message: Answer received
        node: 62
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x - y >= -2 }  (* premise *)
                    invariant { x - y <= 2 }  (* premise *)
                    invariant { x = y }  (* GOAL *)
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?
          answer: |-
            To resolve the failed proof obligation `VC for main (loop invariant init)`, we need to establish a correct set of loop invariants that hold true at the beginning and throughout the execution of the loop.

            From the given premises:
            - `x >= 0` 
            - `x <= 2` 
            - `y <= 2`
            - `y >= 0`

            And the loop specification:
            - `x - y >= -2`
            - `x - y <= 2`

            We are trying to ensure that `x = y` is a valid invariant at the beginning of the loop and throughout.

            Since both `x` and `y` are incremented by `2` in each loop iteration, whatever relationship holds between `x` and `y` once, will continue to hold. To address the failed invariant initialization, we need to ensure that `x = y` holds true from the start.

            From the given assumptions, both `x` and `y` can take the values `0, 1, or 2` initially. For the invariant `x = y` to hold from the start, we need to add an initial condition that explicitly sets `x` equal to `y`.

            Here's the list of new loop invariants to try:

            ```yaml
            [
              "x = y"
            ]
            ```
      - message: Answer received
        node: 66
        space: eval
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                I will show you an annotated program in which Why3 did not manage to prove a particular proof obligation. You must determine two things:

                1. Whether the failing proof obligation is about an invariant not holding initially. In this case, there is no hope to fix the proof by adding new invariants and so the invariant in question must be incorrect.
                2. Whether or not the shown program features redundant invariants. For example, having both invariants `x >= 1` and `x >= 2` is unnecessary since the second one is stronger and thus `x >= 1` is redundant. Similarly, having invariants `x > 0`, `y > 0` and `x + y > 0` is redundant since the first two invariants together imply the third one.

                You should terminate your answer with a triple-quoted code block containing a YAML object with fields `prob_incorrect` and `prob_redundant`. For each of those fields, you should provide a confidence score as a number between 0 and 1.
            - role: user
              content: |-
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x = y }  (* GOAL *)
                    invariant { x - y >= -2 }
                    invariant { x - y <= 2 }
                    invariant { x = y }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                Exactly one proof obligation failed, which is named: `VC for main (loop invariant init)`.
          answer: |-
            The failure of the proof obligation `VC for main (loop invariant init)` suggests that the issue lies in establishing that the loop invariants hold initially, before entering the loop.

            Now, let's examine the loop invariants that are stated in the program:

            1. `invariant { x = y }`
            2. `invariant { x - y >= -2 }`
            3. `invariant { x - y <= 2 }`
            4. `invariant { x = y }`

            Given the initial assumptions:
            - `x >= 0`
            - `x <= 2`
            - `y >= 0`
            - `y <= 2`

            1. Invariant: `{ x = y }`
               - With the premises, we have `0 <= x, y <= 2`. However, there is no guarantee that `x` and `y` are equal initially. Thus, `x = y` as an invariant is not guaranteed to hold initially, suggesting a potential issue.

            2. Invariant: `{ x - y >= -2 }`
               - Since both `x` and `y` are between `0` and `2`, the difference `x - y` initially can range from `-2` to `2`. Hence, the invariant `x - y >= -2` is satisfied initially.

            3. Invariant: `{ x - y <= 2 }`
               - Similar reasoning as above shows that this invariant also holds initially since `x - y` is at most `2`.

            4. Redundancy check:
               - Invariant `x = y` appears twice, which is unnecessary redundancy.
               - Considering redundancy about the differences, with `x = y`, the other conditions `x - y >= -2` and `x - y <= 2` are automatically fulfilled. Thus, `x = y` alone is a stronger condition than the other two, implying these two are redundant if `x = y` could hold.

            From the analysis, it appears:
            - The invariant `x = y` does not necessarily hold initially and is likely incorrect.
            - Invaraints `{ x - y >= -2 }` and `{ x - y <= 2 }` are redundant if `x = y` would be a valid invariant.

            Thus, most likely reasons for Why3 failing to prove the initial holding of invariants are:
            - `x = y` holding initially is false.
            - Redundant invariants also exist in the provided annotations.

            ```yaml
            prob_incorrect: 0.9
            prob_redundant: 0.8
            ```
      - message: Answer received
        node: 68
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
                - ['x + y <= 4', 'x <= 2']
                - ['x - y <= 2', 'x <= 2']
          answer: |-
            Based on the premises provided and the failure to prove the assertion `x <> 4`, the problem seems to relate to maintaining specific properties of `x` and `y` that could prevent `x` from ever reaching 4 even if `y` could become 0.

            Given the premises:
            - `x` and `y` both start in the range `[0, 2]`.
            - In each iteration of the loop, we add 2 to both `x` and `y` simultaneously.

            To prevent `x` from reaching 4 when `y` equals 0, we need to ensure a relationship between `x` and `y` that guarantees if `y = 0`, `x` will never equal 4.

            Notice that `x` and `y` always move together: they start at the same parity because they only differ by at most 2 initially, and they move in lock-step increments of 2. A useful invariant could be a linear relationship or constraint that leverages this fact.

            The key here is to ensure a certain difference or function of `x` and `y` remains bounded such that the condition `x = 4` is not possible when `y` becomes 0.

            Let's try utilizing the initial bounded differences and propose an invariant that confines the changes allowed in `x` and `y`:

            ```yaml
            [
              "0 <= x - y <= 2"
            ]
            ```
      - message: Answer received
        node: 69
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`
                  - `(x + y <= 4) && (x <= 2)`
                  - `(x - y <= 2) && (x <= 2)`

                New formula: `(0 <= x - y <= 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula is distinct from the blacklisted formulas, let's analyze both the blacklisted formulas and the new formula:

            1. Blacklisted Formulas:
               - `(x mod 2 = 0) && (y mod 2 = 0)`: This checks if both `x` and `y` are even numbers.
               - `(x = y)`: This checks if `x` is equal to `y`.
               - `(x + y <= 4) && (x <= 2)`: This checks if the sum of `x` and `y` is less than or equal to 4, and if `x` is less than or equal to 2.
               - `(x - y <= 2) && (x <= 2)`: This checks if the difference between `x` and `y` is less than or equal to 2, and if `x` is less than or equal to 2.

            2. Analyzing New Formula:
               - `(0 <= x - y <= 2)`: This checks if the difference between `x` and `y` is between 0 and 2, inclusive. In other words, this checks if `x` is greater than or equal to `y` and less than or equal to `y + 2`.

            Comparison:
            - The new formula checks that the difference `x - y` is between 0 and 2. This implies `y <= x <= y + 2`.
            - The blacklisted formula `(x - y <= 2) && (x <= 2)` checks that the difference `x - y` is at most 2 and `x` is at most 2, but it does not ensure `x >= y`. 

            The new formula is not equivalent to any of the blacklisted formulas. Therefore, it is distinct.

            ```
            yes
            ```
      - message: Answer received
        node: 73
        space: eval
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                I will show you an annotated program in which Why3 did not manage to prove a particular proof obligation. You must determine two things:

                1. Whether the failing proof obligation is about an invariant not holding initially. In this case, there is no hope to fix the proof by adding new invariants and so the invariant in question must be incorrect.
                2. Whether or not the shown program features redundant invariants. For example, having both invariants `x >= 1` and `x >= 2` is unnecessary since the second one is stronger and thus `x >= 1` is redundant. Similarly, having invariants `x > 0`, `y > 0` and `x + y > 0` is redundant since the first two invariants together imply the third one.

                You should terminate your answer with a triple-quoted code block containing a YAML object with fields `prob_incorrect` and `prob_redundant`. For each of those fields, you should provide a confidence score as a number between 0 and 1.
            - role: user
              content: |-
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { 0 <= x - y <= 2 }  (* GOAL *)
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                Exactly one proof obligation failed, which is named: `VC for main (loop invariant init)`.
          answer: |-
            In this problem, the failing proof obligation is `VC for main (loop invariant init)`, which indicates that the loop invariant does not hold initially. 

            The loop invariant is given as:

            ```ml
            invariant { 0 <= x - y <= 2 }
            ```

            We need to check this invariant with the initial assumptions:

            ```ml
            assume { x >= 0 };
            assume { x <= 2 };
            assume { y <= 2 };
            assume { y >= 0 };
            ```

            For the invariant `0 <= x - y <= 2` to hold initially, we need:

            1. \(0 \leq x - y\) meaning:
               - \(x \geq y\)

            2. \(x - y \leq 2\) meaning:
               - \(x \leq y + 2\)

            Observe the combinations:

            - From `x >= 0` and `y <= 2`, it implies x - y can be at least \(0 - 2 = -2\), therefore, the left part of the first condition might fail initially.

            Given the constraints:
            - \(x \leq 2\)
            - \(y \geq 0\)

            The actual value of \(x - y\) lies between -2 to 2. 

            Since \(x\) and \(y\) can be equal to 0, and there's no guarantee of their equality or their initial values, the invariant's condition (\(x \geq y\)) might not be initially true (invalid).

            This means that the invariant is likely incorrect since it doesn't necessarily hold true with the given constraints at the start.

            Now, the consideration of redundant invariants comes into play:
            The current program shows only a single invariant:
            - `0 <= x - y <= 2`

            There isn’t another invariant that could potentially make it redundant, unless `x` and `y` are symmetrically involved in the invariant where the invariant inherently cannot be made any smaller by itself. Since there is only this single invariant explicitly mentioned, it does not appear redundant by itself.

            Given these observations, here are the assessments:

            ```yaml
            prob_incorrect: 1.0
            prob_redundant: 0.0
            ```
      - message: Answer received
        node: 76
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { 0 <= x - y <= 2 }  (* GOAL *)
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?
          answer: |-
            The goal here is to provide an invariant for the initialization of the loop in order to prove the loop invariant holds initially. Examining the premises and the loop invariant, we can consider the following logical invariant for the loop:

            1. The invariant `0 <= x - y <= 2` must hold during the loop.
            2. Initially, we have the information from assumptions that `x >= 0`, `x <= 2`, `y >= 0`, and `y <= 2`.

            From these assumptions, it follows that `x - y` starts between `0` and `2` after initialization because both `x` and `y` are initialized to values within the [0, 2] range. 

            Thus, we need to assert that this relation holds initially, which is precisely the loop invariant. To further strengthen this, we can additionally conclude from the premises that `x - y >= 0`. This provides us with additional assurance that `x - y` falls within the range [0, 2] from the start. 

            Let's add this invariant explicitly to help the proof. 

            ```yaml
            [
                "0 <= x - y <= 2"
            ]
            ```
      - message: Answer received
        node: 80
        space: eval
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                I will show you an annotated program in which Why3 did not manage to prove a particular proof obligation. You must determine two things:

                1. Whether the failing proof obligation is about an invariant not holding initially. In this case, there is no hope to fix the proof by adding new invariants and so the invariant in question must be incorrect.
                2. Whether or not the shown program features redundant invariants. For example, having both invariants `x >= 1` and `x >= 2` is unnecessary since the second one is stronger and thus `x >= 1` is redundant. Similarly, having invariants `x > 0`, `y > 0` and `x + y > 0` is redundant since the first two invariants together imply the third one.

                You should terminate your answer with a triple-quoted code block containing a YAML object with fields `prob_incorrect` and `prob_redundant`. For each of those fields, you should provide a confidence score as a number between 0 and 1.
            - role: user
              content: |-
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { 0 <= x - y <= 2 }  (* GOAL *)
                    invariant { 0 <= x - y <= 2 }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                Exactly one proof obligation failed, which is named: `VC for main (loop invariant init)`.
          answer: |-
            The failing proof obligation `VC for main (loop invariant init)` indicates that the problem lies with the loop invariant not holding initially, not after the execution of the loop has modified any variables.

            The invariants given are:

            1. `0 <= x - y <= 2`
            2. `0 <= x - y <= 2` (repeated)

            To ensure the invariants hold initially, we must establish that, before entering the loop, the conditions for the invariants are satisfied with the initial values of `x` and `y`.

            From the assumptions, we know:
            - `0 <= x <= 2`
            - `0 <= y <= 2`

            We need `0 <= x - y <= 2` to hold, which means:

            - For `0 <= x - y`: Given `0 <= x` and `0 <= y`, `x - y` could theoretically be negative if `y > x`. This part of the proof obligation fails unless `x >= y`. However, this constraint is not given by the assumptions. Thus, the invariant `0 <= x - y` does not hold with the premises given, indicating that this loop invariant is indeed incorrect.

            - The upper bound `x - y <= 2` seems feasible given `x <= 2` and `y >= 0`.

            Thus, the problem indeed lies with the lower bound of the invariant, specifically "0 <= x - y," not holding initially due to lack of a guarantee that `x >= y`.

            Regarding redundancy, the second invariant `0 <= x - y <= 2` is exactly the same as the first and therefore is redundant. 

            Based on the program analysis, our confidence scores are:

            ```yaml
            prob_incorrect: 1
            prob_redundant: 0.9
            ```
      - message: Answer received
        node: 83
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { 0 <= x - y <= 2 }  (* GOAL *)
                    invariant { 0 <= x - y <= 2 }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['0 <= x - y <= 2']
          answer: |-
            To address the failed proof obligation `VC for main (loop invariant init)`, we need to ensure that the loop invariant is preserved at the beginning and at each iteration of the loop. The key is to identify a suitable loop invariant that covers the transitions of `x` and `y`.

            The initial conditions provided are `0 <= x <= 2` and `0 <= y <= 2`. The loop updates the variables by adding 2 to both `x` and `y` in every iteration. These updates will affect the initial invariant `0 <= x - y <= 2`, which holds.

            We need an additional invariant that can express how `x` and `y` evolve within the loop while still covering the permissible range as per the initial assumptions. A suitable invariant might involve maintaining the relative differences or equating their increments.

            Here's a suitable loop invariant that takes the relative increment pattern into account:

            1. Maintain the relationship between `x` and `y` by expressing it through an equality.
            2. Ensure the lower bound for x and y individually to maintain consistency and range.

            Given these points, the invariant can be:

            1. The difference between `x` and `y` should always be a multiple of 2.
            2. Both `x` and `y` are still in their initial range of `[0, 2]`.

            The proposed invariant that captures these conditions:

            ```yaml
            [
              "0 <= x <= 2",
              "0 <= y <= 2",
              "x mod 2 = y mod 2"
            ]
            ```

            This invariant ensures `x` and `y` are within bounds and have the same parity, reflecting their simultaneous updates by 2, maintaining the relationship throughout the loop.
      - message: Answer received
        node: 84
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(0 <= x - y <= 2)`

                New formula: `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)` is equivalent to the blacklisted formula `(0 <= x - y <= 2)`, we should analyze each part.

            1. **Blacklisted Formula**: This formula specifies that the difference between `x` and `y` is either 0, 1, or 2. This can be rewritten as: 
               - `x = y`,
               - `x = y + 1`, or
               - `x = y + 2`.

            2. **New Formula**: 
               - `0 <= x <= 2` indicates `x` can be 0, 1, or 2.
               - `0 <= y <= 2` indicates `y` can be 0, 1, or 2.
               - `x mod 2 = y mod 2` implies that `x` and `y` must both be either even or odd, i.e., they share the same parity.

            We need to verify if the constraints imposed by both formulas are equivalent.

            **Checking Equivalence**:
            - **Case 1**: `x = y`: Both are equivalent as in both, `x` and `y` can take values (0,0), (1,1), or (2,2) satisfying both mariginal constraints and shared parity.
            - **Case 2**: `x = y + 1`: The new formula can satisfy this if `x = 1` and `y = 0` (both can be true as (0 is even and 1 is odd. So overall they are not equal to each other).
            - **Case 3**: `x = y + 2`: The new formula can satisfy this if `x = 2` and `y = 0`, or `x = 2` and `y = 1`. Again both satisfy both the individual and parity constraints.
              
            For each case, we see that the new formula holds only if the blacklisted formula does as well, and vice versa. They represent the same conditions. 

            Hence, the new formula is not distinct; it is equivalent to the blacklisted formula.

            ```no```
          parse_error: No final code block found.
      - message: Answer received
        node: 84
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(0 <= x - y <= 2)`

                New formula: `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |
            To determine if the new formula `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)` is distinct from the blacklisted formula `(0 <= x - y <= 2)`, we need to analyze both formulas.

            1. **Analyzing the blacklisted formula `(0 <= x - y <= 2)`**:
               - This implies \( x - y = 0 \), \( x - y = 1 \), or \( x - y = 2 \).
               - Possible pairs \((x, y)\) satisfying this are:
                 - \( x = y \)
                 - \( x = y + 1 \)
                 - \( x = y + 2 \)

            2. **Analyzing the new formula `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)`**:
               - The conditions \(0 \leq x \leq 2\) and \(0 \leq y \leq 2\) indicate that both \(x\) and \(y\) can be 0, 1, or 2.
               - The condition \(x \mod 2 = y \mod 2\) implies:
                 - Both \(x\) and \(y\) must be either even or both must be odd.

            Let's list the possibilities for \((x, y)\) given this constraint and the ranges:

            - \(x = 0, y = 0\)
            - \(x = 1, y = 1\)
            - \(x = 2, y = 0\)
            - \(x = 0, y = 2\)
            - \(x = 2, y = 2\)

            Now we need to check if these pairs \((x, y)\) satisfy the blacklisted condition:

            - For \((x = 0, y = 0)\), \(x - y = 0\), satisfies \(0 \leq x - y \leq 2\).
            - For \((x = 1, y = 1)\), \(x - y = 0\), satisfies \(0 \leq x - y \leq 2\).
            - For \((x = 2, y = 0)\), \(x - y = 2\), satisfies \(0 \leq x - y \leq 2\).
            - For \((x = 0, y = 2)\), \(x - y = -2\), does not satisfy \(0 \leq x - y \leq 2\).
            - For \((x = 2, y = 2)\), \(x - y = 0\), satisfies \(0 \leq x - y \leq 2\).

            The pair \((x = 0, y = 2)\) does not satisfy the blacklisted condition while satisfying the new formula. Thus, the new formula is distinct from the blacklisted ones.

            ```no```
          parse_error: No final code block found.
      - message: Answer received
        node: 84
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(0 <= x - y <= 2)`

                New formula: `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula is equivalent to any formula in the blacklist, let's analyze both the blacklisted formula and the new formula.

            1. **Blacklisted formula `(0 <= x - y <= 2)`:**

               This formula implies that `x` and `y` are such that their difference is between 0 and 2, inclusive. In other terms:
               - `x` can be equal to `y`, `y + 1`, or `y + 2`.

            2. **New formula `(0 <= x <= 2) && (0 <= y <= 2) && (x mod 2 = y mod 2)`:**

               - It restricts `x` to be between 0 and 2, inclusive.
               - It restricts `y` to be between 0 and 2, inclusive.
               - It requires `x` and `y` to have the same parity (`x mod 2 = y mod 2`), meaning both are even or both are odd.

            Let's analyze possible values of `x` and `y` for the new formula:

            - If `x = 0` and `y` should be `0` to have the same parity (both even):
              - Modulo condition: `0 mod 2 = 0 mod 2`.
            - If `x = 1` and `y` should be `1` to have the same parity (both odd):
              - Modulo condition: `1 mod 2 = 1 mod 2`.
            - If `x = 2` and `y` should be `2` to have the same parity (both even):
              - Modulo condition: `2 mod 2 = 2 mod 2`.

            For the new formula, possible pairs `(x, y)` are therefore: `(0, 0)`, `(1, 1)`, `(2, 2)`.

            Now, let's check if these pairs satisfy the blacklisted formula:
            - `(0 <= x - y <= 2)` is true for each pair:
              - `(0, 0)`: `0 - 0 = 0`, which satisfies `0 <= 0 <= 2`.
              - `(1, 1)`: `1 - 1 = 0`, which satisfies `0 <= 0 <= 2`.
              - `(2, 2)`: `2 - 2 = 0`, which satisfies `0 <= 0 <= 2`.

            Given that the set of ordered pairs satisfying each formula is identical, the new formula is not novel.

            ```
            no
            ```
      - message: Answer received
        node: 83
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { 0 <= x - y <= 2 }  (* GOAL *)
                    invariant { 0 <= x - y <= 2 }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['0 <= x - y <= 2']
          answer: |-
            To understand the failure, let's first analyze the loop invariants and the assumptions provided:

            Before entering the loop, the assumptions give us:
            - `0 <= x <= 2`
            - `0 <= y <= 2`

            The failed invariant is `0 <= x - y <= 2`, which might not be initially maintained with every choice for `x` and `y` within their respective ranges.

            To prove loop invariants, we must ensure they hold upon entering the loop (initially), are maintained throughout the loop, and ensure the postcondition holds at termination.

            When the loop continues to work on variables `x` and `y`, they are incremented by 2:
            - `x <- x + 2`
            - `y <- y + 2`

            Initially, `x - y` could be between `-2` and `2` given the ranges for `x` and `y`. To maintain the invariant `0 <= x - y <= 2`, we need additional conditions to avoid negative values on initialization and also to hold as the loop continues.

            ### Key Observations:
            - Initially, the expression `x - y` could be negative when `x` is lower than `y`.
            - The current invariant does not cover the possibility that `x` and `y` are equal or that their relationship in values stays within bounds as both are incremented by 2 during the loop.

            A more suitable invariant should align the initial state and successive state updates:
            - `x - y` should indeed start between 0 and 2 considering the updates by 2.

            By re-evaluating the problem, a potential missing invariant considering initial setup could be:
            - `y <= x`

            This ensures that, initially, `0 <= x - y`, addressing the lower bound correctly given the assumption.

            Let's suggest this solution with the YAML configuration:

            ```yaml
            - "x >= y"
            ```
      - message: Answer received
        node: 83
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { 0 <= x - y <= 2 }  (* GOAL *)
                    invariant { 0 <= x - y <= 2 }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['0 <= x - y <= 2']
          answer: |-
            To address the issue with the failure of the `VC for main (loop invariant init)`, we need to ensure that the loop invariants are correctly initialized and preserved throughout the loop execution. The existing invariant `0 <= x - y <= 2` captures part of the needed constraint, but it may be insufficient or not precise enough to describe the state of all variables accurately.

            Given the assumptions that `0 <= x <= 2` and `0 <= y <= 2`, upon loop entry, it is necessary to establish invariants that capture the relationships between variables `x` and `y` that consider these initial conditions. The fact that `x` and `y` are incremented by 2 in every loop iteration can also provide valuable insights for defining a suitable invariant.

            Here is a suggestion for a new invariant that aligns with logical interpretations of the code's behavior:

            - An invariant that explicitly maintains both variable bounds and their relation: `0 <= x <= 2 && 0 <= y <= 2 && x - y = 0`. The first part `0 <= x <= 2 && 0 <= y <= 2` ensures that both variables start within their given bounded ranges, and the part `x - y = 0` conceptualizes that both `x` and `y` should increment proportionally, initially corresponding to the valid range `x - y = 0` when starting at `any bool`.

            ```yaml
            [
                "0 <= x <= 2",
                "0 <= y <= 2",
                "x - y = 0"
            ]
            ```
      - message: Answer received
        node: 87
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(0 <= x - y <= 2)`

                New formula: `(0 <= x <= 2) && (0 <= y <= 2) && (x - y = 0)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula is equivalent to the blacklisted formula, let's analyze both:

            1. **Blacklisted Formula**: 
               - `(0 <= x - y <= 2)`: 
                 This formula defines a range for the difference between `x` and `y`, allowing values `0`, `1`, and `2` for `(x - y)`.

            2. **New Formula**: 
               - `(0 <= x <= 2) && (0 <= y <= 2) && (x - y = 0)`: 
                 This formula imposes the following constraints:
                 - `x` is between `0` and `2` inclusive.
                 - `y` is between `0` and `2` inclusive.
                 - `x - y = 0`, which implies `x = y`.

            Combining these constraints, the new formula ensures both `x` and `y` are within the range [0, 2] and `x` must be equal to `y`. This means that for any values of `x` and `y` satisfying the new formula, we have `(x - y) = 0`, which is a specific case of the general range defined by the blacklisted formula `(0 <= x - y <= 2)`.

            Thus, since `(x - y = 0)` is covered in the range specified by `0 <= x - y <= 2`, the new formula is actually a subset of the blacklisted formula.

            Therefore, the new formula is not distinct; it is included in the constraints of the blacklisted formula.

            ```
            no
            ```
      - message: Answer received
        node: 83
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { 0 <= x - y <= 2 }  (* GOAL *)
                    invariant { 0 <= x - y <= 2 }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['0 <= x - y <= 2']
          answer: |-
            The proof obligation `VC for main (loop invariant init)` indicates that an initial or an intermediate loop invariant is not sufficient to establish the correctness of the program at the start of the loop. The existing invariants are about the relationship between `x` and `y`. However, the program modifies `x` and `y` in each iteration, and both start from some arbitrary values within the assumed bounds.

            To diagnose the invariant issue:
            - \( x \) and \( y \) can both start at values between 0 and 2.
            - After one iteration, both \( x \) and \( y \) are incremented by 2.
              
            Given these updates, one idea is to explicitly express the bounded nature of \( x \) and \( y \) through the iterations of the loop as invariants. This could be accomplished by bounding \( x \) (and thus indirectly, \( y \)) between their potential initial maximum and the maximum possible after any number of increments. Since \( x \) and \( y \) can maximum initial be 2 and increment every cycle by 2, \( x \le 2 \times n \) (where \( n \) is the number of loop iterations). Ensuring these bounds are considered may help establish the validity of \( x \) and \( y \)'s ranges throughout the loop.

            Let's try adding this invariant regarding each of `x` and `y`'s individual relationships by themselves:

            ```yaml
            [
              "0 <= x <= 2*n + 2",
              "0 <= y <= 2*n + 2"
            ]
            ```
      - message: Answer received
        node: 89
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(0 <= x - y <= 2)`

                New formula: `(0 <= x <= 2*n + 2) && (0 <= y <= 2*n + 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine whether the new formula `(0 <= x <= 2*n + 2) && (0 <= y <= 2*n + 2)` is equivalent to the blacklisted formula `(0 <= x - y <= 2)`, we need to analyze the expressions:

            1. Blacklisted formula: `(0 <= x - y <= 2)`
               - This describes a range for the difference between `x` and `y`. It implies that `x` can be at most 2 units greater than `y`.

            2. New formula: `(0 <= x <= 2*n + 2) && (0 <= y <= 2*n + 2)`
               - This describes a bounded range for both `x` and `y`. Both `x` and `y` can independently take values from `0` to `2*n + 2`.

            To check for equivalence:
            - The blacklisted formula allows for `x` and `y` such that `x` is at most 2 units greater than `y`, providing a relation between `x` and `y`.
            - The new formula constrains `x` and `y` to be within a certain range but has no explicit relationship between `x` and `y`.

            The constraints of the blacklisted formula and the new formula are fundamentally different:
            - The new formula does not impose any restrictions on the relationship between `x` and `y`, unlike the blacklisted formula which directly relates `x` and `y`.
            - Due to this lack of relationship constraint in the new formula, it is possible to have situations where the new formula allows combinations of `x` and `y` that the blacklisted formula does not, and vice versa.

            Thus, the new formula is distinct from the blacklisted one because it is possible to have pairs of `x` and `y` satisfying the new formula that do not satisfy the blacklisted formula. Therefore, the new formula is novel.

            ```
            yes
            ```
      - message: Answer received
        node: 94
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { 0 <= x - y <= 2 }  (* GOAL *)
                    invariant { 0 <= x - y <= 2 }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?
          answer: |-
            The proof obligation failure indicates that Why3 is unable to establish the given invariant `0 <= x - y <= 2` at the start of the loop, based on the assumptions provided before the loop begins. This suggests that the initial conditions, namely the assumptions, somehow do not logically lead to the loop invariants at the beginning of the loop.

            Let's analyze the condition `0 <= x - y <= 2`. The initial values for `x` and `y` must satisfy this invariant from the very beginning. In other words, we need to show that given the assumptions `x >= 0`, `x <= 2`, `y >= 0`, `y <= 2`, the initial value of `x - y` satisfies the given invariant `0 <= x - y <= 2`.

            However, from the assumptions:
            - The largest value `x` can be is `2`.
            - The smallest value `y` can be is `0`.

            Therefore, the largest initial value for `x - y` is `2`, and the smallest initial value for `x - y` is `0`. Thus, the initial value of `x - y` indeed satisfies `0 <= x - y <= 2`.

            Since Why3 still fails the verification initially, we need to restate or strengthen our invariants so that the verification condition can propagate accurately through the system. Specifically, we can express the above reasoning explicitly as an invariant, or improve the structure of the current one.

            Let's add one invariant that can help with the proof:

            ```yaml
            - "x >= y"
            - "x <= y + 2"
            ```
      - message: Answer received
        node: 98
        space: eval
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                I will show you an annotated program in which Why3 did not manage to prove a particular proof obligation. You must determine two things:

                1. Whether the failing proof obligation is about an invariant not holding initially. In this case, there is no hope to fix the proof by adding new invariants and so the invariant in question must be incorrect.
                2. Whether or not the shown program features redundant invariants. For example, having both invariants `x >= 1` and `x >= 2` is unnecessary since the second one is stronger and thus `x >= 1` is redundant. Similarly, having invariants `x > 0`, `y > 0` and `x + y > 0` is redundant since the first two invariants together imply the third one.

                You should terminate your answer with a triple-quoted code block containing a YAML object with fields `prob_incorrect` and `prob_redundant`. For each of those fields, you should provide a confidence score as a number between 0 and 1.
            - role: user
              content: |-
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x >= y }  (* GOAL *)
                    invariant { x <= y + 2 }
                    invariant { 0 <= x - y <= 2 }
                    invariant { 0 <= x - y <= 2 }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                Exactly one proof obligation failed, which is named: `VC for main (loop invariant init)`.
          answer: |-
            To analyze the given program, we need to evaluate both the conditions under which the loop invariants hold initially and whether some invariants are unnecessarily redundant.

            ### Checking for Incorrect Invariant Initialization

            The proof obligation that fails is `VC for main (loop invariant init)`, which means one or more loop invariants do not hold initially (before entering the loop). Here, we have to check these invariants against the assumptions given for `x` and `y`.

            1. **Invariant: `x >= y`**
               - From assumptions: `x >= 0` and `y >= 0`, but there is no direct guarantee that `x >= y` unless `x = y` is explicitly assumed, which is not the case.

            2. **Invariant: `x <= y + 2`**
               - From assumptions: `x <= 2` and `y >= 0`, it can be deduced that `x <= y + 2` since the maximum value of `y + 2` is also 2 when `y = 0`.

            3. **Invariant: `0 <= x - y <= 2`**
               - From assumptions: `x >= 0`, `y <= 2`, it suffices to show that `x - y` ranges between `0` and `2`.
               - This is equivalent to requiring `x >= y` and `x <= y + 2`, which together are already covered by the other two invariants, effectively making this one redundant.

            4. **Duplicate Invariant: `0 <= x - y <= 2`**
               - This is a direct duplicate of the previous one and clearly redundant. 

            ### Identifying Redundant Invariants

            Given the analysis above, redundancy exists:
            - The invariants `x <= y + 2` and `0 <= x - y <= 2` in essence are conveying the same constraint because, given `x >= y`, `x <= y + 2` ensures `0 <= x - y <= 2`. Therefore, one of them is redundant.
            - Specifically, the additional copy of `0 <= x - y <= 2` is a straightforward redundancy, being a direct repeat.

            Thus, the only incorrect invariant seems to be `x >= y`, which doesn't hold given the assumptions on entering the loop.

            Here's the final evaluation:

            ```yaml
            prob_incorrect: 0.9
            prob_redundant: 0.8
            ```
      - message: Answer received
        node: 100
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x = y }  (* GOAL *)
                    invariant { x - y >= -2 }
                    invariant { x - y <= 2 }
                    invariant { x = y }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x = y']
          answer: |-
            To debug the situation, let's analyze the problem. The loop invariant `x = y` did not prove successful, which means that the initialization of this invariant isn't possible with the given assumptions. The premises before the loop indicate that `x` and `y` are in the range from 0 to 2.

            The invariant `x = y` is too strong; it requires `x` to always be equal to `y`, but this may not hold before the loop starts due to the initial arbitrary values (`any int`) that `x` and `y` receive. Since we have `x >= 0`, `x <= 2`, `y >= 0`, and `y <= 2`, one thing we know is that they are both constrained to be within that range, but not necessarily equal.

            Upon examination, `x = y` needs to be relaxed. An alternative would be to assert the constraints that are consistent before the loop starts: the difference between `x` and `y` must be a multiple of 2. Thus, instead of enforcing strict equality, we can make use of the other two invariants `x - y >= -2` and `x - y <= 2`. These indicate that `x` and `y` are close to each other.

            Let's try a different invariant: that the difference between `x` and `y` is consistently a multiple of 2. This naturally follows from the loop, as both `x` and `y` are incremented by the same value, maintaining the difference invariant in this way.

            ```yaml
            ["(x - y) mod 2 = 0"]
            ```
      - message: Answer received
        node: 101
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x >= y }  (* GOAL *)
                    invariant { x <= y + 2 }
                    invariant { 0 <= x - y <= 2 }
                    invariant { 0 <= x - y <= 2 }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x >= y', 'x <= y + 2']
          answer: |-
            The problem seems to occur with the initialization of the loop invariant on the first iteration. The loop invariants given (specifically `x >= y` and `x <= y + 2`) may not be sufficient to cover the state when the loop starts. 

            To solve this issue, we need to ensure that these invariants are satisfied from the start, given the assumptions about `x` and `y`. We should also consider the relationship between `x` and `y` established by any code before the loop.

            Given the initial assumptions `x >= 0`, `x <= 2`, `y >= 0`, and `y <= 2`, we can infer that `0 <= x - y <= 2` is an invariant that holds initially.

            Additionally, the invariant `0 <= x - y <= 2` appears twice in the code, indicating redundancy, and more clarity might help Why3 in proving it. Let's consider an appropriate invariant set that combines all these ideas.

            Here are the invariants which should help complete the proof:

            ```yaml
            [
              "x >= y",
              "x <= y + 2",
              "0 <= x - y",
              "x - y <= 2"
            ]
            ```
      - message: Answer received
        node: 102
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x = y)`

                New formula: `((x - y) mod 2 = 0)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula `((x - y) mod 2 = 0)` is equivalent to the blacklisted formula `(x = y)`, we need to interpret the meaning of each formula. 

            1. The blacklisted formula `(x = y)` simply states that `x` is equal to `y`. 

            2. The new formula `((x - y) mod 2 = 0)` means that the difference between `x` and `y` is an even number (because any integer `n` is even if `n mod 2` equals `0`).

            Let's analyze when these two formulas would produce the same results:

            - **(x = y)**:
              - This holds true when both `x` and `y` take the same integer value.

            - **((x - y) mod 2 = 0)**:
              - This holds true when `x` and `y` are either both even or both odd (i.e., their difference is an even integer), but it does not require `x` and `y` to be equal.

            For example:
            - If `x = 2` and `y = 2`, both formulas would be true.
            - If `x = 3` and `y = 3`, both formulas would be true.
            - If `x = 2` and `y = 4`, the formula `((x - y) mod 2 = 0)` is true, but `(x = y)` is false.
            - If `x = 3` and `y = 1`, the formula `((x - y) mod 2 = 0)` is true, but again `(x = y)` is false.

            Therefore, the new formula `((x - y) mod 2 = 0)` is not equivalent to `(x = y)` since they produce different results for different inputs, especially when one of the variables is even and the other is odd.

            ```no```
          parse_error: No final code block found.
      - message: Answer received
        node: 103
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x >= y) && (x <= y + 2)`

                New formula: `(x >= y) && (x <= y + 2) && (0 <= x - y) && (x - y <= 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula is equivalent to one from the blacklist, we can simplify both formulas to see if they are logically the same.

            Let's first consider the blacklisted formula:
            - `(x >= y) && (x <= y + 2)`

            This simply checks if `x` is between `y` and `y + 2`, inclusive.

            Now, for the new formula:
            - `(x >= y) && (x <= y + 2) && (0 <= x - y) && (x - y <= 2)`

            We can observe the following:
            - The first two parts `(x >= y)` and `(x <= y + 2)` are identical to the blacklisted formula.
            - The additional clauses `(0 <= x - y)` and `(x - y <= 2)` are equivalent to `(x >= y)` and `(x <= y + 2)`, respectively.

            Thus, the new formula `(x >= y) && (x <= y + 2) && (0 <= x - y) && (x - y <= 2)` simplifies logically to:
            - `(x >= y) && (x <= y + 2)`

            It is clear that the new formula does not introduce any additional constraints compared to the blacklisted one, and it describes exactly the same set of circumstances.

            Hence, the new formula is effectively equivalent to the blacklisted formula.

            ```
            no
            ```
      - message: Answer received
        node: 102
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x = y)`

                New formula: `((x - y) mod 2 = 0)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula is equivalent to any formula on the blacklist, let's analyze what each formula represents.

            1. Blacklisted formula: `(x = y)`
               - This formula implies that `x` is exactly equal to `y`.

            2. New formula: `((x - y) mod 2 = 0)`
               - This formula means that the difference between `x` and `y` is an even number. In more detail, `x - y` is divisible by 2, indicating that `x` and `y` are either both even or both odd.

            Now, let's compare these formulas:

            - The formula `(x = y)` is stricter than `((x - y) mod 2 = 0)`. For `(x = y)` to hold, both `x` and `y` must be the same exact number.
            - For `((x - y) mod 2 = 0)`, `x` and `y` do not need to be identical; they only need to have the same parity (both even or both odd).

            Therefore, these two formulas are not equivalent. The new formula permits more combinations of `x` and `y`, such as `(x, y) = (2, 4)` or `(x, y) = (3, 5)`, whereas the blacklisted formula only holds true when `x` is exactly equal to `y`.

            Thus, the new formula is distinct from the blacklisted formula `(x = y)`.

            ```
            yes
            ```
      - message: Answer received
        node: 101
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* GOAL, premise *)
                  let ref y = any int in  (* GOAL, premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x >= y }  (* GOAL *)
                    invariant { x <= y + 2 }
                    invariant { 0 <= x - y <= 2 }
                    invariant { 0 <= x - y <= 2 }
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant init)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x >= y', 'x <= y + 2']
          answer: |-
            To address the failing proof obligation, we should ensure that the initial values satisfy the loop invariant in every possible case, given the assumptions.

            **Analysis:**

            Given the assumptions:
            - `0 <= x <= 2`
            - `0 <= y <= 2`

            We need to establish an invariant for the initialization of the loop that can hold true across the valid range of these variables for every iteration, especially at the beginning.

            The invariant `x >= y` might not hold if `x < y` from the beginning under the assumptions, hence, it failed before. The primary point of failure lies in the initial relationship between `x` and `y`. Therefore, we need to rethink our loop invariants considering the values that `x` and `y` can take.

            **Adding New Invariants:**

            Given the updated guidance, we ought to specify what could be true initially. Since assumptions already tell us bounds, let's consider an alternative invariant that directly makes use of `x` and `y`'s initial constraints.

            Given that:
            - `0 <= x - y`, and the initial assumptions about range,
              
            We can replace or add to the invariant set by narrowing the differences between `x` and `y`:

            To verify the start and maintain consistency, the difference between `x` and `y` in terms of explicit boundaries could be emphasized:

            ```yaml
            - "x <= y + 1"
            - "y <= x + 1"
            ```

            These constraints ensure that, initially and at every loop step, the values of `x` and `y` could only differ slightly according to initial assumptions and should adaptively hold through the transformations applied within the loop. 

            ```yaml
            - "x <= y + 1"
            - "y <= x + 1"
            ```
      - message: Answer received
        node: 109
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x >= y) && (x <= y + 2)`

                New formula: `(x <= y + 1) && (y <= x + 1)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To evaluate whether the new formula is distinct from the blacklisted formula, we should compare their logical implications under integer arithmetic.

            1. **Blacklisted formula:** `(x >= y) && (x <= y + 2)`
               - This means `x` can take any of the integer values `y`, `y+1`, or `y+2`.

            2. **New formula:** `(x <= y + 1) && (y <= x + 1)`
               - Breaking this down:
                 - `(x <= y + 1)` implies `x` is at most `y+1`.
                 - `(y <= x + 1)` implies `y` is at most `x+1`, i.e., `x` is at least `y-1`.

               Combining both parts:
               - `y - 1 <= x <= y + 1`

               This means `x` can be `y-1`, `y`, or `y+1`.

            Let's list the allowed integer values for `x` for both formulas:

            - **Blacklisted formula:** `x` can be `y`, `y+1`, `y+2`.
            - **New formula:** `x` can be `y-1`, `y`, `y+1`.

            Comparing the sets of possible values for `x`:
            - The blacklisted formula allows `{y, y+1, y+2}`.
            - The new formula allows `{y-1, y, y+1}`.

            Since these sets are not the same, the new formula is distinct from the blacklisted one.

            ```
            yes
            ```
      - message: Answer received
        node: 114
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
                - ['x + y <= 4', 'x <= 2']
                - ['x - y <= 2', 'x <= 2']
                - ['0 <= x - y <= 2']
          answer: |-
            To solve the problem, let's examine the relevant parts of the code and existing assumptions. The loop increments both `x` and `y` by 2 continuously. Our challenge is to ensure that after the loop, if `y = 0`, then `x` should not equal 4.

            Given the provided assumptions and the unsuccessful attempts, we can deduce:
            - Initially, `0 <= x <= 2` and `0 <= y <= 2`.
            - The loop increments both `x` and `y` by 2 each time, keeping them even.
            - The condition `y = 0` implies that `y` was even or became even during execution.
              
            Thus, if `y = 0` post-loop, it could only reach zero if it started even. Given the even increment, starting at an even value ensures it will remain even. Similarly, `x` could not have reached an even number larger than 2 if it was not even initially, and its original maximum was 2.

            This observation gives us an invariant that correlates a potential zero value for `y` to a limitation on `x`: when `y = 0`, it must have started from 0 due to loop behaviour constraints, thus not allowing `x` to reach 4.

            Let's try the following invariants:

            ```yaml
            [
              "y >= 0",
              "x >= 0",
              "x <= y + 2"
            ]
            ```
      - message: Answer received
        node: 115
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`
                  - `(x + y <= 4) && (x <= 2)`
                  - `(x - y <= 2) && (x <= 2)`
                  - `(0 <= x - y <= 2)`

                New formula: `(y >= 0) && (x >= 0) && (x <= y + 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula `(y >= 0) && (x >= 0) && (x <= y + 2)` is equivalent to any of the blacklisted ones, I'll analyze and compare them:

            1. **Blacklist Formula 1:** `(x mod 2 = 0) && (y mod 2 = 0)`
               - This expression requires that both `x` and `y` are even numbers. The new formula does not imply any particular parity for `x` or `y`, so these formulas are not equivalent.

            2. **Blacklist Formula 2:** `(x = y)`
               - This formula states that `x` and `y` are identical. The new formula permits `x` and `y` to differ by up to 2, so they are not equivalent.

            3. **Blacklist Formula 3:** `(x + y <= 4) && (x <= 2)`
               - This formula restricts the sum of `x` and `y` and also requires `x` to be less than or equal to 2. The new formula does not correspondingly limit the sum of `x` and `y`, thus they are not equivalent.

            4. **Blacklist Formula 4:** `(x - y <= 2) && (x <= 2)`
               - This expression indicates that `x` can be at most 2 units greater than `y`, with `x` also constrained to be at most 2. The new formula appears similar due to the comparison `(x <= y + 2)`. Still, there is no explicit restriction that `x` must be less than or equal to 2, so these are not fully equivalent.

            5. **Blacklist Formula 5:** `(0 <= x - y <= 2)`
               - This formula effectively states that `x` is between `y` and `y + 2`, inclusive. The new formula also states that `x <= y + 2` while including restrictions of `y >= 0` and `x >= 0`, which do not contradict the range relationship `0 <= x - y <= 2`. Thus, the new formula essentially describes the same relationship among `x` and `y`.

            The analyzed comparison shows that the new formula `(y >= 0) && (x >= 0) && (x <= y + 2)` is essentially expressing the same bound as the blacklisted condition `(0 <= x - y <= 2)`, given the context of integer variables. 

            Therefore, the new formula is not distinct from the blacklisted formulas.

            ```
            no
            ```
      - message: Answer received
        node: 114
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
                - ['x + y <= 4', 'x <= 2']
                - ['x - y <= 2', 'x <= 2']
                - ['0 <= x - y <= 2']
          answer: |-
            To prove the assertion `assert { x <> 4 }` at the end of the loop, we need to ensure that the value of `x` after the loop will never be 4 if `y` is 0.

            Let's break down the situation:
            - Initially, `x` is between 0 and 2, and `y` is between 0 and 2.
            - In each iteration of the loop, both `x` and `y` are incremented by 2.
            - We need to ensure that, after any sequence of increments that would result in `y = 0`, `x` is not 4.

            If `y = 0` at the end, given `y` increases by 2 in every loop iteration, it must have been 0 at the beginning since we do not have subtraction operations. Thus, the number of increments applied to both `x` and `y` must be zero, meaning neither `x` nor `y` would have changed. Therefore, `x` remains within its initial range (0 to 2), and it can never be 4.

            Given this reasoning, a useful invariant could be:
            - The relationship between the number of increments of `x` and `y` and their initial values ensures that `x` doesn't ever reach 4 if `y` ends up at 0.

            So the invariant to add could be:
            - `x <= 2 || y <> 0`.

            This invariant maintains that if `x` reaches values beyond its initial bound (i.e., `x > 2`), then `y` will not be zero, helping to prove the assertion at the end. 

            Here's the formal annotation to help Why3 with this logic:

            ```yaml
            ["x <= 2 || y <> 0"]
            ```
      - message: Answer received
        node: 117
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`
                  - `(x + y <= 4) && (x <= 2)`
                  - `(x - y <= 2) && (x <= 2)`
                  - `(0 <= x - y <= 2)`

                New formula: `(x <= 2 || y <> 0)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            Yes, the new formula `(x <= 2 || y <> 0)` is distinct from all the blacklisted formulas. Let's break down the comparison:

            1. `(x mod 2 = 0) && (y mod 2 = 0)`: Checks if both `x` and `y` are even, unrelated to comparisons using `<=`, `=`, or `<>`.

            2. `(x = y)`: Checks for equality. The new formula allows inequality.

            3. `(x + y <= 4) && (x <= 2)`: Conditions involving specific limits on `x` and `x+y`, without involving `y <> 0`.

            4. `(x - y <= 2) && (x <= 2)`: Involves a condition on the difference between `x` and `y`, not directly related to `<=` or `<>` checks.

            5. `(0 <= x - y <= 2)`: Checks if `x` is slightly larger than or equal to `y` and also within 2 units, unlike the new formula.

            Since the new formula is based on `x <= 2` or `y <> 0` which doesn't fit the pattern or logic of the existing blacklist entries, it is novel.

            ```
            yes
            ```
      - message: Answer received
        node: 121
        space: eval
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                I will show you an annotated program in which Why3 did not manage to prove a particular proof obligation. You must determine two things:

                1. Whether the failing proof obligation is about an invariant not holding initially. In this case, there is no hope to fix the proof by adding new invariants and so the invariant in question must be incorrect.
                2. Whether or not the shown program features redundant invariants. For example, having both invariants `x >= 1` and `x >= 2` is unnecessary since the second one is stronger and thus `x >= 1` is redundant. Similarly, having invariants `x > 0`, `y > 0` and `x + y > 0` is redundant since the first two invariants together imply the third one.

                You should terminate your answer with a triple-quoted code block containing a YAML object with fields `prob_incorrect` and `prob_redundant`. For each of those fields, you should provide a confidence score as a number between 0 and 1.
            - role: user
              content: |-
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                    x <- x + 2;  (* premise *)
                    y <- y + 2  (* premise *)
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                Exactly one proof obligation failed, which is named: `VC for main (loop invariant preservation)`.
          answer: |-
            Given the program, the failing proof obligation concerns the preservation of the loop invariant across iterations of the loop. The invariant is:

            ```mlw
            invariant { x <= 2 || y <> 0 }
            ```

            Let's analyze each aspect:

            1. **Invariant Initially Holding**: For the invariant to hold initially, we need to verify the starting conditions when the loop is entered.
               
               - From the assumptions, we know that `x >= 0`, `x <= 2`, `y >= 0`, and `y <= 2`. Thus, initially: 
                 - `x <= 2` holds because it's explicitly assumed. Hence, `x <= 2 || y <> 0` is `True || y <> 0`, simplifying to `True`, which holds trivially.
               - Consequently, the invariant does hold before entering the loop, and the issue is not with the invariant not holding initially.

            2. **Invariant Preservation**:
               
               - After one iteration of the loop:
                 - `x` becomes `x + 2`
                 - `y` becomes `y + 2`
                 - The invariant to check now becomes `(x + 2 <= 2) || (y + 2 <> 0)`, which simplifies to `x <= 0 || y + 2 <> 0`.
               - However, `x` was initially between 0 and 2 (inclusively), so after the update `x + 2 >= 2`, which means the left condition `x <= 0` will generally not hold after the first iteration. Therefore, y must not be 0 to preserve the invariant, which aligns initially.

               This analysis shows that as long as `y` is initially nonzero or `x <= 0`,`y` does not affect the loop condition unless initially zero, ensuring `(y + 2 <> 0)` is respected, reinforcing the obligation.

            3. **Redundancy**:
               
               - The loop invariant `x <= 2 || y <> 0` is not redundant with any other assumption or invariant since it establishes a condition that must remain true throughout the loop, crucial considering changes because y starts at zero potentially unless x is strictly 0 initially. This invariant plays a role in guaranteeing `x <= 2` or non-zero y across iterations, justifying the symmetry alone.

            In summary, since the invariant holds initially but fails to hold across iterations, particularly resulting in failure when `x` becomes greater than `2` post-initialization pair phase, it likely needs modification to accommodate iterative increases over given assumptions.

            ```yaml
            prob_incorrect: 0.2
            prob_redundant: 0.3
            ```
      - message: Answer received
        node: 124
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                    x <- x + 2;  (* premise *)
                    y <- y + 2  (* premise *)
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant preservation)`. Can you fix this?
          answer: |-
            To fix this issue, we need to identify the missing invariants that will allow the loop invariant to be maintained through each iteration of the loop.

            Examining the code, the loop modifies `x` and `y` by adding 2 to each of them. The initial values of `x` and `y` are constrained by the assumptions: `0 <= x <= 2` and `0 <= y <= 2`.

            The existing invariant is `x <= 2 || y <> 0`. For each iteration, given that `x` and `y` are incremented by 2, we need an invariant that expresses the relationship between `x` and `y` to ensure that when `y = 0`, the condition `x <> 4` is maintained.

            Let's consider the following additional invariants:

            1. `x mod 2 = y mod 2`. This will ensure that the increments maintain parity between `x` and `y`, providing an implication that helps when `y` reaches 0.

            2. `x <= y + 2`. This initially holds true given the assumptions. Since both `x` and `y` are modified by the same value, the inequality is preserved across loop iterations.

            These invariants should provide sufficient information for the theorem prover to establish the correctness of the loop invariant and prove the final assertion.

            ```yaml
            - "x mod 2 = y mod 2"
            - "x <= y + 2"
            ```
      - message: Answer received
        node: 129
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                    x <- x + 2;  (* premise *)
                    y <- y + 2  (* premise *)
                  done;
                  if y = 0 then
                    assert { x <> 4 }
                ```

                The name of the proof obligation that failed is: `VC for main (loop invariant preservation)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = y mod 2', 'x <= y + 2']
          answer: |-
            To resolve the proof obligation `VC for main (loop invariant preservation)`, we need to reason about how the values of `x` and `y` evolve across iterations of the loop, given the operations performed on them and their initial assumptions.

            Given:
            - Initial conditions: `0 <= x <= 2` and `0 <= y <= 2`
            - In each iteration: `x <- x + 2` and `y <- y + 2`
            - We need to ensure the loop invariant `x <= 2 || y <> 0` holds across iterations.

            The major challenge appears to be maintaining this invariant given the changes to `x` and `y`. Initially, both `x` and `y` are between `0` and `2`, and they are incremented by `2` each iteration. This suggests that the relationship between `x` and `y` could be crucial. Let's explore potential invariant forms that encapsulate this relationship:

            1. Since both `x` and `y` start below or equal to `2`, they increase in steps of `2`, and their difference maintains parity (`x - y` is always even, suggestive but not enforceable), both remain synchronously large or small. Therefore, we can propose a bound on the maximum value they reach.
            2. Enforcing direct constraints on their iterative increase may help; we notice they grow uniformly.

            The preservation of `x <= 2 || y <> 0` could be upheld through a combination of checking the synchronization via difference or bounding constraints going beyond the initial constraints.

            Here's a hypothesis:

            ```yaml
            [
              "x <= y + 2",
              "x <= 2 || y <> 0",
              "x <= 4",
              "y <= 4"
            ]
            ```

            This proposal adds bounds while trying to preserve the logical condition formed by `x` and `y` changes. 
      - message: Answer received
        node: 130
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = y mod 2) && (x <= y + 2)`

                New formula: `(x <= y + 2) && (x <= 2 || y <> 0) && (x <= 4) && (y <= 4)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            First, let's analyze the blacklisted formula:

            - `(x mod 2 = y mod 2)` implies that `x` and `y` have the same parity. This condition is independent of specific range constraints on the values of `x` and `y`.
            - `(x <= y + 2)` restricts `x` to being at most 2 units greater than `y`. 

            Now, let's look at the new formula:

            - `(x <= y + 2)` matches directly with the second component of the blacklisted formula.
            - `(x <= 2 || y <> 0)` suggests some additional restrictions. This condition says either `x` must be at most 2, or `y` cannot be 0.
            - `(x <= 4)` and `(y <= 4)` are additional bounding conditions that restrict the maximum possible values for `x` and `y`.

            The blacklisted formula requires `x` and `y` to have the same parity and that `x` must be at most `2` more than `y`. 

            The new formula restricts `x <= y + 2`, similar to the blacklisted condition, and it further restricts the values with bounded conditions (`x <= 4` and `y <= 4`) and a disjunction that involves specific values of `x` and `y` (`x <= 2 || y <> 0`). However, the parity condition from the blacklisted formula doesn't appear to directly correspond in the new formula.

            To conclude, the new formula and the blacklisted formula contain constraints that intersect partially but differ because of the absent parity condition in the new formula and the additional bounding the new formula imposes. Thus, they cannot be considered equivalent.

            ```
            yes
            ```
      - message: Answer received
        node: 135
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
                - ['x + y <= 4', 'x <= 2']
                - ['x - y <= 2', 'x <= 2']
                - ['0 <= x - y <= 2']
                - ['x <= 2 || y <> 0']
          answer: |-
            To ensure that the assertion `x <> 4` is proven, we should consider how the loop affects the relationship between `x` and `y`. The key is to understand how `x` and `y` evolve by increments of 2 inside the loop. Since both start within the range `[0, 2]`, adding 2 repeatedly keeps them even. If `y = 0`, it likely means the loop didn't run at all. Thus, it's critical to capture the relationship established by starting conditions and the parity of `x` and `y` that persists through the loop because they are both increased by 2 simultaneously.

            Let's try adding an invariant that uses this understanding to preserve properties through the loop. 

            Here are some invariants that could help in this situation:

            ```yaml
            - "x mod 2 = y mod 2"
            ``` 

            This invariant asserts that `x` and `y` will always have the same parity, ensuring that post-loop, if `y = 0`, it logically follows that `x`, initialized within the same constraints and modified in tandem, can’t be 4. Combining this understanding with the starting conditions ensures that only certain values for `x` and `y` are possible when `y = 0` after the loop.
      - message: Answer received
        node: 136
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                I am going to give you a list of formulas, along with a new one. Your task is to tell me if the new formula is equivalent to one already in the list. Note that all involved variables are integer variables. Thus, formula `(x > 0)` is considered equivalent to formula `(x >= 1)`. However, it is not equivalent to `(x >= 1 && x <= 3)`.

                Please terminate your answer with a triple-quoted code block containing
                 `yes` if the new formula is novel (not in the list) and `no` otherwise.
            - role: user
              content: |-
                Blacklist:
                  - `(x mod 2 = 0) && (y mod 2 = 0)`
                  - `(x = y)`
                  - `(x + y <= 4) && (x <= 2)`
                  - `(x - y <= 2) && (x <= 2)`
                  - `(0 <= x - y <= 2)`
                  - `(x <= 2 || y <> 0)`

                New formula: `(x mod 2 = y mod 2)`

                Is the new formula distinct from all blacklisted formulas?
          answer: |-
            To determine if the new formula `(x mod 2 = y mod 2)` is equivalent to any formula in the blacklist, we must analyze what each formula represents:

            1. **`(x mod 2 = 0) && (y mod 2 = 0)`** represents both `x` and `y` being even numbers. The new formula checks if `x` and `y` have the same parity (both even or both odd), so it is not equivalent to only both being even.

            2. **`(x = y)`** checks if `x` and `y` are exactly equal. The new formula does not require `x` and `y` to be equal, only that they have the same parity.

            3. **`(x + y <= 4) && (x <= 2)`** is a condition on the sum and one of the variables, unrelated to their parity.

            4. **`(x - y <= 2) && (x <= 2)`** is a condition on the difference between `x` and `y`, again unrelated to parity directly.

            5. **`(0 <= x - y <= 2)`** is equivalent to the condition `(x - y) >= 0 && (x - y) <= 2`, meaning `y` can be `x`, `x-1`, or `x-2`. This does not directly check the parity, only their difference.

            6. **`(x <= 2 || y <> 0)`** checks a range and a non-equality, unrelated to parity equivalence.

            The new formula checks if both numbers `x` and `y` are either both even or both odd, which is distinctive from all conditions in the blacklist.

            Thus, none of the blacklisted formulas is equivalent to the new formula `(x mod 2 = y mod 2)`.

            ```
            yes
            ```
      - message: Answer received
        node: 141
        space: cands
        metadata:
          mode: null
          prompt:
            - role: system
              content: |-
                Your goal is to prove the correctness of WhyML programs using the Why3 theorem prover. To do so, you must annotate programs with loop invariants in such a way that all assertions in the program can be proved automatically via the weakest-precondition calculus.

                We only allow invariants that feature logical combinations of **linear** arithmetic expressions. In particular, we only accept multiplication by constant numerical literals. Thus, we accept invariants such as `x + y > 0` or `a > 0 || 2*x + y < n` but not `x * y > 0` or `x >= y * (y + 1) / 2`.

                I will show you an annotated program in which Why3 did not manage to prove a particular assertion or invariant. Your task is to suggest one or several missing invariants that may help finish the proof.

                In order to help you diagnose the problem, I added comments to the WhyML program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

                In addition, I will summarize a list of changes that were tried already and did not prove successful. You must try and suggest something different.

                You should **carefully** check the proposed examples and organize your answer in a similar way. First, try to understand the problem and identify missing invariants that may help complete the proof. Then, terminate your answer with a triple-quoted YAML code block that denotes a list of strings, each of which corresponding to an invariant.
            - role: user
              content: |
                Here is the program that Why3 was tasked to verify.

                ```mlw
                use int.Int

                let main () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = any int in  (* premise *)
                  assume { x >= 0 };  (* premise *)
                  assume { x <= 2 };  (* premise *)
                  assume { y <= 2 };  (* premise *)
                  assume { y >= 0 };  (* premise *)
                  while any bool do
                    x <- x + 2;
                    y <- y + 2
                  done;
                  if y = 0 then  (* premise *)
                    assert { x <> 4 }  (* GOAL *)
                ```

                The name of the proof obligation that failed is: `VC for main (assertion)`. Can you fix this?

                Here is a list of proposed changes that were tried previously and did not work. You should not try those again:

                - ['x mod 2 = 0', 'y mod 2 = 0']
                - ['x = y']
                - ['x + y <= 4', 'x <= 2']
                - ['x - y <= 2', 'x <= 2']
                - ['0 <= x - y <= 2']
                - ['x <= 2 || y <> 0']
                - ['x mod 2 = y mod 2']
          answer: |-
            To resolve this proof obligation, we need to ensure that the invariant leads to the conclusion that when `y = 0`, `x` cannot be equal to 4. 

            Given that both `x` and `y` start within the range [0, 2] and are incremented by 2 in each iteration of the loop, they will remain in sync with respect to their initial difference, which is zero or two, because they start within the same bounds.

            Let's analyze:
            - Initially, the difference between `x` and `y` is zero, i.e., `x - y = 0`.
            - If `x` is incremented by 2, so is `y`, maintaining `x - y = 0`.
            - Therefore, maintaining this invariant `x - y = 0` ensures `x` and `y` remain equal.

            Thus, if `y = 0`, it implies `x = 0` based on the invariant `x - y = 0`, leading to a contradiction if `x = 4`. Hence, an appropriate invariant is `x - y = 0`.

            Here's the suggested invariant:

            ```yaml
            ["x - y = 0"]
            ```
    browsable_trace:
      nodes:
        "1":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 1
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (assertion)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (assertion)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (assertion)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@1}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [1]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (assertion)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (assertion)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (assertion)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 2
          origin: root
        "2":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: iterate
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: nested
                strategy: iterate
                args:
                  next:
                    short: <function prove_program.<locals>.<lambda> at 0x1169de020>
                    long: <function prove_program.<locals>.<lambda> at 0x1169de020>
                    json_provided: false
                    json: null
                node_id: 3
          actions:
            - ref:
                with_ids: cands{%6}
                with_hints: null
              hints: null
              related_success_nodes: [6]
              related_answers: []
              value:
                short: "['x mod 2 = 0', 'y mod 2 = 0']"
                long: "['x mod 2 = 0', 'y mod 2 = 0']"
                json_provided: true
                json: [x mod 2 = 0, y mod 2 = 0]
              destination: 7
            - ref:
                with_ids: cands{%12}
                with_hints: null
              hints: null
              related_success_nodes: [12]
              related_answers: []
              value:
                short: "['x = y']"
                long: "['x = y']"
                json_provided: true
                json: [x = y]
              destination: 13
            - ref:
                with_ids: cands{%40}
                with_hints: null
              hints: null
              related_success_nodes: [40]
              related_answers: []
              value:
                short: "['x + y <= 4', 'x <= 2']"
                long: "['x + y <= 4', 'x <= 2']"
                json_provided: true
                json: [x + y <= 4, x <= 2]
              destination: 41
            - ref:
                with_ids: cands{%46}
                with_hints: null
              hints: null
              related_success_nodes: [46]
              related_answers: []
              value:
                short: "['x - y <= 2', 'x <= 2']"
                long: "['x - y <= 2', 'x <= 2']"
                json_provided: true
                json: [x - y <= 2, x <= 2]
              destination: 47
            - ref:
                with_ids: cands{%71}
                with_hints: null
              hints: null
              related_success_nodes: [71]
              related_answers: []
              value:
                short: "['0 <= x - y <= 2']"
                long: "['0 <= x - y <= 2']"
                json_provided: true
                json: [0 <= x - y <= 2]
              destination: 72
            - ref:
                with_ids: cands{%119}
                with_hints: null
              hints: null
              related_success_nodes: [119]
              related_answers: []
              value:
                short: "['x <= 2 || y <> 0']"
                long: "['x <= 2 || y <> 0']"
                json_provided: true
                json: [x <= 2 || y <> 0]
              destination: 120
            - ref:
                with_ids: cands{%138}
                with_hints: null
              hints: null
              related_success_nodes: [138]
              related_answers: []
              value:
                short: "['x mod 2 = y mod 2']"
                long: "['x mod 2 = y mod 2']"
                json_provided: true
                json: [x mod 2 = y mod 2]
              destination: 139
          origin: [child, 1, 0]
        "3":
          kind: Iteration
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: next(nil)
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (assertion)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then  (* premise *)\n    assert { x <> 4 }  (* GOAL *)')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (assertion)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then  (* premise *)\n'
                                                         '    assert { x <> 4 }  (* GOAL *)')
                    json_provided: true
                    json:
                      obligation_name: VC for main (assertion)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                node_id: 4
            - - with_ids: next(next(nil){%5}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (assertion)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then  (* premise *)\n    assert { x <> 4 }  (* GOAL *)')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (assertion)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then  (* premise *)\n'
                                                         '    assert { x <> 4 }  (* GOAL *)')
                    json_provided: true
                    json:
                      obligation_name: VC for main (assertion)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    short: "[['x mod 2 = 0', 'y mod 2 = 0']]"
                    long: "[['x mod 2 = 0', 'y mod 2 = 0']]"
                    json_provided: true
                    json:
                      - [x mod 2 = 0, y mod 2 = 0]
                node_id: 9
            - - with_ids: next(next(next(nil){%5}[1]){%11}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (assertion)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then  (* premise *)\n    assert { x <> 4 }  (* GOAL *)')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (assertion)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then  (* premise *)\n'
                                                         '    assert { x <> 4 }  (* GOAL *)')
                    json_provided: true
                    json:
                      obligation_name: VC for main (assertion)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    short: "[['x mod 2 = 0', 'y mod 2 = 0'], ['x = y']]"
                    long: "[['x mod 2 = 0', 'y mod 2 = 0'], ['x = y']]"
                    json_provided: true
                    json:
                      - [x mod 2 = 0, y mod 2 = 0]
                      - [x = y]
                node_id: 30
            - - with_ids: next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (assertion)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then  (* premise *)\n    assert { x <> 4 }  (* GOAL *)')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (assertion)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then  (* premise *)\n'
                                                         '    assert { x <> 4 }  (* GOAL *)')
                    json_provided: true
                    json:
                      obligation_name: VC for main (assertion)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    short: "[['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2']]"
                    long: "[['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2']]"
                    json_provided: true
                    json:
                      - [x mod 2 = 0, y mod 2 = 0]
                      - [x = y]
                      - [x + y <= 4, x <= 2]
                node_id: 43
            - - with_ids: next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (assertion)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then  (* premise *)\n    assert { x <> 4 }  (* GOAL *)')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (assertion)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then  (* premise *)\n'
                                                         '    assert { x <> 4 }  (* GOAL *)')
                    json_provided: true
                    json:
                      obligation_name: VC for main (assertion)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    short: "[['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2']]"
                    long: |-
                      [['x mod 2 = 0', 'y mod 2 = 0'],
                       ['x = y'],
                       ['x + y <= 4', 'x <= 2'],
                       ['x - y <= 2', 'x <= 2']]
                    json_provided: true
                    json:
                      - [x mod 2 = 0, y mod 2 = 0]
                      - [x = y]
                      - [x + y <= 4, x <= 2]
                      - [x - y <= 2, x <= 2]
                node_id: 68
            - - with_ids: next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (assertion)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then  (* premise *)\n    assert { x <> 4 }  (* GOAL *)')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (assertion)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then  (* premise *)\n'
                                                         '    assert { x <> 4 }  (* GOAL *)')
                    json_provided: true
                    json:
                      obligation_name: VC for main (assertion)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    short: "[['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2'], ['0 <= x - y <= 2']]"
                    long: |-
                      [['x mod 2 = 0', 'y mod 2 = 0'],
                       ['x = y'],
                       ['x + y <= 4', 'x <= 2'],
                       ['x - y <= 2', 'x <= 2'],
                       ['0 <= x - y <= 2']]
                    json_provided: true
                    json:
                      - [x mod 2 = 0, y mod 2 = 0]
                      - [x = y]
                      - [x + y <= 4, x <= 2]
                      - [x - y <= 2, x <= 2]
                      - [0 <= x - y <= 2]
                node_id: 114
            - - with_ids: next(next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1]){%118}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (assertion)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then  (* premise *)\n    assert { x <> 4 }  (* GOAL *)')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (assertion)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then  (* premise *)\n'
                                                         '    assert { x <> 4 }  (* GOAL *)')
                    json_provided: true
                    json:
                      obligation_name: VC for main (assertion)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    short: "[['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2'], ['0 <= x - y <= 2'], ['x <= 2 || y <> 0']]"
                    long: |-
                      [['x mod 2 = 0', 'y mod 2 = 0'],
                       ['x = y'],
                       ['x + y <= 4', 'x <= 2'],
                       ['x - y <= 2', 'x <= 2'],
                       ['0 <= x - y <= 2'],
                       ['x <= 2 || y <> 0']]
                    json_provided: true
                    json:
                      - [x mod 2 = 0, y mod 2 = 0]
                      - [x = y]
                      - [x + y <= 4, x <= 2]
                      - [x - y <= 2, x <= 2]
                      - [0 <= x - y <= 2]
                      - [x <= 2 || y <> 0]
                node_id: 135
            - - with_ids: next(next(next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1]){%118}[1]){%137}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (assertion)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then  (* premise *)\n    assert { x <> 4 }  (* GOAL *)')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (assertion)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then  (* premise *)\n'
                                                         '    assert { x <> 4 }  (* GOAL *)')
                    json_provided: true
                    json:
                      obligation_name: VC for main (assertion)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    short: "[['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2'], ['0 <= x - y <= 2'], ['x <= 2 || y <> 0'], ['x mod 2 = y mod 2']]"
                    long: |-
                      [['x mod 2 = 0', 'y mod 2 = 0'],
                       ['x = y'],
                       ['x + y <= 4', 'x <= 2'],
                       ['x - y <= 2', 'x <= 2'],
                       ['0 <= x - y <= 2'],
                       ['x <= 2 || y <> 0'],
                       ['x mod 2 = y mod 2']]
                    json_provided: true
                    json:
                      - [x mod 2 = 0, y mod 2 = 0]
                      - [x = y]
                      - [x + y <= 4, x <= 2]
                      - [x - y <= 2, x <= 2]
                      - [0 <= x - y <= 2]
                      - [x <= 2 || y <> 0]
                      - [x mod 2 = y mod 2]
                node_id: 141
          actions:
            - ref:
                with_ids: next(nil){%5}
                with_hints: null
              hints: null
              related_success_nodes: [5]
              related_answers: []
              value:
                short: (['x mod 2 = 0', 'y mod 2 = 0'], [['x mod 2 = 0', 'y mod 2 = 0']])
                long: (['x mod 2 = 0', 'y mod 2 = 0'], [['x mod 2 = 0', 'y mod 2 = 0']])
                json_provided: true
                json:
                  - [x mod 2 = 0, y mod 2 = 0]
                  - - [x mod 2 = 0, y mod 2 = 0]
              destination: 6
            - ref:
                with_ids: next(next(nil){%5}[1]){%11}
                with_hints: null
              hints: null
              related_success_nodes: [11, 5]
              related_answers: []
              value:
                short: (['x = y'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y']])
                long: (['x = y'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y']])
                json_provided: true
                json:
                  - [x = y]
                  - - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
              destination: 12
            - ref:
                with_ids: next(next(next(nil){%5}[1]){%11}[1]){%39}
                with_hints: null
              hints: null
              related_success_nodes: [39, 11, 5]
              related_answers: []
              value:
                short: (['x + y <= 4', 'x <= 2'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2']])
                long: |-
                  (['x + y <= 4', 'x <= 2'],
                   [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2']])
                json_provided: true
                json:
                  - [x + y <= 4, x <= 2]
                  - - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
              destination: 40
            - ref:
                with_ids: next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}
                with_hints: null
              hints: null
              related_success_nodes: [45, 39, 11, 5]
              related_answers: []
              value:
                short: (['x - y <= 2', 'x <= 2'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2']])
                long: |-
                  (['x - y <= 2', 'x <= 2'],
                   [['x mod 2 = 0', 'y mod 2 = 0'],
                    ['x = y'],
                    ['x + y <= 4', 'x <= 2'],
                    ['x - y <= 2', 'x <= 2']])
                json_provided: true
                json:
                  - [x - y <= 2, x <= 2]
                  - - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
              destination: 46
            - ref:
                with_ids: next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}
                with_hints: null
              hints: null
              related_success_nodes: [70, 45, 39, 11, 5]
              related_answers: []
              value:
                short: (['0 <= x - y <= 2'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2'], ['0 <= x - y <= 2']])
                long: |-
                  (['0 <= x - y <= 2'],
                   [['x mod 2 = 0', 'y mod 2 = 0'],
                    ['x = y'],
                    ['x + y <= 4', 'x <= 2'],
                    ['x - y <= 2', 'x <= 2'],
                    ['0 <= x - y <= 2']])
                json_provided: true
                json:
                  - [0 <= x - y <= 2]
                  - - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
              destination: 71
            - ref:
                with_ids: next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1]){%118}
                with_hints: null
              hints: null
              related_success_nodes: [118, 70, 45, 39, 11, 5]
              related_answers: []
              value:
                short: (['x <= 2 || y <> 0'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2'], ['0 <= x - y <= 2'], ['x <= 2 || y <> 0']])
                long: |-
                  (['x <= 2 || y <> 0'],
                   [['x mod 2 = 0', 'y mod 2 = 0'],
                    ['x = y'],
                    ['x + y <= 4', 'x <= 2'],
                    ['x - y <= 2', 'x <= 2'],
                    ['0 <= x - y <= 2'],
                    ['x <= 2 || y <> 0']])
                json_provided: true
                json:
                  - [x <= 2 || y <> 0]
                  - - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
                    - [x <= 2 || y <> 0]
              destination: 119
            - ref:
                with_ids: next(next(next(next(next(next(next(nil){%5}[1]){%11}[1]){%39}[1]){%45}[1]){%70}[1]){%118}[1]){%137}
                with_hints: null
              hints: null
              related_success_nodes: [137, 118, 70, 45, 39, 11, 5]
              related_answers: []
              value:
                short: (['x mod 2 = y mod 2'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2'], ['0 <= x - y <= 2'], ['x <= 2 || y <> 0'], ['x mod 2 = y mod 2']])
                long: |-
                  (['x mod 2 = y mod 2'],
                   [['x mod 2 = 0', 'y mod 2 = 0'],
                    ['x = y'],
                    ['x + y <= 4', 'x <= 2'],
                    ['x - y <= 2', 'x <= 2'],
                    ['0 <= x - y <= 2'],
                    ['x <= 2 || y <> 0'],
                    ['x mod 2 = y mod 2']])
                json_provided: true
                json:
                  - [x mod 2 = y mod 2]
                  - - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
                    - [x <= 2 || y <> 0]
                    - [x mod 2 = y mod 2]
              destination: 138
          origin: [nested, 2, 0]
        "4":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (assertion)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
                  blacklist: []
                answers:
                  - id: 2
                    hint: null
                    value:
                      short: "['x mod 2 = 0', 'y mod 2 = 0']"
                      long: "['x mod 2 = 0', 'y mod 2 = 0']"
                      json_provided: true
                      json: [x mod 2 = 0, y mod 2 = 0]
          actions:
            - ref:
                with_ids: cands{@2}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [2]
              value:
                short: "['x mod 2 = 0', 'y mod 2 = 0']"
                long: "['x mod 2 = 0', 'y mod 2 = 0']"
                json_provided: true
                json: [x mod 2 = 0, y mod 2 = 0]
              destination: 5
          origin: [nested, 3, 0]
        "5":
          kind: Success
          success_value:
            short: (['x mod 2 = 0', 'y mod 2 = 0'], [['x mod 2 = 0', 'y mod 2 = 0']])
            long: (['x mod 2 = 0', 'y mod 2 = 0'], [['x mod 2 = 0', 'y mod 2 = 0']])
            json_provided: true
            json:
              - [x mod 2 = 0, y mod 2 = 0]
              - - [x mod 2 = 0, y mod 2 = 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 4, 0]
        "6":
          kind: Success
          success_value:
            short: "['x mod 2 = 0', 'y mod 2 = 0']"
            long: "['x mod 2 = 0', 'y mod 2 = 0']"
            json_provided: true
            json: [x mod 2 = 0, y mod 2 = 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 3, 0]
        "7":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x mod 2 = 0 }
                          invariant { y mod 2 = 0 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 3
                    hint: null
                    value:
                      short: "{'error': \"File line 11, characters 18-21: unbound function or predicate symbol 'mod'\", 'obligations': []}"
                      long: |-
                        {'error': 'File line 11, characters 18-21: unbound function or predicate '
                                  "symbol 'mod'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: "File line 11, characters 18-21: unbound function or predicate symbol 'mod'"
                        obligations: []
          actions:
            - ref:
                with_ids: query{@3}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [3]
              value:
                short: "{'error': \"File line 11, characters 18-21: unbound function or predicate symbol 'mod'\", 'obligations': []}"
                long: |-
                  {'error': 'File line 11, characters 18-21: unbound function or predicate '
                            "symbol 'mod'",
                   'obligations': []}
                json_provided: true
                json:
                  error: "File line 11, characters 18-21: unbound function or predicate symbol 'mod'"
                  obligations: []
              destination: 8
          origin: [child, 2, 0]
        "8":
          kind: Failure
          success_value: null
          summary_message: invalid program
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 7, 0]
        "9":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (assertion)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                answers:
                  - id: 4
                    hint: null
                    value:
                      short: "['x = y']"
                      long: "['x = y']"
                      json_provided: true
                      json: [x = y]
          actions:
            - ref:
                with_ids: cands{@4}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [4]
              value:
                short: "['x = y']"
                long: "['x = y']"
                json_provided: true
                json: [x = y]
              destination: 10
          origin: [nested, 3, 1]
        "10":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x = y]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                answers:
                  - id: 5
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@5}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [5]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 11
          origin: [child, 9, 0]
        "11":
          kind: Success
          success_value:
            short: (['x = y'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y']])
            long: (['x = y'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y']])
            json_provided: true
            json:
              - [x = y]
              - - [x mod 2 = 0, y mod 2 = 0]
                - [x = y]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 10, 0]
        "12":
          kind: Success
          success_value:
            short: "['x = y']"
            long: "['x = y']"
            json_provided: true
            json: [x = y]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 3, 1]
        "13":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 6
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }  (* GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@6}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [6]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }  (* GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 14
          origin: [child, 2, 1]
        "14":
          kind: Value
          success_value: null
          summary_message: null
          leaf_node: false
          label: EvaluateProofState
          properties:
            - - with_ids: eval
                with_hints: null
              - kind: query
                name: EvaluateProofState
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 7
                    hint: null
                    value:
                      short: ProofStateMetrics(prob_incorrect=1.0, prob_redundant=0.0)
                      long: ProofStateMetrics(prob_incorrect=1.0, prob_redundant=0.0)
                      json_provided: true
                      json:
                        prob_incorrect: 1
                        prob_redundant: 0
          actions:
            - ref:
                with_ids: nil
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: []
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 15
          origin: [child, 13, 0]
        "15":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: iterate
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: nested
                strategy: iterate
                args:
                  next:
                    short: <function prove_program.<locals>.<lambda> at 0x110e1f2e0>
                    long: <function prove_program.<locals>.<lambda> at 0x110e1f2e0>
                    json_provided: false
                    json: null
                node_id: 16
          actions:
            - ref:
                with_ids: cands{%19}
                with_hints: null
              hints: null
              related_success_nodes: [19]
              related_answers: []
              value:
                short: "['x - y >= -2', 'x - y <= 2']"
                long: "['x - y >= -2', 'x - y <= 2']"
                json_provided: true
                json: [x - y >= -2, x - y <= 2]
              destination: 20
            - ref:
                with_ids: cands{%27}
                with_hints: null
              hints: null
              related_success_nodes: [27]
              related_answers: []
              value:
                short: "['x = y = 0']"
                long: "['x = y = 0']"
                json_provided: true
                json: [x = y = 0]
              destination: 28
          origin: [child, 14, 0]
        "16":
          kind: Iteration
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: next(nil)
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant init)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* GOAL, premise *)\n  let ref y = any int in  (* GOAL, premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x = y }  (* GOAL *)\n    invariant { x - y >= -2 }\n    invariant { x - y <= 2 }\n    invariant { x = y }\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant init)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  let ref y = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x = y }  (* GOAL *)\n'
                                                         '    invariant { x - y >= -2 }\n'
                                                         '    invariant { x - y <= 2 }\n'
                                                         '    invariant { x = y }\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant init)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* GOAL *)
                            invariant { x - y >= -2 }
                            invariant { x - y <= 2 }
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                node_id: 17
            - - with_ids: next(next(nil){%18}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant init)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* GOAL, premise *)\n  let ref y = any int in  (* GOAL, premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x = y }  (* GOAL *)\n    invariant { x - y >= -2 }\n    invariant { x - y <= 2 }\n    invariant { x = y }\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant init)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  let ref y = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x = y }  (* GOAL *)\n'
                                                         '    invariant { x - y >= -2 }\n'
                                                         '    invariant { x - y <= 2 }\n'
                                                         '    invariant { x = y }\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant init)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* GOAL *)
                            invariant { x - y >= -2 }
                            invariant { x - y <= 2 }
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: "[['x - y >= -2', 'x - y <= 2']]"
                    long: "[['x - y >= -2', 'x - y <= 2']]"
                    json_provided: true
                    json:
                      - [x - y >= -2, x - y <= 2]
                node_id: 24
          actions:
            - ref:
                with_ids: next(nil){%18}
                with_hints: null
              hints: null
              related_success_nodes: [18]
              related_answers: []
              value:
                short: (['x - y >= -2', 'x - y <= 2'], [['x - y >= -2', 'x - y <= 2']])
                long: (['x - y >= -2', 'x - y <= 2'], [['x - y >= -2', 'x - y <= 2']])
                json_provided: true
                json:
                  - [x - y >= -2, x - y <= 2]
                  - - [x - y >= -2, x - y <= 2]
              destination: 19
            - ref:
                with_ids: next(next(nil){%18}[1]){%26}
                with_hints: null
              hints: null
              related_success_nodes: [26, 18]
              related_answers: []
              value:
                short: (['x = y = 0'], [['x - y >= -2', 'x - y <= 2'], ['x = y = 0']])
                long: (['x = y = 0'], [['x - y >= -2', 'x - y <= 2'], ['x = y = 0']])
                json_provided: true
                json:
                  - [x = y = 0]
                  - - [x - y >= -2, x - y <= 2]
                    - [x = y = 0]
              destination: 27
          origin: [nested, 15, 0]
        "17":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist: []
                answers:
                  - id: 8
                    hint: null
                    value:
                      short: "['x - y >= -2', 'x - y <= 2']"
                      long: "['x - y >= -2', 'x - y <= 2']"
                      json_provided: true
                      json: [x - y >= -2, x - y <= 2]
          actions:
            - ref:
                with_ids: cands{@8}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [8]
              value:
                short: "['x - y >= -2', 'x - y <= 2']"
                long: "['x - y >= -2', 'x - y <= 2']"
                json_provided: true
                json: [x - y >= -2, x - y <= 2]
              destination: 18
          origin: [nested, 16, 0]
        "18":
          kind: Success
          success_value:
            short: (['x - y >= -2', 'x - y <= 2'], [['x - y >= -2', 'x - y <= 2']])
            long: (['x - y >= -2', 'x - y <= 2'], [['x - y >= -2', 'x - y <= 2']])
            json_provided: true
            json:
              - [x - y >= -2, x - y <= 2]
              - - [x - y >= -2, x - y <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 17, 0]
        "19":
          kind: Success
          success_value:
            short: "['x - y >= -2', 'x - y <= 2']"
            long: "['x - y >= -2', 'x - y <= 2']"
            json_provided: true
            json: [x - y >= -2, x - y <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 16, 0]
        "20":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x - y >= -2 }
                          invariant { x - y <= 2 }
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 9
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* GOAL *)\\n    invariant { x - y <= 2 }\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* GOAL, premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y >= -2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x - y <= 2 }\n'
                                                             '    invariant { x = y }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x = y }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y >= -2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y >= -2 }  (* GOAL *)
                                  invariant { x - y <= 2 }
                                  invariant { x = y }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* GOAL *)
                                  invariant { x = y }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x = y }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y >= -2 }  (* GOAL, premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* GOAL, premise *)
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x = y }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@9}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [9]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* GOAL *)\\n    invariant { x - y <= 2 }\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* GOAL, premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y >= -2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x - y <= 2 }\n'
                                                       '    invariant { x = y }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x = y }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y >= -2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y >= -2 }  (* GOAL *)
                            invariant { x - y <= 2 }
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* GOAL *)
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x = y }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y >= -2 }  (* GOAL, premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x = y }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* GOAL, premise *)
                            invariant { x = y }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x = y }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x = y }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 21
          origin: [child, 15, 0]
        "21":
          kind: Value
          success_value: null
          summary_message: null
          leaf_node: false
          label: EvaluateProofState
          properties:
            - - with_ids: eval
                with_hints: null
              - kind: query
                name: EvaluateProofState
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 10
                    hint: null
                    value:
                      short: ProofStateMetrics(prob_incorrect=0.9, prob_redundant=0.8)
                      long: ProofStateMetrics(prob_incorrect=0.9, prob_redundant=0.8)
                      json_provided: true
                      json:
                        prob_incorrect: 0.9
                        prob_redundant: 0.8
          actions:
            - ref:
                with_ids: nil
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: []
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 22
          origin: [child, 20, 0]
        "22":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: iterate
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: nested
                strategy: iterate
                args:
                  next:
                    short: <function prove_program.<locals>.<lambda> at 0x1169e9800>
                    long: <function prove_program.<locals>.<lambda> at 0x1169e9800>
                    json_provided: false
                    json: null
                node_id: 23
          actions:
            - ref:
                with_ids: cands{%64}
                with_hints: null
              hints: null
              related_success_nodes: [64]
              related_answers: []
              value:
                short: "['x = y']"
                long: "['x = y']"
                json_provided: true
                json: [x = y]
              destination: 65
            - ref:
                with_ids: cands{%106}
                with_hints: null
              hints: null
              related_success_nodes: [106]
              related_answers: []
              value:
                short: "['(x - y) mod 2 = 0']"
                long: "['(x - y) mod 2 = 0']"
                json_provided: true
                json: [(x - y) mod 2 = 0]
              destination: 107
          origin: [child, 21, 0]
        "23":
          kind: Iteration
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: next(nil)
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant init)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* GOAL, premise *)\n  let ref y = any int in  (* GOAL, premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x = y }  (* GOAL *)\n    invariant { x - y >= -2 }\n    invariant { x - y <= 2 }\n    invariant { x = y }\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant init)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  let ref y = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x = y }  (* GOAL *)\n'
                                                         '    invariant { x - y >= -2 }\n'
                                                         '    invariant { x - y <= 2 }\n'
                                                         '    invariant { x = y }\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant init)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* GOAL *)
                            invariant { x - y >= -2 }
                            invariant { x - y <= 2 }
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                node_id: 62
            - - with_ids: next(next(nil){%63}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant init)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* GOAL, premise *)\n  let ref y = any int in  (* GOAL, premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x = y }  (* GOAL *)\n    invariant { x - y >= -2 }\n    invariant { x - y <= 2 }\n    invariant { x = y }\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant init)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  let ref y = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x = y }  (* GOAL *)\n'
                                                         '    invariant { x - y >= -2 }\n'
                                                         '    invariant { x - y <= 2 }\n'
                                                         '    invariant { x = y }\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant init)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* GOAL *)
                            invariant { x - y >= -2 }
                            invariant { x - y <= 2 }
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: "[['x = y']]"
                    long: "[['x = y']]"
                    json_provided: true
                    json:
                      - [x = y]
                node_id: 100
          actions:
            - ref:
                with_ids: next(nil){%63}
                with_hints: null
              hints: null
              related_success_nodes: [63]
              related_answers: []
              value:
                short: (['x = y'], [['x = y']])
                long: (['x = y'], [['x = y']])
                json_provided: true
                json:
                  - [x = y]
                  - - [x = y]
              destination: 64
            - ref:
                with_ids: next(next(nil){%63}[1]){%105}
                with_hints: null
              hints: null
              related_success_nodes: [105, 63]
              related_answers: []
              value:
                short: (['(x - y) mod 2 = 0'], [['x = y'], ['(x - y) mod 2 = 0']])
                long: (['(x - y) mod 2 = 0'], [['x = y'], ['(x - y) mod 2 = 0']])
                json_provided: true
                json:
                  - [(x - y) mod 2 = 0]
                  - - [x = y]
                    - [(x - y) mod 2 = 0]
              destination: 106
          origin: [nested, 22, 0]
        "24":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist:
                    - [x - y >= -2, x - y <= 2]
                answers:
                  - id: 11
                    hint: null
                    value:
                      short: "['x = y = 0']"
                      long: "['x = y = 0']"
                      json_provided: true
                      json: [x = y = 0]
          actions:
            - ref:
                with_ids: cands{@11}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [11]
              value:
                short: "['x = y = 0']"
                long: "['x = y = 0']"
                json_provided: true
                json: [x = y = 0]
              destination: 25
          origin: [nested, 16, 1]
        "25":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x = y = 0]
                  blacklist:
                    - [x - y >= -2, x - y <= 2]
                answers:
                  - id: 12
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@12}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [12]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 26
          origin: [child, 24, 0]
        "26":
          kind: Success
          success_value:
            short: (['x = y = 0'], [['x - y >= -2', 'x - y <= 2'], ['x = y = 0']])
            long: (['x = y = 0'], [['x - y >= -2', 'x - y <= 2'], ['x = y = 0']])
            json_provided: true
            json:
              - [x = y = 0]
              - - [x - y >= -2, x - y <= 2]
                - [x = y = 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 25, 0]
        "27":
          kind: Success
          success_value:
            short: "['x = y = 0']"
            long: "['x = y = 0']"
            json_provided: true
            json: [x = y = 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 16, 1]
        "28":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x = y = 0 }
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 13
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* GOAL *)\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* premise *)\\n    invariant { x = y }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* GOAL, premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* premise *)\\n    invariant { x = y }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y = 0 }  (* GOAL *)\n'
                                                             '    invariant { x = y }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y = 0 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y = 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y = 0 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y = 0 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y = 0 }  (* GOAL *)
                                  invariant { x = y }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y = 0 }  (* premise *)
                                  invariant { x = y }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y = 0 }  (* GOAL, premise *)
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y = 0 }  (* premise *)
                                  invariant { x = y }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y = 0 }  (* premise *)
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@13}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [13]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* GOAL *)\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* premise *)\\n    invariant { x = y }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* GOAL, premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* premise *)\\n    invariant { x = y }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y = 0 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y = 0 }  (* GOAL *)\n'
                                                       '    invariant { x = y }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y = 0 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y = 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y = 0 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y = 0 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y = 0 }  (* GOAL *)
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y = 0 }  (* premise *)
                            invariant { x = y }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y = 0 }  (* GOAL, premise *)
                            invariant { x = y }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y = 0 }  (* premise *)
                            invariant { x = y }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y = 0 }  (* premise *)
                            invariant { x = y }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 29
          origin: [child, 15, 1]
        "29":
          kind: Failure
          success_value: null
          summary_message: too many remaining obligations
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 28, 0]
        "30":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (assertion)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                answers:
                  - id: 14
                    hint: null
                    value:
                      short: "['x - y = 0']"
                      long: "['x - y = 0']"
                      json_provided: true
                      json: [x - y = 0]
                  - id: 16
                    hint: null
                    value:
                      short: "['x - y = 0 || x - y = 2']"
                      long: "['x - y = 0 || x - y = 2']"
                      json_provided: true
                      json: [x - y = 0 || x - y = 2]
                  - id: 18
                    hint: null
                    value:
                      short: "['x <= y + 2']"
                      long: "['x <= y + 2']"
                      json_provided: true
                      json: [x <= y + 2]
                  - id: 19
                    hint: null
                    value:
                      short: "['x - y = 0']"
                      long: "['x - y = 0']"
                      json_provided: true
                      json: [x - y = 0]
                  - id: 21
                    hint: null
                    value:
                      short: "['x + y <= 4', 'x <= 2']"
                      long: "['x + y <= 4', 'x <= 2']"
                      json_provided: true
                      json: [x + y <= 4, x <= 2]
          actions:
            - ref:
                with_ids: cands{@14}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [14]
              value:
                short: "['x - y = 0']"
                long: "['x - y = 0']"
                json_provided: true
                json: [x - y = 0]
              destination: 31
            - ref:
                with_ids: cands{@16}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [16]
              value:
                short: "['x - y = 0 || x - y = 2']"
                long: "['x - y = 0 || x - y = 2']"
                json_provided: true
                json: [x - y = 0 || x - y = 2]
              destination: 33
            - ref:
                with_ids: cands{@18}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [18]
              value:
                short: "['x <= y + 2']"
                long: "['x <= y + 2']"
                json_provided: true
                json: [x <= y + 2]
              destination: 35
            - ref:
                with_ids: cands{@19}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [19]
              value:
                short: "['x - y = 0']"
                long: "['x - y = 0']"
                json_provided: true
                json: [x - y = 0]
              destination: 36
            - ref:
                with_ids: cands{@21}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [21]
              value:
                short: "['x + y <= 4', 'x <= 2']"
                long: "['x + y <= 4', 'x <= 2']"
                json_provided: true
                json: [x + y <= 4, x <= 2]
              destination: 38
          origin: [nested, 3, 2]
        "31":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x - y = 0]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                answers:
                  - id: 15
                    hint: null
                    value:
                      short: "False"
                      long: "False"
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: cands{@15}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [15]
              value:
                short: "False"
                long: "False"
                json_provided: true
                json: false
              destination: 32
          origin: [child, 30, 0]
        "32":
          kind: Failure
          success_value: null
          summary_message: proposal is not novel
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 31, 0]
        "33":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x - y = 0 || x - y = 2]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                answers:
                  - id: 17
                    hint: null
                    value:
                      short: "False"
                      long: "False"
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: cands{@17}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [17]
              value:
                short: "False"
                long: "False"
                json_provided: true
                json: false
              destination: 34
          origin: [child, 30, 1]
        "34":
          kind: Failure
          success_value: null
          summary_message: proposal is not novel
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 33, 0]
        "35":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x <= y + 2]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                answers: []
          actions: []
          origin: [child, 30, 2]
        "36":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x - y = 0]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                answers:
                  - id: 20
                    hint: null
                    value:
                      short: "False"
                      long: "False"
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: cands{@20}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [20]
              value:
                short: "False"
                long: "False"
                json_provided: true
                json: false
              destination: 37
          origin: [child, 30, 3]
        "37":
          kind: Failure
          success_value: null
          summary_message: proposal is not novel
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 36, 0]
        "38":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x + y <= 4, x <= 2]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                answers:
                  - id: 22
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@22}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [22]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 39
          origin: [child, 30, 4]
        "39":
          kind: Success
          success_value:
            short: (['x + y <= 4', 'x <= 2'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2']])
            long: |-
              (['x + y <= 4', 'x <= 2'],
               [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2']])
            json_provided: true
            json:
              - [x + y <= 4, x <= 2]
              - - [x mod 2 = 0, y mod 2 = 0]
                - [x = y]
                - [x + y <= 4, x <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 38, 0]
        "40":
          kind: Success
          success_value:
            short: "['x + y <= 4', 'x <= 2']"
            long: "['x + y <= 4', 'x <= 2']"
            json_provided: true
            json: [x + y <= 4, x <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 3, 2]
        "41":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x + y <= 4 }
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 23
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x + y <= 4 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x + y <= 4 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x + y <= 4 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x + y <= 4 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x + y <= 4 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x + y <= 4 }  (* GOAL *)
                                  invariant { x <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x + y <= 4 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x + y <= 4 }  (* GOAL, premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x + y <= 4 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x + y <= 4 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@23}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [23]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x + y <= 4 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x + y <= 4 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x + y <= 4 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x + y <= 4 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x + y <= 4 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x + y <= 4 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x + y <= 4 }  (* GOAL *)
                            invariant { x <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x + y <= 4 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x + y <= 4 }  (* GOAL, premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x + y <= 4 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x + y <= 4 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 42
          origin: [child, 2, 2]
        "42":
          kind: Failure
          success_value: null
          summary_message: too many remaining obligations
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 41, 0]
        "43":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (assertion)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                answers:
                  - id: 24
                    hint: null
                    value:
                      short: "['x - y <= 2', 'x <= 2']"
                      long: "['x - y <= 2', 'x <= 2']"
                      json_provided: true
                      json: [x - y <= 2, x <= 2]
          actions:
            - ref:
                with_ids: cands{@24}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [24]
              value:
                short: "['x - y <= 2', 'x <= 2']"
                long: "['x - y <= 2', 'x <= 2']"
                json_provided: true
                json: [x - y <= 2, x <= 2]
              destination: 44
          origin: [nested, 3, 3]
        "44":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x - y <= 2, x <= 2]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                answers:
                  - id: 25
                    hint: null
                    value:
                      short: No final code block found.
                      long: ParseError(error='No final code block found.')
                      json_provided: true
                      json:
                        error: No final code block found.
                  - id: 26
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@26}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [26]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 45
          origin: [child, 43, 0]
        "45":
          kind: Success
          success_value:
            short: (['x - y <= 2', 'x <= 2'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2']])
            long: |-
              (['x - y <= 2', 'x <= 2'],
               [['x mod 2 = 0', 'y mod 2 = 0'],
                ['x = y'],
                ['x + y <= 4', 'x <= 2'],
                ['x - y <= 2', 'x <= 2']])
            json_provided: true
            json:
              - [x - y <= 2, x <= 2]
              - - [x mod 2 = 0, y mod 2 = 0]
                - [x = y]
                - [x + y <= 4, x <= 2]
                - [x - y <= 2, x <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 44, 0]
        "46":
          kind: Success
          success_value:
            short: "['x - y <= 2', 'x <= 2']"
            long: "['x - y <= 2', 'x <= 2']"
            json_provided: true
            json: [x - y <= 2, x <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 3, 3]
        "47":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x - y <= 2 }
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 27
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* GOAL *)
                                  invariant { x <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* GOAL, premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@27}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [27]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* GOAL *)
                            invariant { x <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* GOAL, premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 48
          origin: [child, 2, 3]
        "48":
          kind: Value
          success_value: null
          summary_message: null
          leaf_node: false
          label: EvaluateProofState
          properties:
            - - with_ids: eval
                with_hints: null
              - kind: query
                name: EvaluateProofState
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant preservation)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 28
                    hint: null
                    value:
                      short: ProofStateMetrics(prob_incorrect=0.9, prob_redundant=0.1)
                      long: ProofStateMetrics(prob_incorrect=0.9, prob_redundant=0.1)
                      json_provided: true
                      json:
                        prob_incorrect: 0.9
                        prob_redundant: 0.1
          actions:
            - ref:
                with_ids: nil
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: []
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 49
          origin: [child, 47, 0]
        "49":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: iterate
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: nested
                strategy: iterate
                args:
                  next:
                    short: <function prove_program.<locals>.<lambda> at 0x1169fec00>
                    long: <function prove_program.<locals>.<lambda> at 0x1169fec00>
                    json_provided: false
                    json: null
                node_id: 50
          actions:
            - ref:
                with_ids: cands{%53}
                with_hints: null
              hints: null
              related_success_nodes: [53]
              related_answers: []
              value:
                short: "['x - y <= 2', 'x <= 2', 'x <= y']"
                long: "['x - y <= 2', 'x <= 2', 'x <= y']"
                json_provided: true
                json: [x - y <= 2, x <= 2, x <= y]
              destination: 54
            - ref:
                with_ids: cands{%59}
                with_hints: null
              hints: null
              related_success_nodes: [59]
              related_answers: []
              value:
                short: "['x - y = 0']"
                long: "['x - y = 0']"
                json_provided: true
                json: [x - y = 0]
              destination: 60
          origin: [child, 48, 0]
        "50":
          kind: Iteration
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: next(nil)
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant preservation)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x - y <= 2 }  (* premise *)\n    invariant { x <= 2 }  (* GOAL, premise *)\n    x <- x + 2;  (* premise *)\n    y <- y + 2  (* premise *)\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant preservation)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x - y <= 2 }  (* premise '
                                                         '*)\n'
                                                         '    invariant { x <= 2 }  (* GOAL, premise '
                                                         '*)\n'
                                                         '    x <- x + 2;  (* premise *)\n'
                                                         '    y <- y + 2  (* premise *)\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant preservation)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                node_id: 51
            - - with_ids: next(next(nil){%52}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant preservation)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x - y <= 2 }  (* premise *)\n    invariant { x <= 2 }  (* GOAL, premise *)\n    x <- x + 2;  (* premise *)\n    y <- y + 2  (* premise *)\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant preservation)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x - y <= 2 }  (* premise '
                                                         '*)\n'
                                                         '    invariant { x <= 2 }  (* GOAL, premise '
                                                         '*)\n'
                                                         '    x <- x + 2;  (* premise *)\n'
                                                         '    y <- y + 2  (* premise *)\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant preservation)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: "[['x - y <= 2', 'x <= 2', 'x <= y']]"
                    long: "[['x - y <= 2', 'x <= 2', 'x <= y']]"
                    json_provided: true
                    json:
                      - [x - y <= 2, x <= 2, x <= y]
                node_id: 56
          actions:
            - ref:
                with_ids: next(nil){%52}
                with_hints: null
              hints: null
              related_success_nodes: [52]
              related_answers: []
              value:
                short: (['x - y <= 2', 'x <= 2', 'x <= y'], [['x - y <= 2', 'x <= 2', 'x <= y']])
                long: (['x - y <= 2', 'x <= 2', 'x <= y'], [['x - y <= 2', 'x <= 2', 'x <= y']])
                json_provided: true
                json:
                  - [x - y <= 2, x <= 2, x <= y]
                  - - [x - y <= 2, x <= 2, x <= y]
              destination: 53
            - ref:
                with_ids: next(next(nil){%52}[1]){%58}
                with_hints: null
              hints: null
              related_success_nodes: [58, 52]
              related_answers: []
              value:
                short: (['x - y = 0'], [['x - y <= 2', 'x <= 2', 'x <= y'], ['x - y = 0']])
                long: (['x - y = 0'], [['x - y <= 2', 'x <= 2', 'x <= y'], ['x - y = 0']])
                json_provided: true
                json:
                  - [x - y = 0]
                  - - [x - y <= 2, x <= 2, x <= y]
                    - [x - y = 0]
              destination: 59
          origin: [nested, 49, 0]
        "51":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant preservation)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist: []
                answers:
                  - id: 29
                    hint: null
                    value:
                      short: "['x - y <= 2', 'x <= 2', 'x <= y']"
                      long: "['x - y <= 2', 'x <= 2', 'x <= y']"
                      json_provided: true
                      json: [x - y <= 2, x <= 2, x <= y]
          actions:
            - ref:
                with_ids: cands{@29}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [29]
              value:
                short: "['x - y <= 2', 'x <= 2', 'x <= y']"
                long: "['x - y <= 2', 'x <= 2', 'x <= y']"
                json_provided: true
                json: [x - y <= 2, x <= 2, x <= y]
              destination: 52
          origin: [nested, 50, 0]
        "52":
          kind: Success
          success_value:
            short: (['x - y <= 2', 'x <= 2', 'x <= y'], [['x - y <= 2', 'x <= 2', 'x <= y']])
            long: (['x - y <= 2', 'x <= 2', 'x <= y'], [['x - y <= 2', 'x <= 2', 'x <= y']])
            json_provided: true
            json:
              - [x - y <= 2, x <= 2, x <= y]
              - - [x - y <= 2, x <= 2, x <= y]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 51, 0]
        "53":
          kind: Success
          success_value:
            short: "['x - y <= 2', 'x <= 2', 'x <= y']"
            long: "['x - y <= 2', 'x <= 2', 'x <= y']"
            json_provided: true
            json: [x - y <= 2, x <= 2, x <= y]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 50, 0]
        "54":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x - y <= 2 }
                          invariant { x <= 2 }
                          invariant { x <= y }
                          invariant { x - y <= 2 }
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 30
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    invariant { x <= y }\\n    invariant { x - y <= 2 }\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    invariant { x <= y }\\n    invariant { x - y <= 2 }\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* GOAL *)\\n    invariant { x - y <= 2 }\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* GOAL, premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }\n'
                                                             '    invariant { x <= y }\n'
                                                             '    invariant { x - y <= 2 }\n'
                                                             '    invariant { x <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL *)\n'
                                                             '    invariant { x <= y }\n'
                                                             '    invariant { x - y <= 2 }\n'
                                                             '    invariant { x <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    invariant { x <= y }  (* GOAL *)\n'
                                                             '    invariant { x - y <= 2 }\n'
                                                             '    invariant { x <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    invariant { x <= y }  (* premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    invariant { x <= y }  (* premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    invariant { x <= y }  (* premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x <= y }  (* premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    invariant { x <= y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    invariant { x <= y }  (* premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    invariant { x <= y }  (* premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    invariant { x <= y }  (* premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* GOAL *)
                                  invariant { x <= 2 }
                                  invariant { x <= y }
                                  invariant { x - y <= 2 }
                                  invariant { x <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL *)
                                  invariant { x <= y }
                                  invariant { x - y <= 2 }
                                  invariant { x <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  invariant { x <= y }  (* GOAL *)
                                  invariant { x - y <= 2 }
                                  invariant { x <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  invariant { x <= y }  (* premise *)
                                  invariant { x - y <= 2 }  (* GOAL *)
                                  invariant { x <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  invariant { x <= y }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* GOAL, premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  invariant { x <= y }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL, premise *)
                                  invariant { x <= y }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  invariant { x <= y }  (* GOAL, premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  invariant { x <= y }  (* premise *)
                                  invariant { x - y <= 2 }  (* GOAL, premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  invariant { x <= y }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  invariant { x <= y }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@30}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [30]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    invariant { x <= y }\\n    invariant { x - y <= 2 }\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    invariant { x <= y }\\n    invariant { x - y <= 2 }\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* GOAL *)\\n    invariant { x - y <= 2 }\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* GOAL, premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    invariant { x <= y }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }\n'
                                                       '    invariant { x <= y }\n'
                                                       '    invariant { x - y <= 2 }\n'
                                                       '    invariant { x <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL *)\n'
                                                       '    invariant { x <= y }\n'
                                                       '    invariant { x - y <= 2 }\n'
                                                       '    invariant { x <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    invariant { x <= y }  (* GOAL *)\n'
                                                       '    invariant { x - y <= 2 }\n'
                                                       '    invariant { x <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    invariant { x <= y }  (* premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    invariant { x <= y }  (* premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    invariant { x <= y }  (* premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x <= y }  (* premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    invariant { x <= y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    invariant { x <= y }  (* premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    invariant { x <= y }  (* premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    invariant { x <= y }  (* premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* GOAL *)
                            invariant { x <= 2 }
                            invariant { x <= y }
                            invariant { x - y <= 2 }
                            invariant { x <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL *)
                            invariant { x <= y }
                            invariant { x - y <= 2 }
                            invariant { x <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            invariant { x <= y }  (* GOAL *)
                            invariant { x - y <= 2 }
                            invariant { x <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            invariant { x <= y }  (* premise *)
                            invariant { x - y <= 2 }  (* GOAL *)
                            invariant { x <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            invariant { x <= y }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* GOAL, premise *)
                            invariant { x <= 2 }  (* premise *)
                            invariant { x <= y }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL, premise *)
                            invariant { x <= y }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            invariant { x <= y }  (* GOAL, premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            invariant { x <= y }  (* premise *)
                            invariant { x - y <= 2 }  (* GOAL, premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            invariant { x <= y }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            invariant { x <= y }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 55
          origin: [child, 49, 0]
        "55":
          kind: Failure
          success_value: null
          summary_message: too many remaining obligations
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 54, 0]
        "56":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant preservation)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x <= 2 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist:
                    - [x - y <= 2, x <= 2, x <= y]
                answers:
                  - id: 31
                    hint: null
                    value:
                      short: "['x - y = 0']"
                      long: "['x - y = 0']"
                      json_provided: true
                      json: [x - y = 0]
          actions:
            - ref:
                with_ids: cands{@31}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [31]
              value:
                short: "['x - y = 0']"
                long: "['x - y = 0']"
                json_provided: true
                json: [x - y = 0]
              destination: 57
          origin: [nested, 50, 1]
        "57":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x - y = 0]
                  blacklist:
                    - [x - y <= 2, x <= 2, x <= y]
                answers:
                  - id: 32
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@32}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [32]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 58
          origin: [child, 56, 0]
        "58":
          kind: Success
          success_value:
            short: (['x - y = 0'], [['x - y <= 2', 'x <= 2', 'x <= y'], ['x - y = 0']])
            long: (['x - y = 0'], [['x - y <= 2', 'x <= 2', 'x <= y'], ['x - y = 0']])
            json_provided: true
            json:
              - [x - y = 0]
              - - [x - y <= 2, x <= 2, x <= y]
                - [x - y = 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 57, 0]
        "59":
          kind: Success
          success_value:
            short: "['x - y = 0']"
            long: "['x - y = 0']"
            json_provided: true
            json: [x - y = 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 50, 1]
        "60":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x - y = 0 }
                          invariant { x - y <= 2 }
                          invariant { x <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 33
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* GOAL *)\\n    invariant { x - y <= 2 }\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* GOAL, premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y = 0 }  (* GOAL *)\n'
                                                             '    invariant { x - y <= 2 }\n'
                                                             '    invariant { x <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y = 0 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y = 0 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y = 0 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y = 0 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y = 0 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x - y = 0 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 }  (* premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y = 0 }  (* GOAL *)
                                  invariant { x - y <= 2 }
                                  invariant { x <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y = 0 }  (* premise *)
                                  invariant { x - y <= 2 }  (* GOAL *)
                                  invariant { x <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y = 0 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y = 0 }  (* GOAL, premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y = 0 }  (* premise *)
                                  invariant { x - y <= 2 }  (* GOAL, premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y = 0 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x - y = 0 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x <= 2 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@33}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [33]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* GOAL *)\\n    invariant { x - y <= 2 }\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* GOAL, premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x - y = 0 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y = 0 }  (* GOAL *)\n'
                                                       '    invariant { x - y <= 2 }\n'
                                                       '    invariant { x <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y = 0 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y = 0 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y = 0 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y = 0 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y = 0 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x - y = 0 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 }  (* premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y = 0 }  (* GOAL *)
                            invariant { x - y <= 2 }
                            invariant { x <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y = 0 }  (* premise *)
                            invariant { x - y <= 2 }  (* GOAL *)
                            invariant { x <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y = 0 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y = 0 }  (* GOAL, premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y = 0 }  (* premise *)
                            invariant { x - y <= 2 }  (* GOAL, premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y = 0 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x - y = 0 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x <= 2 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 61
          origin: [child, 49, 1]
        "61":
          kind: Failure
          success_value: null
          summary_message: too many remaining obligations
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 60, 0]
        "62":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x - y >= -2 }  (* premise *)
                          invariant { x - y <= 2 }  (* premise *)
                          invariant { x = y }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist: []
                answers:
                  - id: 34
                    hint: null
                    value:
                      short: "['x = y']"
                      long: "['x = y']"
                      json_provided: true
                      json: [x = y]
          actions:
            - ref:
                with_ids: cands{@34}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [34]
              value:
                short: "['x = y']"
                long: "['x = y']"
                json_provided: true
                json: [x = y]
              destination: 63
          origin: [nested, 23, 0]
        "63":
          kind: Success
          success_value:
            short: (['x = y'], [['x = y']])
            long: (['x = y'], [['x = y']])
            json_provided: true
            json:
              - [x = y]
              - - [x = y]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 62, 0]
        "64":
          kind: Success
          success_value:
            short: "['x = y']"
            long: "['x = y']"
            json_provided: true
            json: [x = y]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 23, 0]
        "65":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x = y }
                          invariant { x - y >= -2 }
                          invariant { x - y <= 2 }
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 35
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* GOAL *)\\n    invariant { x - y >= -2 }\\n    invariant { x - y <= 2 }\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }\\n    invariant { x - y >= -2 }  (* GOAL *)\\n    invariant { x - y <= 2 }\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* GOAL, premise *)\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    invariant { x - y >= -2 }  (* GOAL, premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }  (* GOAL *)\n'
                                                             '    invariant { x - y >= -2 }\n'
                                                             '    invariant { x - y <= 2 }\n'
                                                             '    invariant { x = y }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }\n'
                                                             '    invariant { x - y >= -2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x - y <= 2 }\n'
                                                             '    invariant { x = y }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x = y }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    invariant { x - y >= -2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    invariant { x - y >= -2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x - y <= 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x = y }  (* premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }  (* GOAL *)
                                  invariant { x - y >= -2 }
                                  invariant { x - y <= 2 }
                                  invariant { x = y }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }
                                  invariant { x - y >= -2 }  (* GOAL *)
                                  invariant { x - y <= 2 }
                                  invariant { x = y }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* GOAL *)
                                  invariant { x = y }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x = y }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }  (* GOAL, premise *)
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }  (* premise *)
                                  invariant { x - y >= -2 }  (* GOAL, premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }  (* premise *)
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* GOAL, premise *)
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }  (* premise *)
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x = y }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x = y }  (* premise *)
                                  invariant { x - y >= -2 }  (* premise *)
                                  invariant { x - y <= 2 }  (* premise *)
                                  invariant { x = y }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@35}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [35]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* GOAL *)\\n    invariant { x - y >= -2 }\\n    invariant { x - y <= 2 }\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }\\n    invariant { x - y >= -2 }  (* GOAL *)\\n    invariant { x - y <= 2 }\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL *)\\n    invariant { x = y }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* GOAL, premise *)\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    invariant { x - y >= -2 }  (* GOAL, premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* GOAL, premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x = y }  (* premise *)\\n    invariant { x - y >= -2 }  (* premise *)\\n    invariant { x - y <= 2 }  (* premise *)\\n    invariant { x = y }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }  (* GOAL *)\n'
                                                       '    invariant { x - y >= -2 }\n'
                                                       '    invariant { x - y <= 2 }\n'
                                                       '    invariant { x = y }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }\n'
                                                       '    invariant { x - y >= -2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x - y <= 2 }\n'
                                                       '    invariant { x = y }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x = y }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    invariant { x - y >= -2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    invariant { x - y >= -2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x - y <= 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x = y }  (* premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* GOAL *)
                            invariant { x - y >= -2 }
                            invariant { x - y <= 2 }
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }
                            invariant { x - y >= -2 }  (* GOAL *)
                            invariant { x - y <= 2 }
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* GOAL *)
                            invariant { x = y }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x = y }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* GOAL, premise *)
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x = y }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* premise *)
                            invariant { x - y >= -2 }  (* GOAL, premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x = y }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* premise *)
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* GOAL, premise *)
                            invariant { x = y }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* premise *)
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x = y }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x = y }  (* premise *)
                            invariant { x - y >= -2 }  (* premise *)
                            invariant { x - y <= 2 }  (* premise *)
                            invariant { x = y }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 66
          origin: [child, 22, 0]
        "66":
          kind: Value
          success_value: null
          summary_message: null
          leaf_node: false
          label: EvaluateProofState
          properties:
            - - with_ids: eval
                with_hints: null
              - kind: query
                name: EvaluateProofState
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* GOAL *)
                          invariant { x - y >= -2 }
                          invariant { x - y <= 2 }
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 36
                    hint: null
                    value:
                      short: ProofStateMetrics(prob_incorrect=0.9, prob_redundant=0.8)
                      long: ProofStateMetrics(prob_incorrect=0.9, prob_redundant=0.8)
                      json_provided: true
                      json:
                        prob_incorrect: 0.9
                        prob_redundant: 0.8
          actions:
            - ref:
                with_ids: nil
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: []
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 67
          origin: [child, 65, 0]
        "67":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: iterate
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: nested
                strategy: iterate
                args:
                  next:
                    short: <function prove_program.<locals>.<lambda> at 0x11102a5c0>
                    long: <function prove_program.<locals>.<lambda> at 0x11102a5c0>
                    json_provided: false
                    json: null
                node_id: null
          actions: []
          origin: [child, 66, 0]
        "68":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (assertion)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                answers:
                  - id: 37
                    hint: null
                    value:
                      short: "['0 <= x - y <= 2']"
                      long: "['0 <= x - y <= 2']"
                      json_provided: true
                      json: [0 <= x - y <= 2]
          actions:
            - ref:
                with_ids: cands{@37}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [37]
              value:
                short: "['0 <= x - y <= 2']"
                long: "['0 <= x - y <= 2']"
                json_provided: true
                json: [0 <= x - y <= 2]
              destination: 69
          origin: [nested, 3, 4]
        "69":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [0 <= x - y <= 2]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                answers:
                  - id: 38
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@38}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [38]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 70
          origin: [child, 68, 0]
        "70":
          kind: Success
          success_value:
            short: (['0 <= x - y <= 2'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2'], ['0 <= x - y <= 2']])
            long: |-
              (['0 <= x - y <= 2'],
               [['x mod 2 = 0', 'y mod 2 = 0'],
                ['x = y'],
                ['x + y <= 4', 'x <= 2'],
                ['x - y <= 2', 'x <= 2'],
                ['0 <= x - y <= 2']])
            json_provided: true
            json:
              - [0 <= x - y <= 2]
              - - [x mod 2 = 0, y mod 2 = 0]
                - [x = y]
                - [x + y <= 4, x <= 2]
                - [x - y <= 2, x <= 2]
                - [0 <= x - y <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 69, 0]
        "71":
          kind: Success
          success_value:
            short: "['0 <= x - y <= 2']"
            long: "['0 <= x - y <= 2']"
            json_provided: true
            json: [0 <= x - y <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 3, 4]
        "72":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 39
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { 0 <= x - y <= 2 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@39}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [39]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { 0 <= x - y <= 2 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 73
          origin: [child, 2, 4]
        "73":
          kind: Value
          success_value: null
          summary_message: null
          leaf_node: false
          label: EvaluateProofState
          properties:
            - - with_ids: eval
                with_hints: null
              - kind: query
                name: EvaluateProofState
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 40
                    hint: null
                    value:
                      short: ProofStateMetrics(prob_incorrect=1.0, prob_redundant=0.0)
                      long: ProofStateMetrics(prob_incorrect=1.0, prob_redundant=0.0)
                      json_provided: true
                      json:
                        prob_incorrect: 1
                        prob_redundant: 0
          actions:
            - ref:
                with_ids: nil
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: []
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 74
          origin: [child, 72, 0]
        "74":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: iterate
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: nested
                strategy: iterate
                args:
                  next:
                    short: <function prove_program.<locals>.<lambda> at 0x11107b600>
                    long: <function prove_program.<locals>.<lambda> at 0x11107b600>
                    json_provided: false
                    json: null
                node_id: 75
          actions:
            - ref:
                with_ids: cands{%78}
                with_hints: null
              hints: null
              related_success_nodes: [78]
              related_answers: []
              value:
                short: "['0 <= x - y <= 2']"
                long: "['0 <= x - y <= 2']"
                json_provided: true
                json: [0 <= x - y <= 2]
              destination: 79
            - ref:
                with_ids: cands{%91}
                with_hints: null
              hints: null
              related_success_nodes: [91]
              related_answers: []
              value:
                short: "['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']"
                long: "['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']"
                json_provided: true
                json: [0 <= x <= 2*n + 2, 0 <= y <= 2*n + 2]
              destination: 92
          origin: [child, 73, 0]
        "75":
          kind: Iteration
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: next(nil)
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant init)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* GOAL, premise *)\n  let ref y = any int in  (* GOAL, premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x >= y }  (* GOAL *)\n    invariant { x <= y + 2 }\n    invariant { 0 <= x - y <= 2 }\n    invariant { 0 <= x - y <= 2 }\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant init)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  let ref y = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x >= y }  (* GOAL *)\n'
                                                         '    invariant { x <= y + 2 }\n'
                                                         '    invariant { 0 <= x - y <= 2 }\n'
                                                         '    invariant { 0 <= x - y <= 2 }\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant init)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* GOAL *)
                            invariant { x <= y + 2 }
                            invariant { 0 <= x - y <= 2 }
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                node_id: 76
            - - with_ids: next(next(nil){%77}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant init)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* GOAL, premise *)\n  let ref y = any int in  (* GOAL, premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x >= y }  (* GOAL *)\n    invariant { x <= y + 2 }\n    invariant { 0 <= x - y <= 2 }\n    invariant { 0 <= x - y <= 2 }\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant init)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  let ref y = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x >= y }  (* GOAL *)\n'
                                                         '    invariant { x <= y + 2 }\n'
                                                         '    invariant { 0 <= x - y <= 2 }\n'
                                                         '    invariant { 0 <= x - y <= 2 }\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant init)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* GOAL *)
                            invariant { x <= y + 2 }
                            invariant { 0 <= x - y <= 2 }
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: "[['0 <= x - y <= 2']]"
                    long: "[['0 <= x - y <= 2']]"
                    json_provided: true
                    json:
                      - [0 <= x - y <= 2]
                node_id: 83
          actions:
            - ref:
                with_ids: next(nil){%77}
                with_hints: null
              hints: null
              related_success_nodes: [77]
              related_answers: []
              value:
                short: (['0 <= x - y <= 2'], [['0 <= x - y <= 2']])
                long: (['0 <= x - y <= 2'], [['0 <= x - y <= 2']])
                json_provided: true
                json:
                  - [0 <= x - y <= 2]
                  - - [0 <= x - y <= 2]
              destination: 78
            - ref:
                with_ids: next(next(nil){%77}[1]){%90}
                with_hints: null
              hints: null
              related_success_nodes: [90, 77]
              related_answers: []
              value:
                short: (['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2'], [['0 <= x - y <= 2'], ['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']])
                long: |-
                  (['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2'],
                   [['0 <= x - y <= 2'], ['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']])
                json_provided: true
                json:
                  - [0 <= x <= 2*n + 2, 0 <= y <= 2*n + 2]
                  - - [0 <= x - y <= 2]
                    - [0 <= x <= 2*n + 2, 0 <= y <= 2*n + 2]
              destination: 91
          origin: [nested, 74, 0]
        "76":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist: []
                answers:
                  - id: 41
                    hint: null
                    value:
                      short: "['0 <= x - y <= 2']"
                      long: "['0 <= x - y <= 2']"
                      json_provided: true
                      json: [0 <= x - y <= 2]
          actions:
            - ref:
                with_ids: cands{@41}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [41]
              value:
                short: "['0 <= x - y <= 2']"
                long: "['0 <= x - y <= 2']"
                json_provided: true
                json: [0 <= x - y <= 2]
              destination: 77
          origin: [nested, 75, 0]
        "77":
          kind: Success
          success_value:
            short: (['0 <= x - y <= 2'], [['0 <= x - y <= 2']])
            long: (['0 <= x - y <= 2'], [['0 <= x - y <= 2']])
            json_provided: true
            json:
              - [0 <= x - y <= 2]
              - - [0 <= x - y <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 76, 0]
        "78":
          kind: Success
          success_value:
            short: "['0 <= x - y <= 2']"
            long: "['0 <= x - y <= 2']"
            json_provided: true
            json: [0 <= x - y <= 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 75, 0]
        "79":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { 0 <= x - y <= 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 42
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { 0 <= x - y <= 2 }  (* GOAL *)
                                  invariant { 0 <= x - y <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@42}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [42]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { 0 <= x - y <= 2 }  (* GOAL *)
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 80
          origin: [child, 74, 0]
        "80":
          kind: Value
          success_value: null
          summary_message: null
          leaf_node: false
          label: EvaluateProofState
          properties:
            - - with_ids: eval
                with_hints: null
              - kind: query
                name: EvaluateProofState
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 43
                    hint: null
                    value:
                      short: ProofStateMetrics(prob_incorrect=1.0, prob_redundant=0.9)
                      long: ProofStateMetrics(prob_incorrect=1.0, prob_redundant=0.9)
                      json_provided: true
                      json:
                        prob_incorrect: 1
                        prob_redundant: 0.9
          actions:
            - ref:
                with_ids: nil
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: []
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 81
          origin: [child, 79, 0]
        "81":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: iterate
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: nested
                strategy: iterate
                args:
                  next:
                    short: <function prove_program.<locals>.<lambda> at 0x1110b07c0>
                    long: <function prove_program.<locals>.<lambda> at 0x1110b07c0>
                    json_provided: false
                    json: null
                node_id: 82
          actions:
            - ref:
                with_ids: cands{%96}
                with_hints: null
              hints: null
              related_success_nodes: [96]
              related_answers: []
              value:
                short: "['x >= y', 'x <= y + 2']"
                long: "['x >= y', 'x <= y + 2']"
                json_provided: true
                json: [x >= y, x <= y + 2]
              destination: 97
            - ref:
                with_ids: cands{%111}
                with_hints: null
              hints: null
              related_success_nodes: [111]
              related_answers: []
              value:
                short: "['x <= y + 1', 'y <= x + 1']"
                long: "['x <= y + 1', 'y <= x + 1']"
                json_provided: true
                json: [x <= y + 1, y <= x + 1]
              destination: 112
          origin: [child, 80, 0]
        "82":
          kind: Iteration
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: next(nil)
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant init)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* GOAL, premise *)\n  let ref y = any int in  (* GOAL, premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x >= y }  (* GOAL *)\n    invariant { x <= y + 2 }\n    invariant { 0 <= x - y <= 2 }\n    invariant { 0 <= x - y <= 2 }\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant init)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  let ref y = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x >= y }  (* GOAL *)\n'
                                                         '    invariant { x <= y + 2 }\n'
                                                         '    invariant { 0 <= x - y <= 2 }\n'
                                                         '    invariant { 0 <= x - y <= 2 }\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant init)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* GOAL *)
                            invariant { x <= y + 2 }
                            invariant { 0 <= x - y <= 2 }
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                node_id: 94
            - - with_ids: next(next(nil){%95}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant init)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* GOAL, premise *)\n  let ref y = any int in  (* GOAL, premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x >= y }  (* GOAL *)\n    invariant { x <= y + 2 }\n    invariant { 0 <= x - y <= 2 }\n    invariant { 0 <= x - y <= 2 }\n    x <- x + 2;\n    y <- y + 2\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant init)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  let ref y = any int in  (* GOAL, premise '
                                                         '*)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x >= y }  (* GOAL *)\n'
                                                         '    invariant { x <= y + 2 }\n'
                                                         '    invariant { 0 <= x - y <= 2 }\n'
                                                         '    invariant { 0 <= x - y <= 2 }\n'
                                                         '    x <- x + 2;\n'
                                                         '    y <- y + 2\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant init)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* GOAL *)
                            invariant { x <= y + 2 }
                            invariant { 0 <= x - y <= 2 }
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: "[['x >= y', 'x <= y + 2']]"
                    long: "[['x >= y', 'x <= y + 2']]"
                    json_provided: true
                    json:
                      - [x >= y, x <= y + 2]
                node_id: 101
          actions:
            - ref:
                with_ids: next(nil){%95}
                with_hints: null
              hints: null
              related_success_nodes: [95]
              related_answers: []
              value:
                short: (['x >= y', 'x <= y + 2'], [['x >= y', 'x <= y + 2']])
                long: (['x >= y', 'x <= y + 2'], [['x >= y', 'x <= y + 2']])
                json_provided: true
                json:
                  - [x >= y, x <= y + 2]
                  - - [x >= y, x <= y + 2]
              destination: 96
            - ref:
                with_ids: next(next(nil){%95}[1]){%110}
                with_hints: null
              hints: null
              related_success_nodes: [110, 95]
              related_answers: []
              value:
                short: (['x <= y + 1', 'y <= x + 1'], [['x >= y', 'x <= y + 2'], ['x <= y + 1', 'y <= x + 1']])
                long: |-
                  (['x <= y + 1', 'y <= x + 1'],
                   [['x >= y', 'x <= y + 2'], ['x <= y + 1', 'y <= x + 1']])
                json_provided: true
                json:
                  - [x <= y + 1, y <= x + 1]
                  - - [x >= y, x <= y + 2]
                    - [x <= y + 1, y <= x + 1]
              destination: 111
          origin: [nested, 81, 0]
        "83":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist:
                    - [0 <= x - y <= 2]
                answers:
                  - id: 44
                    hint: null
                    value:
                      short: "['0 <= x <= 2', '0 <= y <= 2', 'x mod 2 = y mod 2']"
                      long: "['0 <= x <= 2', '0 <= y <= 2', 'x mod 2 = y mod 2']"
                      json_provided: true
                      json: [0 <= x <= 2, 0 <= y <= 2, x mod 2 = y mod 2]
                  - id: 48
                    hint: null
                    value:
                      short: "['x >= y']"
                      long: "['x >= y']"
                      json_provided: true
                      json: [x >= y]
                  - id: 49
                    hint: null
                    value:
                      short: "['0 <= x <= 2', '0 <= y <= 2', 'x - y = 0']"
                      long: "['0 <= x <= 2', '0 <= y <= 2', 'x - y = 0']"
                      json_provided: true
                      json: [0 <= x <= 2, 0 <= y <= 2, x - y = 0]
                  - id: 51
                    hint: null
                    value:
                      short: "['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']"
                      long: "['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']"
                      json_provided: true
                      json: [0 <= x <= 2*n + 2, 0 <= y <= 2*n + 2]
          actions:
            - ref:
                with_ids: cands{@44}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [44]
              value:
                short: "['0 <= x <= 2', '0 <= y <= 2', 'x mod 2 = y mod 2']"
                long: "['0 <= x <= 2', '0 <= y <= 2', 'x mod 2 = y mod 2']"
                json_provided: true
                json: [0 <= x <= 2, 0 <= y <= 2, x mod 2 = y mod 2]
              destination: 84
            - ref:
                with_ids: cands{@48}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [48]
              value:
                short: "['x >= y']"
                long: "['x >= y']"
                json_provided: true
                json: [x >= y]
              destination: 86
            - ref:
                with_ids: cands{@49}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [49]
              value:
                short: "['0 <= x <= 2', '0 <= y <= 2', 'x - y = 0']"
                long: "['0 <= x <= 2', '0 <= y <= 2', 'x - y = 0']"
                json_provided: true
                json: [0 <= x <= 2, 0 <= y <= 2, x - y = 0]
              destination: 87
            - ref:
                with_ids: cands{@51}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [51]
              value:
                short: "['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']"
                long: "['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']"
                json_provided: true
                json: [0 <= x <= 2*n + 2, 0 <= y <= 2*n + 2]
              destination: 89
          origin: [nested, 75, 1]
        "84":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [0 <= x <= 2, 0 <= y <= 2, x mod 2 = y mod 2]
                  blacklist:
                    - [0 <= x - y <= 2]
                answers:
                  - id: 45
                    hint: null
                    value:
                      short: No final code block found.
                      long: ParseError(error='No final code block found.')
                      json_provided: true
                      json:
                        error: No final code block found.
                  - id: 46
                    hint: null
                    value:
                      short: No final code block found.
                      long: ParseError(error='No final code block found.')
                      json_provided: true
                      json:
                        error: No final code block found.
                  - id: 47
                    hint: null
                    value:
                      short: "False"
                      long: "False"
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: cands{@47}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [47]
              value:
                short: "False"
                long: "False"
                json_provided: true
                json: false
              destination: 85
          origin: [child, 83, 0]
        "85":
          kind: Failure
          success_value: null
          summary_message: proposal is not novel
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 84, 0]
        "86":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x >= y]
                  blacklist:
                    - [0 <= x - y <= 2]
                answers: []
          actions: []
          origin: [child, 83, 1]
        "87":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [0 <= x <= 2, 0 <= y <= 2, x - y = 0]
                  blacklist:
                    - [0 <= x - y <= 2]
                answers:
                  - id: 50
                    hint: null
                    value:
                      short: "False"
                      long: "False"
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: cands{@50}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [50]
              value:
                short: "False"
                long: "False"
                json_provided: true
                json: false
              destination: 88
          origin: [child, 83, 2]
        "88":
          kind: Failure
          success_value: null
          summary_message: proposal is not novel
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 87, 0]
        "89":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [0 <= x <= 2*n + 2, 0 <= y <= 2*n + 2]
                  blacklist:
                    - [0 <= x - y <= 2]
                answers:
                  - id: 52
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@52}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [52]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 90
          origin: [child, 83, 3]
        "90":
          kind: Success
          success_value:
            short: (['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2'], [['0 <= x - y <= 2'], ['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']])
            long: |-
              (['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2'],
               [['0 <= x - y <= 2'], ['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']])
            json_provided: true
            json:
              - [0 <= x <= 2*n + 2, 0 <= y <= 2*n + 2]
              - - [0 <= x - y <= 2]
                - [0 <= x <= 2*n + 2, 0 <= y <= 2*n + 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 89, 0]
        "91":
          kind: Success
          success_value:
            short: "['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']"
            long: "['0 <= x <= 2*n + 2', '0 <= y <= 2*n + 2']"
            json_provided: true
            json: [0 <= x <= 2*n + 2, 0 <= y <= 2*n + 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 75, 1]
        "92":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { 0 <= x <= 2*n + 2 }
                          invariant { 0 <= y <= 2*n + 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 53
                    hint: null
                    value:
                      short: "{'error': \"File line 11, characters 28-29: unbound function or predicate symbol 'n'\", 'obligations': []}"
                      long: |-
                        {'error': 'File line 11, characters 28-29: unbound function or predicate '
                                  "symbol 'n'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: "File line 11, characters 28-29: unbound function or predicate symbol 'n'"
                        obligations: []
          actions:
            - ref:
                with_ids: query{@53}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [53]
              value:
                short: "{'error': \"File line 11, characters 28-29: unbound function or predicate symbol 'n'\", 'obligations': []}"
                long: |-
                  {'error': 'File line 11, characters 28-29: unbound function or predicate '
                            "symbol 'n'",
                   'obligations': []}
                json_provided: true
                json:
                  error: "File line 11, characters 28-29: unbound function or predicate symbol 'n'"
                  obligations: []
              destination: 93
          origin: [child, 74, 1]
        "93":
          kind: Failure
          success_value: null
          summary_message: invalid program
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 92, 0]
        "94":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { 0 <= x - y <= 2 }  (* GOAL *)
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist: []
                answers:
                  - id: 54
                    hint: null
                    value:
                      short: "['x >= y', 'x <= y + 2']"
                      long: "['x >= y', 'x <= y + 2']"
                      json_provided: true
                      json: [x >= y, x <= y + 2]
          actions:
            - ref:
                with_ids: cands{@54}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [54]
              value:
                short: "['x >= y', 'x <= y + 2']"
                long: "['x >= y', 'x <= y + 2']"
                json_provided: true
                json: [x >= y, x <= y + 2]
              destination: 95
          origin: [nested, 82, 0]
        "95":
          kind: Success
          success_value:
            short: (['x >= y', 'x <= y + 2'], [['x >= y', 'x <= y + 2']])
            long: (['x >= y', 'x <= y + 2'], [['x >= y', 'x <= y + 2']])
            json_provided: true
            json:
              - [x >= y, x <= y + 2]
              - - [x >= y, x <= y + 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 94, 0]
        "96":
          kind: Success
          success_value:
            short: "['x >= y', 'x <= y + 2']"
            long: "['x >= y', 'x <= y + 2']"
            json_provided: true
            json: [x >= y, x <= y + 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 82, 0]
        "97":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x >= y }
                          invariant { x <= y + 2 }
                          invariant { 0 <= x - y <= 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 55
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* GOAL *)\\n    invariant { x <= y + 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* GOAL, premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x >= y }  (* GOAL *)\n'
                                                             '    invariant { x <= y + 2 }\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    invariant { x <= y + 2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x >= y }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    invariant { x <= y + 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x >= y }  (* premise *)\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x >= y }  (* GOAL *)
                                  invariant { x <= y + 2 }
                                  invariant { 0 <= x - y <= 2 }
                                  invariant { 0 <= x - y <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x >= y }  (* premise *)
                                  invariant { x <= y + 2 }  (* GOAL *)
                                  invariant { 0 <= x - y <= 2 }
                                  invariant { 0 <= x - y <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x >= y }  (* premise *)
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL *)
                                  invariant { 0 <= x - y <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x >= y }  (* premise *)
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x >= y }  (* GOAL, premise *)
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x >= y }  (* premise *)
                                  invariant { x <= y + 2 }  (* GOAL, premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x >= y }  (* premise *)
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x >= y }  (* premise *)
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x >= y }  (* premise *)
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@55}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [55]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* GOAL *)\\n    invariant { x <= y + 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* GOAL, premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x >= y }  (* premise *)\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x >= y }  (* GOAL *)\n'
                                                       '    invariant { x <= y + 2 }\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    invariant { x <= y + 2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x >= y }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    invariant { x <= y + 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x >= y }  (* premise *)\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* GOAL *)
                            invariant { x <= y + 2 }
                            invariant { 0 <= x - y <= 2 }
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* premise *)
                            invariant { x <= y + 2 }  (* GOAL *)
                            invariant { 0 <= x - y <= 2 }
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* premise *)
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL *)
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* premise *)
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* GOAL, premise *)
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* premise *)
                            invariant { x <= y + 2 }  (* GOAL, premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* premise *)
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* premise *)
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x >= y }  (* premise *)
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 98
          origin: [child, 81, 0]
        "98":
          kind: Value
          success_value: null
          summary_message: null
          leaf_node: false
          label: EvaluateProofState
          properties:
            - - with_ids: eval
                with_hints: null
              - kind: query
                name: EvaluateProofState
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* GOAL *)
                          invariant { x <= y + 2 }
                          invariant { 0 <= x - y <= 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 56
                    hint: null
                    value:
                      short: ProofStateMetrics(prob_incorrect=0.9, prob_redundant=0.8)
                      long: ProofStateMetrics(prob_incorrect=0.9, prob_redundant=0.8)
                      json_provided: true
                      json:
                        prob_incorrect: 0.9
                        prob_redundant: 0.8
          actions:
            - ref:
                with_ids: nil
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: []
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 99
          origin: [child, 97, 0]
        "99":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: iterate
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: nested
                strategy: iterate
                args:
                  next:
                    short: <function prove_program.<locals>.<lambda> at 0x110e6fe20>
                    long: <function prove_program.<locals>.<lambda> at 0x110e6fe20>
                    json_provided: false
                    json: null
                node_id: null
          actions: []
          origin: [child, 98, 0]
        "100":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x = y }  (* GOAL *)
                          invariant { x - y >= -2 }
                          invariant { x - y <= 2 }
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist:
                    - [x = y]
                answers:
                  - id: 57
                    hint: null
                    value:
                      short: "['(x - y) mod 2 = 0']"
                      long: "['(x - y) mod 2 = 0']"
                      json_provided: true
                      json: [(x - y) mod 2 = 0]
          actions:
            - ref:
                with_ids: cands{@57}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [57]
              value:
                short: "['(x - y) mod 2 = 0']"
                long: "['(x - y) mod 2 = 0']"
                json_provided: true
                json: [(x - y) mod 2 = 0]
              destination: 102
          origin: [nested, 23, 1]
        "101":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant init)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* GOAL, premise *)
                        let ref y = any int in  (* GOAL, premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x >= y }  (* GOAL *)
                          invariant { x <= y + 2 }
                          invariant { 0 <= x - y <= 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist:
                    - [x >= y, x <= y + 2]
                answers:
                  - id: 58
                    hint: null
                    value:
                      short: "['x >= y', 'x <= y + 2', '0 <= x - y', 'x - y <= 2']"
                      long: "['x >= y', 'x <= y + 2', '0 <= x - y', 'x - y <= 2']"
                      json_provided: true
                      json: [x >= y, x <= y + 2, 0 <= x - y, x - y <= 2]
                  - id: 63
                    hint: null
                    value:
                      short: "['x <= y + 1', 'y <= x + 1']"
                      long: "['x <= y + 1', 'y <= x + 1']"
                      json_provided: true
                      json: [x <= y + 1, y <= x + 1]
          actions:
            - ref:
                with_ids: cands{@58}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [58]
              value:
                short: "['x >= y', 'x <= y + 2', '0 <= x - y', 'x - y <= 2']"
                long: "['x >= y', 'x <= y + 2', '0 <= x - y', 'x - y <= 2']"
                json_provided: true
                json: [x >= y, x <= y + 2, 0 <= x - y, x - y <= 2]
              destination: 103
            - ref:
                with_ids: cands{@63}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [63]
              value:
                short: "['x <= y + 1', 'y <= x + 1']"
                long: "['x <= y + 1', 'y <= x + 1']"
                json_provided: true
                json: [x <= y + 1, y <= x + 1]
              destination: 109
          origin: [nested, 82, 1]
        "102":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [(x - y) mod 2 = 0]
                  blacklist:
                    - [x = y]
                answers:
                  - id: 59
                    hint: null
                    value:
                      short: No final code block found.
                      long: ParseError(error='No final code block found.')
                      json_provided: true
                      json:
                        error: No final code block found.
                  - id: 61
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@61}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [61]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 105
          origin: [child, 100, 0]
        "103":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x >= y, x <= y + 2, 0 <= x - y, x - y <= 2]
                  blacklist:
                    - [x >= y, x <= y + 2]
                answers:
                  - id: 60
                    hint: null
                    value:
                      short: "False"
                      long: "False"
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: cands{@60}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [60]
              value:
                short: "False"
                long: "False"
                json_provided: true
                json: false
              destination: 104
          origin: [child, 101, 0]
        "104":
          kind: Failure
          success_value: null
          summary_message: proposal is not novel
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 103, 0]
        "105":
          kind: Success
          success_value:
            short: (['(x - y) mod 2 = 0'], [['x = y'], ['(x - y) mod 2 = 0']])
            long: (['(x - y) mod 2 = 0'], [['x = y'], ['(x - y) mod 2 = 0']])
            json_provided: true
            json:
              - [(x - y) mod 2 = 0]
              - - [x = y]
                - [(x - y) mod 2 = 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 102, 0]
        "106":
          kind: Success
          success_value:
            short: "['(x - y) mod 2 = 0']"
            long: "['(x - y) mod 2 = 0']"
            json_provided: true
            json: [(x - y) mod 2 = 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 23, 1]
        "107":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { (x - y) mod 2 = 0 }
                          invariant { x - y >= -2 }
                          invariant { x - y <= 2 }
                          invariant { x = y }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 62
                    hint: null
                    value:
                      short: "{'error': \"File line 11, characters 24-27: unbound function or predicate symbol 'mod'\", 'obligations': []}"
                      long: |-
                        {'error': 'File line 11, characters 24-27: unbound function or predicate '
                                  "symbol 'mod'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: "File line 11, characters 24-27: unbound function or predicate symbol 'mod'"
                        obligations: []
          actions:
            - ref:
                with_ids: query{@62}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [62]
              value:
                short: "{'error': \"File line 11, characters 24-27: unbound function or predicate symbol 'mod'\", 'obligations': []}"
                long: |-
                  {'error': 'File line 11, characters 24-27: unbound function or predicate '
                            "symbol 'mod'",
                   'obligations': []}
                json_provided: true
                json:
                  error: "File line 11, characters 24-27: unbound function or predicate symbol 'mod'"
                  obligations: []
              destination: 108
          origin: [child, 22, 1]
        "108":
          kind: Failure
          success_value: null
          summary_message: invalid program
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 107, 0]
        "109":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x <= y + 1, y <= x + 1]
                  blacklist:
                    - [x >= y, x <= y + 2]
                answers:
                  - id: 64
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@64}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [64]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 110
          origin: [child, 101, 1]
        "110":
          kind: Success
          success_value:
            short: (['x <= y + 1', 'y <= x + 1'], [['x >= y', 'x <= y + 2'], ['x <= y + 1', 'y <= x + 1']])
            long: |-
              (['x <= y + 1', 'y <= x + 1'],
               [['x >= y', 'x <= y + 2'], ['x <= y + 1', 'y <= x + 1']])
            json_provided: true
            json:
              - [x <= y + 1, y <= x + 1]
              - - [x >= y, x <= y + 2]
                - [x <= y + 1, y <= x + 1]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 109, 0]
        "111":
          kind: Success
          success_value:
            short: "['x <= y + 1', 'y <= x + 1']"
            long: "['x <= y + 1', 'y <= x + 1']"
            json_provided: true
            json: [x <= y + 1, y <= x + 1]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 82, 1]
        "112":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x <= y + 1 }
                          invariant { y <= x + 1 }
                          invariant { 0 <= x - y <= 2 }
                          invariant { 0 <= x - y <= 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 65
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* GOAL *)\\n    invariant { y <= x + 1 }\\n    invariant { 0 <= x - y <= 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* GOAL, premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 1 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { y <= x + 1 }\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { y <= x + 1 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { y <= x + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { y <= x + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 1 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { y <= x + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { y <= x + 1 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { y <= x + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { y <= x + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { y <= x + 1 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { 0 <= x - y <= 2 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 1 }  (* GOAL *)
                                  invariant { y <= x + 1 }
                                  invariant { 0 <= x - y <= 2 }
                                  invariant { 0 <= x - y <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 1 }  (* premise *)
                                  invariant { y <= x + 1 }  (* GOAL *)
                                  invariant { 0 <= x - y <= 2 }
                                  invariant { 0 <= x - y <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 1 }  (* premise *)
                                  invariant { y <= x + 1 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL *)
                                  invariant { 0 <= x - y <= 2 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 1 }  (* premise *)
                                  invariant { y <= x + 1 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 1 }  (* GOAL, premise *)
                                  invariant { y <= x + 1 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 1 }  (* premise *)
                                  invariant { y <= x + 1 }  (* GOAL, premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 1 }  (* premise *)
                                  invariant { y <= x + 1 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 1 }  (* premise *)
                                  invariant { y <= x + 1 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 1 }  (* premise *)
                                  invariant { y <= x + 1 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  invariant { 0 <= x - y <= 2 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@65}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [65]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* GOAL *)\\n    invariant { y <= x + 1 }\\n    invariant { 0 <= x - y <= 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    invariant { 0 <= x - y <= 2 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* GOAL, premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 1 }  (* premise *)\\n    invariant { y <= x + 1 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    invariant { 0 <= x - y <= 2 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 1 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { y <= x + 1 }\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { y <= x + 1 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { y <= x + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { y <= x + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 1 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { y <= x + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { y <= x + 1 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { y <= x + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { y <= x + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { y <= x + 1 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { 0 <= x - y <= 2 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 1 }  (* GOAL *)
                            invariant { y <= x + 1 }
                            invariant { 0 <= x - y <= 2 }
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 1 }  (* premise *)
                            invariant { y <= x + 1 }  (* GOAL *)
                            invariant { 0 <= x - y <= 2 }
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 1 }  (* premise *)
                            invariant { y <= x + 1 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL *)
                            invariant { 0 <= x - y <= 2 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 1 }  (* premise *)
                            invariant { y <= x + 1 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 1 }  (* GOAL, premise *)
                            invariant { y <= x + 1 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 1 }  (* premise *)
                            invariant { y <= x + 1 }  (* GOAL, premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 1 }  (* premise *)
                            invariant { y <= x + 1 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 1 }  (* premise *)
                            invariant { y <= x + 1 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 1 }  (* premise *)
                            invariant { y <= x + 1 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            invariant { 0 <= x - y <= 2 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 113
          origin: [child, 81, 1]
        "113":
          kind: Failure
          success_value: null
          summary_message: too many remaining obligations
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 112, 0]
        "114":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (assertion)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
                answers:
                  - id: 66
                    hint: null
                    value:
                      short: "['y >= 0', 'x >= 0', 'x <= y + 2']"
                      long: "['y >= 0', 'x >= 0', 'x <= y + 2']"
                      json_provided: true
                      json: [y >= 0, x >= 0, x <= y + 2]
                  - id: 68
                    hint: null
                    value:
                      short: "['x <= 2 || y <> 0']"
                      long: "['x <= 2 || y <> 0']"
                      json_provided: true
                      json: [x <= 2 || y <> 0]
          actions:
            - ref:
                with_ids: cands{@66}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [66]
              value:
                short: "['y >= 0', 'x >= 0', 'x <= y + 2']"
                long: "['y >= 0', 'x >= 0', 'x <= y + 2']"
                json_provided: true
                json: [y >= 0, x >= 0, x <= y + 2]
              destination: 115
            - ref:
                with_ids: cands{@68}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [68]
              value:
                short: "['x <= 2 || y <> 0']"
                long: "['x <= 2 || y <> 0']"
                json_provided: true
                json: [x <= 2 || y <> 0]
              destination: 117
          origin: [nested, 3, 5]
        "115":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [y >= 0, x >= 0, x <= y + 2]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
                answers:
                  - id: 67
                    hint: null
                    value:
                      short: "False"
                      long: "False"
                      json_provided: true
                      json: false
          actions:
            - ref:
                with_ids: cands{@67}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [67]
              value:
                short: "False"
                long: "False"
                json_provided: true
                json: false
              destination: 116
          origin: [child, 114, 0]
        "116":
          kind: Failure
          success_value: null
          summary_message: proposal is not novel
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 115, 0]
        "117":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x <= 2 || y <> 0]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
                answers:
                  - id: 69
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@69}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [69]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 118
          origin: [child, 114, 1]
        "118":
          kind: Success
          success_value:
            short: (['x <= 2 || y <> 0'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2'], ['0 <= x - y <= 2'], ['x <= 2 || y <> 0']])
            long: |-
              (['x <= 2 || y <> 0'],
               [['x mod 2 = 0', 'y mod 2 = 0'],
                ['x = y'],
                ['x + y <= 4', 'x <= 2'],
                ['x - y <= 2', 'x <= 2'],
                ['0 <= x - y <= 2'],
                ['x <= 2 || y <> 0']])
            json_provided: true
            json:
              - [x <= 2 || y <> 0]
              - - [x mod 2 = 0, y mod 2 = 0]
                - [x = y]
                - [x + y <= 4, x <= 2]
                - [x - y <= 2, x <= 2]
                - [0 <= x - y <= 2]
                - [x <= 2 || y <> 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 117, 0]
        "119":
          kind: Success
          success_value:
            short: "['x <= 2 || y <> 0']"
            long: "['x <= 2 || y <> 0']"
            json_provided: true
            json: [x <= 2 || y <> 0]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 3, 5]
        "120":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x <= 2 || y <> 0 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 70
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= 2 || y <> 0 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= 2 || y <> 0 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@70}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [70]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= 2 || y <> 0 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= 2 || y <> 0 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 121
          origin: [child, 2, 5]
        "121":
          kind: Value
          success_value: null
          summary_message: null
          leaf_node: false
          label: EvaluateProofState
          properties:
            - - with_ids: eval
                with_hints: null
              - kind: query
                name: EvaluateProofState
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant preservation)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 71
                    hint: null
                    value:
                      short: ProofStateMetrics(prob_incorrect=0.2, prob_redundant=0.3)
                      long: ProofStateMetrics(prob_incorrect=0.2, prob_redundant=0.3)
                      json_provided: true
                      json:
                        prob_incorrect: 0.2
                        prob_redundant: 0.3
          actions:
            - ref:
                with_ids: nil
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: []
              value:
                short: None
                long: None
                json_provided: true
                json: null
              destination: 122
          origin: [child, 120, 0]
        "122":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: iterate
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: nested
                strategy: iterate
                args:
                  next:
                    short: <function prove_program.<locals>.<lambda> at 0x107dd44a0>
                    long: <function prove_program.<locals>.<lambda> at 0x107dd44a0>
                    json_provided: false
                    json: null
                node_id: 123
          actions:
            - ref:
                with_ids: cands{%126}
                with_hints: null
              hints: null
              related_success_nodes: [126]
              related_answers: []
              value:
                short: "['x mod 2 = y mod 2', 'x <= y + 2']"
                long: "['x mod 2 = y mod 2', 'x <= y + 2']"
                json_provided: true
                json: [x mod 2 = y mod 2, x <= y + 2]
              destination: 127
            - ref:
                with_ids: cands{%132}
                with_hints: null
              hints: null
              related_success_nodes: [132]
              related_answers: []
              value:
                short: "['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']"
                long: "['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']"
                json_provided: true
                json: [x <= y + 2, x <= 2 || y <> 0, x <= 4, y <= 4]
              destination: 133
          origin: [child, 121, 0]
        "123":
          kind: Iteration
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: next(nil)
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant preservation)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)\n    x <- x + 2;  (* premise *)\n    y <- y + 2  (* premise *)\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant preservation)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x <= 2 || y <> 0 }  (* '
                                                         'GOAL, premise *)\n'
                                                         '    x <- x + 2;  (* premise *)\n'
                                                         '    y <- y + 2  (* premise *)\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant preservation)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: None
                    long: None
                    json_provided: true
                    json: null
                node_id: 124
            - - with_ids: next(next(nil){%125}[1])
                with_hints: null
              - kind: nested
                strategy: propose_invariants
                args:
                  obligation:
                    short: UnprovedObligation(obligation_name='VC for main (loop invariant preservation)', relevance_hints='use int.Int\n\nlet main () diverges =  (* GOAL *)\n  let ref x = any int in  (* premise *)\n  let ref y = any int in  (* premise *)\n  assume { x >= 0 };  (* premise *)\n  assume { x <= 2 };  (* premise *)\n  assume { y <= 2 };  (* premise *)\n  assume { y >= 0 };  (* premise *)\n  while any bool do\n    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)\n    x <- x + 2;  (* premise *)\n    y <- y + 2  (* premise *)\n  done;\n  if y = 0 then\n    assert { x <> 4 }')
                    long: |-
                      UnprovedObligation(obligation_name='VC for main (loop invariant preservation)',
                                         relevance_hints='use int.Int\n'
                                                         '\n'
                                                         'let main () diverges =  (* GOAL *)\n'
                                                         '  let ref x = any int in  (* premise *)\n'
                                                         '  let ref y = any int in  (* premise *)\n'
                                                         '  assume { x >= 0 };  (* premise *)\n'
                                                         '  assume { x <= 2 };  (* premise *)\n'
                                                         '  assume { y <= 2 };  (* premise *)\n'
                                                         '  assume { y >= 0 };  (* premise *)\n'
                                                         '  while any bool do\n'
                                                         '    invariant { x <= 2 || y <> 0 }  (* '
                                                         'GOAL, premise *)\n'
                                                         '    x <- x + 2;  (* premise *)\n'
                                                         '    y <- y + 2  (* premise *)\n'
                                                         '  done;\n'
                                                         '  if y = 0 then\n'
                                                         '    assert { x <> 4 }')
                    json_provided: true
                    json:
                      obligation_name: VC for main (loop invariant preservation)
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                  blacklist:
                    short: "[['x mod 2 = y mod 2', 'x <= y + 2']]"
                    long: "[['x mod 2 = y mod 2', 'x <= y + 2']]"
                    json_provided: true
                    json:
                      - [x mod 2 = y mod 2, x <= y + 2]
                node_id: 129
          actions:
            - ref:
                with_ids: next(nil){%125}
                with_hints: null
              hints: null
              related_success_nodes: [125]
              related_answers: []
              value:
                short: (['x mod 2 = y mod 2', 'x <= y + 2'], [['x mod 2 = y mod 2', 'x <= y + 2']])
                long: (['x mod 2 = y mod 2', 'x <= y + 2'], [['x mod 2 = y mod 2', 'x <= y + 2']])
                json_provided: true
                json:
                  - [x mod 2 = y mod 2, x <= y + 2]
                  - - [x mod 2 = y mod 2, x <= y + 2]
              destination: 126
            - ref:
                with_ids: next(next(nil){%125}[1]){%131}
                with_hints: null
              hints: null
              related_success_nodes: [131, 125]
              related_answers: []
              value:
                short: (['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4'], [['x mod 2 = y mod 2', 'x <= y + 2'], ['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']])
                long: |-
                  (['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4'],
                   [['x mod 2 = y mod 2', 'x <= y + 2'],
                    ['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']])
                json_provided: true
                json:
                  - [x <= y + 2, x <= 2 || y <> 0, x <= 4, y <= 4]
                  - - [x mod 2 = y mod 2, x <= y + 2]
                    - [x <= y + 2, x <= 2 || y <> 0, x <= 4, y <= 4]
              destination: 132
          origin: [nested, 122, 0]
        "124":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant preservation)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist: []
                answers:
                  - id: 72
                    hint: null
                    value:
                      short: "['x mod 2 = y mod 2', 'x <= y + 2']"
                      long: "['x mod 2 = y mod 2', 'x <= y + 2']"
                      json_provided: true
                      json: [x mod 2 = y mod 2, x <= y + 2]
          actions:
            - ref:
                with_ids: cands{@72}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [72]
              value:
                short: "['x mod 2 = y mod 2', 'x <= y + 2']"
                long: "['x mod 2 = y mod 2', 'x <= y + 2']"
                json_provided: true
                json: [x mod 2 = y mod 2, x <= y + 2]
              destination: 125
          origin: [nested, 123, 0]
        "125":
          kind: Success
          success_value:
            short: (['x mod 2 = y mod 2', 'x <= y + 2'], [['x mod 2 = y mod 2', 'x <= y + 2']])
            long: (['x mod 2 = y mod 2', 'x <= y + 2'], [['x mod 2 = y mod 2', 'x <= y + 2']])
            json_provided: true
            json:
              - [x mod 2 = y mod 2, x <= y + 2]
              - - [x mod 2 = y mod 2, x <= y + 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 124, 0]
        "126":
          kind: Success
          success_value:
            short: "['x mod 2 = y mod 2', 'x <= y + 2']"
            long: "['x mod 2 = y mod 2', 'x <= y + 2']"
            json_provided: true
            json: [x mod 2 = y mod 2, x <= y + 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 123, 0]
        "127":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x mod 2 = y mod 2 }
                          invariant { x <= y + 2 }
                          invariant { x <= 2 || y <> 0 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 73
                    hint: null
                    value:
                      short: "{'error': \"File line 11, characters 18-21: unbound function or predicate symbol 'mod'\", 'obligations': []}"
                      long: |-
                        {'error': 'File line 11, characters 18-21: unbound function or predicate '
                                  "symbol 'mod'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: "File line 11, characters 18-21: unbound function or predicate symbol 'mod'"
                        obligations: []
          actions:
            - ref:
                with_ids: query{@73}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [73]
              value:
                short: "{'error': \"File line 11, characters 18-21: unbound function or predicate symbol 'mod'\", 'obligations': []}"
                long: |-
                  {'error': 'File line 11, characters 18-21: unbound function or predicate '
                            "symbol 'mod'",
                   'obligations': []}
                json_provided: true
                json:
                  error: "File line 11, characters 18-21: unbound function or predicate symbol 'mod'"
                  obligations: []
              destination: 128
          origin: [child, 122, 0]
        "128":
          kind: Failure
          success_value: null
          summary_message: invalid program
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 127, 0]
        "129":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (loop invariant preservation)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                          x <- x + 2;  (* premise *)
                          y <- y + 2  (* premise *)
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                  blacklist:
                    - [x mod 2 = y mod 2, x <= y + 2]
                answers:
                  - id: 74
                    hint: null
                    value:
                      short: "['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']"
                      long: "['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']"
                      json_provided: true
                      json: [x <= y + 2, x <= 2 || y <> 0, x <= 4, y <= 4]
          actions:
            - ref:
                with_ids: cands{@74}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [74]
              value:
                short: "['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']"
                long: "['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']"
                json_provided: true
                json: [x <= y + 2, x <= 2 || y <> 0, x <= 4, y <= 4]
              destination: 130
          origin: [nested, 123, 1]
        "130":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x <= y + 2, x <= 2 || y <> 0, x <= 4, y <= 4]
                  blacklist:
                    - [x mod 2 = y mod 2, x <= y + 2]
                answers:
                  - id: 75
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@75}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [75]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 131
          origin: [child, 129, 0]
        "131":
          kind: Success
          success_value:
            short: (['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4'], [['x mod 2 = y mod 2', 'x <= y + 2'], ['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']])
            long: |-
              (['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4'],
               [['x mod 2 = y mod 2', 'x <= y + 2'],
                ['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']])
            json_provided: true
            json:
              - [x <= y + 2, x <= 2 || y <> 0, x <= 4, y <= 4]
              - - [x mod 2 = y mod 2, x <= y + 2]
                - [x <= y + 2, x <= 2 || y <> 0, x <= 4, y <= 4]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 130, 0]
        "132":
          kind: Success
          success_value:
            short: "['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']"
            long: "['x <= y + 2', 'x <= 2 || y <> 0', 'x <= 4', 'y <= 4']"
            json_provided: true
            json: [x <= y + 2, x <= 2 || y <> 0, x <= 4, y <= 4]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 123, 1]
        "133":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x <= y + 2 }
                          invariant { x <= 2 || y <> 0 }
                          invariant { x <= 4 }
                          invariant { y <= 4 }
                          invariant { x <= 2 || y <> 0 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 76
                    hint: null
                    value:
                      short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* GOAL *)\\n    invariant { x <= 2 || y <> 0 }\\n    invariant { x <= 4 }\\n    invariant { y <= 4 }\\n    invariant { x <= 2 || y <> 0 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* GOAL *)\\n    invariant { x <= 4 }\\n    invariant { y <= 4 }\\n    invariant { x <= 2 || y <> 0 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* GOAL *)\\n    invariant { y <= 4 }\\n    invariant { x <= 2 || y <> 0 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* GOAL *)\\n    invariant { x <= 2 || y <> 0 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* GOAL, premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* GOAL, premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                      long: |-
                        {'error': None,
                         'obligations': [{'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* GOAL '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }\n'
                                                             '    invariant { x <= 4 }\n'
                                                             '    invariant { y <= 4 }\n'
                                                             '    invariant { x <= 2 || y <> 0 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'GOAL *)\n'
                                                             '    invariant { x <= 4 }\n'
                                                             '    invariant { y <= 4 }\n'
                                                             '    invariant { x <= 2 || y <> 0 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x <= 4 }  (* GOAL *)\n'
                                                             '    invariant { y <= 4 }\n'
                                                             '    invariant { x <= 2 || y <> 0 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x <= 4 }  (* premise *)\n'
                                                             '    invariant { y <= 4 }  (* GOAL *)\n'
                                                             '    invariant { x <= 2 || y <> 0 }\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant init)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  let ref y = any int in  (* GOAL, '
                                                             'premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x <= 4 }  (* premise *)\n'
                                                             '    invariant { y <= 4 }  (* premise *)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'GOAL *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x <= 4 }  (* premise *)\n'
                                                             '    invariant { y <= 4 }  (* premise *)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    invariant { x <= 4 }  (* premise *)\n'
                                                             '    invariant { y <= 4 }  (* premise *)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x <= 4 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { y <= 4 }  (* premise *)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': False,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x <= 4 }  (* premise *)\n'
                                                             '    invariant { y <= 4 }  (* GOAL, '
                                                             'premise *)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (loop invariant preservation)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x <= 4 }  (* premise *)\n'
                                                             '    invariant { y <= 4 }  (* premise *)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'GOAL, premise *)\n'
                                                             '    x <- x + 2;  (* premise *)\n'
                                                             '    y <- y + 2  (* premise *)\n'
                                                             '  done;\n'
                                                             '  if y = 0 then\n'
                                                             '    assert { x <> 4 }'},
                                         {'name': 'VC for main (assertion)',
                                          'proved': True,
                                          'relevance_hints': 'use int.Int\n'
                                                             '\n'
                                                             'let main () diverges =  (* GOAL *)\n'
                                                             '  let ref x = any int in  (* premise *)\n'
                                                             '  let ref y = any int in  (* premise *)\n'
                                                             '  assume { x >= 0 };  (* premise *)\n'
                                                             '  assume { x <= 2 };  (* premise *)\n'
                                                             '  assume { y <= 2 };  (* premise *)\n'
                                                             '  assume { y >= 0 };  (* premise *)\n'
                                                             '  while any bool do\n'
                                                             '    invariant { x <= y + 2 }  (* premise '
                                                             '*)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    invariant { x <= 4 }  (* premise *)\n'
                                                             '    invariant { y <= 4 }  (* premise *)\n'
                                                             '    invariant { x <= 2 || y <> 0 }  (* '
                                                             'premise *)\n'
                                                             '    x <- x + 2;\n'
                                                             '    y <- y + 2\n'
                                                             '  done;\n'
                                                             '  if y = 0 then  (* premise *)\n'
                                                             '    assert { x <> 4 }  (* GOAL *)'}]}
                      json_provided: true
                      json:
                        error: null
                        obligations:
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* GOAL *)
                                  invariant { x <= 2 || y <> 0 }
                                  invariant { x <= 4 }
                                  invariant { y <= 4 }
                                  invariant { x <= 2 || y <> 0 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* GOAL *)
                                  invariant { x <= 4 }
                                  invariant { y <= 4 }
                                  invariant { x <= 2 || y <> 0 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  invariant { x <= 4 }  (* GOAL *)
                                  invariant { y <= 4 }
                                  invariant { x <= 2 || y <> 0 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  invariant { x <= 4 }  (* premise *)
                                  invariant { y <= 4 }  (* GOAL *)
                                  invariant { x <= 2 || y <> 0 }
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant init)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* GOAL, premise *)
                                let ref y = any int in  (* GOAL, premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  invariant { x <= 4 }  (* premise *)
                                  invariant { y <= 4 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* GOAL *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* GOAL, premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  invariant { x <= 4 }  (* premise *)
                                  invariant { y <= 4 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                                  invariant { x <= 4 }  (* premise *)
                                  invariant { y <= 4 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  invariant { x <= 4 }  (* GOAL, premise *)
                                  invariant { y <= 4 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: false
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  invariant { x <= 4 }  (* premise *)
                                  invariant { y <= 4 }  (* GOAL, premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (loop invariant preservation)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  invariant { x <= 4 }  (* premise *)
                                  invariant { y <= 4 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                                  x <- x + 2;  (* premise *)
                                  y <- y + 2  (* premise *)
                                done;
                                if y = 0 then
                                  assert { x <> 4 }
                          - name: VC for main (assertion)
                            proved: true
                            relevance_hints: |-
                              use int.Int

                              let main () diverges =  (* GOAL *)
                                let ref x = any int in  (* premise *)
                                let ref y = any int in  (* premise *)
                                assume { x >= 0 };  (* premise *)
                                assume { x <= 2 };  (* premise *)
                                assume { y <= 2 };  (* premise *)
                                assume { y >= 0 };  (* premise *)
                                while any bool do
                                  invariant { x <= y + 2 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  invariant { x <= 4 }  (* premise *)
                                  invariant { y <= 4 }  (* premise *)
                                  invariant { x <= 2 || y <> 0 }  (* premise *)
                                  x <- x + 2;
                                  y <- y + 2
                                done;
                                if y = 0 then  (* premise *)
                                  assert { x <> 4 }  (* GOAL *)
          actions:
            - ref:
                with_ids: query{@76}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [76]
              value:
                short: "{'error': None, 'obligations': [{'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* GOAL *)\\n    invariant { x <= 2 || y <> 0 }\\n    invariant { x <= 4 }\\n    invariant { y <= 4 }\\n    invariant { x <= 2 || y <> 0 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* GOAL *)\\n    invariant { x <= 4 }\\n    invariant { y <= 4 }\\n    invariant { x <= 2 || y <> 0 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* GOAL *)\\n    invariant { y <= 4 }\\n    invariant { x <= 2 || y <> 0 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* GOAL *)\\n    invariant { x <= 2 || y <> 0 }\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant init)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* GOAL, premise *)\\n  let ref y = any int in  (* GOAL, premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* GOAL *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* GOAL, premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* GOAL, premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': False, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* GOAL, premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (loop invariant preservation)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)\\n    x <- x + 2;  (* premise *)\\n    y <- y + 2  (* premise *)\\n  done;\\n  if y = 0 then\\n    assert { x <> 4 }'}, {'name': 'VC for main (assertion)', 'proved': True, 'relevance_hints': 'use int.Int\\n\\nlet main () diverges =  (* GOAL *)\\n  let ref x = any int in  (* premise *)\\n  let ref y = any int in  (* premise *)\\n  assume { x >= 0 };  (* premise *)\\n  assume { x <= 2 };  (* premise *)\\n  assume { y <= 2 };  (* premise *)\\n  assume { y >= 0 };  (* premise *)\\n  while any bool do\\n    invariant { x <= y + 2 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    invariant { x <= 4 }  (* premise *)\\n    invariant { y <= 4 }  (* premise *)\\n    invariant { x <= 2 || y <> 0 }  (* premise *)\\n    x <- x + 2;\\n    y <- y + 2\\n  done;\\n  if y = 0 then  (* premise *)\\n    assert { x <> 4 }  (* GOAL *)'}]}"
                long: |-
                  {'error': None,
                   'obligations': [{'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* GOAL '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }\n'
                                                       '    invariant { x <= 4 }\n'
                                                       '    invariant { y <= 4 }\n'
                                                       '    invariant { x <= 2 || y <> 0 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'GOAL *)\n'
                                                       '    invariant { x <= 4 }\n'
                                                       '    invariant { y <= 4 }\n'
                                                       '    invariant { x <= 2 || y <> 0 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x <= 4 }  (* GOAL *)\n'
                                                       '    invariant { y <= 4 }\n'
                                                       '    invariant { x <= 2 || y <> 0 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x <= 4 }  (* premise *)\n'
                                                       '    invariant { y <= 4 }  (* GOAL *)\n'
                                                       '    invariant { x <= 2 || y <> 0 }\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant init)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  let ref y = any int in  (* GOAL, '
                                                       'premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x <= 4 }  (* premise *)\n'
                                                       '    invariant { y <= 4 }  (* premise *)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'GOAL *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x <= 4 }  (* premise *)\n'
                                                       '    invariant { y <= 4 }  (* premise *)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    invariant { x <= 4 }  (* premise *)\n'
                                                       '    invariant { y <= 4 }  (* premise *)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x <= 4 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { y <= 4 }  (* premise *)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': False,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x <= 4 }  (* premise *)\n'
                                                       '    invariant { y <= 4 }  (* GOAL, '
                                                       'premise *)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (loop invariant preservation)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x <= 4 }  (* premise *)\n'
                                                       '    invariant { y <= 4 }  (* premise *)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'GOAL, premise *)\n'
                                                       '    x <- x + 2;  (* premise *)\n'
                                                       '    y <- y + 2  (* premise *)\n'
                                                       '  done;\n'
                                                       '  if y = 0 then\n'
                                                       '    assert { x <> 4 }'},
                                   {'name': 'VC for main (assertion)',
                                    'proved': True,
                                    'relevance_hints': 'use int.Int\n'
                                                       '\n'
                                                       'let main () diverges =  (* GOAL *)\n'
                                                       '  let ref x = any int in  (* premise *)\n'
                                                       '  let ref y = any int in  (* premise *)\n'
                                                       '  assume { x >= 0 };  (* premise *)\n'
                                                       '  assume { x <= 2 };  (* premise *)\n'
                                                       '  assume { y <= 2 };  (* premise *)\n'
                                                       '  assume { y >= 0 };  (* premise *)\n'
                                                       '  while any bool do\n'
                                                       '    invariant { x <= y + 2 }  (* premise '
                                                       '*)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    invariant { x <= 4 }  (* premise *)\n'
                                                       '    invariant { y <= 4 }  (* premise *)\n'
                                                       '    invariant { x <= 2 || y <> 0 }  (* '
                                                       'premise *)\n'
                                                       '    x <- x + 2;\n'
                                                       '    y <- y + 2\n'
                                                       '  done;\n'
                                                       '  if y = 0 then  (* premise *)\n'
                                                       '    assert { x <> 4 }  (* GOAL *)'}]}
                json_provided: true
                json:
                  error: null
                  obligations:
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* GOAL *)
                            invariant { x <= 2 || y <> 0 }
                            invariant { x <= 4 }
                            invariant { y <= 4 }
                            invariant { x <= 2 || y <> 0 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* GOAL *)
                            invariant { x <= 4 }
                            invariant { y <= 4 }
                            invariant { x <= 2 || y <> 0 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            invariant { x <= 4 }  (* GOAL *)
                            invariant { y <= 4 }
                            invariant { x <= 2 || y <> 0 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            invariant { x <= 4 }  (* premise *)
                            invariant { y <= 4 }  (* GOAL *)
                            invariant { x <= 2 || y <> 0 }
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant init)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* GOAL, premise *)
                          let ref y = any int in  (* GOAL, premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            invariant { x <= 4 }  (* premise *)
                            invariant { y <= 4 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* GOAL *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* GOAL, premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            invariant { x <= 4 }  (* premise *)
                            invariant { y <= 4 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                            invariant { x <= 4 }  (* premise *)
                            invariant { y <= 4 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            invariant { x <= 4 }  (* GOAL, premise *)
                            invariant { y <= 4 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: false
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            invariant { x <= 4 }  (* premise *)
                            invariant { y <= 4 }  (* GOAL, premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (loop invariant preservation)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            invariant { x <= 4 }  (* premise *)
                            invariant { y <= 4 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* GOAL, premise *)
                            x <- x + 2;  (* premise *)
                            y <- y + 2  (* premise *)
                          done;
                          if y = 0 then
                            assert { x <> 4 }
                    - name: VC for main (assertion)
                      proved: true
                      relevance_hints: |-
                        use int.Int

                        let main () diverges =  (* GOAL *)
                          let ref x = any int in  (* premise *)
                          let ref y = any int in  (* premise *)
                          assume { x >= 0 };  (* premise *)
                          assume { x <= 2 };  (* premise *)
                          assume { y <= 2 };  (* premise *)
                          assume { y >= 0 };  (* premise *)
                          while any bool do
                            invariant { x <= y + 2 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            invariant { x <= 4 }  (* premise *)
                            invariant { y <= 4 }  (* premise *)
                            invariant { x <= 2 || y <> 0 }  (* premise *)
                            x <- x + 2;
                            y <- y + 2
                          done;
                          if y = 0 then  (* premise *)
                            assert { x <> 4 }  (* GOAL *)
              destination: 134
          origin: [child, 122, 1]
        "134":
          kind: Failure
          success_value: null
          summary_message: too many remaining obligations
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 133, 0]
        "135":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (assertion)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
                    - [x <= 2 || y <> 0]
                answers:
                  - id: 77
                    hint: null
                    value:
                      short: "['x mod 2 = y mod 2']"
                      long: "['x mod 2 = y mod 2']"
                      json_provided: true
                      json: [x mod 2 = y mod 2]
          actions:
            - ref:
                with_ids: cands{@77}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [77]
              value:
                short: "['x mod 2 = y mod 2']"
                long: "['x mod 2 = y mod 2']"
                json_provided: true
                json: [x mod 2 = y mod 2]
              destination: 136
          origin: [nested, 3, 6]
        "136":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x mod 2 = y mod 2]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
                    - [x <= 2 || y <> 0]
                answers:
                  - id: 78
                    hint: null
                    value:
                      short: "True"
                      long: "True"
                      json_provided: true
                      json: true
          actions:
            - ref:
                with_ids: cands{@78}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [78]
              value:
                short: "True"
                long: "True"
                json_provided: true
                json: true
              destination: 137
          origin: [child, 135, 0]
        "137":
          kind: Success
          success_value:
            short: (['x mod 2 = y mod 2'], [['x mod 2 = 0', 'y mod 2 = 0'], ['x = y'], ['x + y <= 4', 'x <= 2'], ['x - y <= 2', 'x <= 2'], ['0 <= x - y <= 2'], ['x <= 2 || y <> 0'], ['x mod 2 = y mod 2']])
            long: |-
              (['x mod 2 = y mod 2'],
               [['x mod 2 = 0', 'y mod 2 = 0'],
                ['x = y'],
                ['x + y <= 4', 'x <= 2'],
                ['x - y <= 2', 'x <= 2'],
                ['0 <= x - y <= 2'],
                ['x <= 2 || y <> 0'],
                ['x mod 2 = y mod 2']])
            json_provided: true
            json:
              - [x mod 2 = y mod 2]
              - - [x mod 2 = 0, y mod 2 = 0]
                - [x = y]
                - [x + y <= 4, x <= 2]
                - [x - y <= 2, x <= 2]
                - [0 <= x - y <= 2]
                - [x <= 2 || y <> 0]
                - [x mod 2 = y mod 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 136, 0]
        "138":
          kind: Success
          success_value:
            short: "['x mod 2 = y mod 2']"
            long: "['x mod 2 = y mod 2']"
            json_provided: true
            json: [x mod 2 = y mod 2]
          summary_message: null
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 3, 6]
        "139":
          kind: Computation
          success_value: null
          summary_message: null
          leaf_node: false
          label: null
          properties:
            - - with_ids: query
                with_hints: null
              - kind: query
                name: __Computation__
                args:
                  fun: check
                  args:
                    prog: |
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                    annotated: |-
                      use int.Int

                      let main () diverges =
                        let ref x = any int in
                        let ref y = any int in
                        assume { x >= 0 };
                        assume { x <= 2 };
                        assume { y <= 2 };
                        assume { y >= 0 };
                        while any bool do
                          invariant { x mod 2 = y mod 2 }
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then
                          assert { x <> 4 }
                answers:
                  - id: 79
                    hint: null
                    value:
                      short: "{'error': \"File line 11, characters 18-21: unbound function or predicate symbol 'mod'\", 'obligations': []}"
                      long: |-
                        {'error': 'File line 11, characters 18-21: unbound function or predicate '
                                  "symbol 'mod'",
                         'obligations': []}
                      json_provided: true
                      json:
                        error: "File line 11, characters 18-21: unbound function or predicate symbol 'mod'"
                        obligations: []
          actions:
            - ref:
                with_ids: query{@79}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [79]
              value:
                short: "{'error': \"File line 11, characters 18-21: unbound function or predicate symbol 'mod'\", 'obligations': []}"
                long: |-
                  {'error': 'File line 11, characters 18-21: unbound function or predicate '
                            "symbol 'mod'",
                   'obligations': []}
                json_provided: true
                json:
                  error: "File line 11, characters 18-21: unbound function or predicate symbol 'mod'"
                  obligations: []
              destination: 140
          origin: [child, 2, 6]
        "140":
          kind: Failure
          success_value: null
          summary_message: invalid program
          leaf_node: true
          label: null
          properties: []
          actions: []
          origin: [child, 139, 0]
        "141":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: ProposeInvariants
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: ProposeInvariants
                args:
                  unproved:
                    obligation_name: VC for main (assertion)
                    relevance_hints: |-
                      use int.Int

                      let main () diverges =  (* GOAL *)
                        let ref x = any int in  (* premise *)
                        let ref y = any int in  (* premise *)
                        assume { x >= 0 };  (* premise *)
                        assume { x <= 2 };  (* premise *)
                        assume { y <= 2 };  (* premise *)
                        assume { y >= 0 };  (* premise *)
                        while any bool do
                          x <- x + 2;
                          y <- y + 2
                        done;
                        if y = 0 then  (* premise *)
                          assert { x <> 4 }  (* GOAL *)
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
                    - [x <= 2 || y <> 0]
                    - [x mod 2 = y mod 2]
                answers:
                  - id: 80
                    hint: null
                    value:
                      short: "['x - y = 0']"
                      long: "['x - y = 0']"
                      json_provided: true
                      json: [x - y = 0]
          actions:
            - ref:
                with_ids: cands{@80}
                with_hints: null
              hints: null
              related_success_nodes: []
              related_answers: [80]
              value:
                short: "['x - y = 0']"
                long: "['x - y = 0']"
                json_provided: true
                json: [x - y = 0]
              destination: 142
          origin: [nested, 3, 7]
        "142":
          kind: Branch
          success_value: null
          summary_message: null
          leaf_node: false
          label: IsProposalNovel
          properties:
            - - with_ids: cands
                with_hints: null
              - kind: query
                name: IsProposalNovel
                args:
                  proposal: [x - y = 0]
                  blacklist:
                    - [x mod 2 = 0, y mod 2 = 0]
                    - [x = y]
                    - [x + y <= 4, x <= 2]
                    - [x - y <= 2, x <= 2]
                    - [0 <= x - y <= 2]
                    - [x <= 2 || y <> 0]
                    - [x mod 2 = y mod 2]
                answers: []
          actions: []
          origin: [child, 141, 0]
