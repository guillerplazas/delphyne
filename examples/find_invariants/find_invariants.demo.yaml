# Demonstrations for the `find_invariants.prove_program` strategy


# An example with conditionals, which involves abducting an additional assumption.
- strategy: prove_program
  args:
    prog: |
      use int.Int

      let example1 () diverges =
        let ref x = any int in
        let ref y = 3 in
        let ref z = 0 in
        assume { x < 0 };
        while x < 10 do
          x <- x + 1;
          z <- z - 1;
          if z < 0 then y <- y + 1
        done;
        assert { x <> y }
  tests:
    - run | success
    - run 'partial' | success
  queries: 
    - query: ProposeInvariants
      args:
        unproved:
          obligation_name: VC for example1 (assertion)
          relevance_hints: |-
            use int.Int
      
            let example1 () diverges =  (* GOAL *)
              let ref x = any int in  (* premise *)
              let ref y = 3 in
              let ref z = 0 in
              assume { x < 0 };  (* premise *)
              while x < 10 do  (* premise *)
                x <- x + 1;
                z <- z - 1;
                if z < 0 then y <- y + 1
              done;
              assert { x <> y }  (* GOAL *)
        blacklist: []
      answers:
        - answer: |
            The final assertion `x <> y` failed to prove, meaning that Why3 could not deduce it after assuming the provided loop invariants (none) and the negation of the loop guard. Let's see if `x <> y` itself might be an invariant. For this to hold, it has to be true before the loop and preserved by each loop iteration.

            Right before the loop, `x <> y` holds thanks to the `x < 0` assumption. Assuming `x <> y` holds at the start of a loop iteration, can it be shown to hold afterwards? What happens to `x` and `y` in the loop body depends on whether or not the conditional statement is executed, which in turns depends on the value of `z`. Looking at `z`, it starts with value `0` at the beginning of the program and it is then never increased. Thus, `z <= 0` is an invariant and the conditional statement is always executed. Thus, at each loop iteration, both `x` and `y` are increased by 1 and so `x <> y` is preserved.

            Summarizing, we can prove `x <> y` to be an invariant, assuming that `z <= 0` is added as an invariant too. Thus, we propose to update the program by adding the following two invariants:

            ```
            - "z <= 0"
            - "x <> y"
            ```
        - label: partial
          example: false
          answer: |
            ```
            - "x <> y"
            ```