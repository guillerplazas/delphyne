{% include 'shared/intro.jinja' %}


{% include 'shared/lin_only.jinja' %}


I will show you a Why3 program with a single loop and a final assertion. The goal is to prove this assertion by providing a sequence of loop invariants. As a reminder, an invariant is a formula that holds initially and that is preserved by the loop body (it is true at the end of an iteration if it is true at the start). Your job is to find a list of invariants that together imply the final assertion.

Please reason carefully and then finish your answer with a YAML object surrounded by triple quotes that denotes a list of invariants. If you make a mistake (your suggested invariants do not imply the postcondition, an invariant does not hold initially or could not be proved to be preserved), I will show you the failing proof obligations and you'll have a chance to answer again. If there

## Why3 Feedback

If there is a syntax error in your answer, I'll give you Why3's error message and let you fix your answer. If some obligations failed to be proved, we'll show them to you as feedback. Each obligation name provides a hint about the nature of a problem, which is either:

- `assertion`: the final assertion is not implied by the invariants
- `loop invariant init`: an invariant does not hold initially
- `loop invariant preservation`: an invariant cannot be proved to be preserved by the loop body (it may not be preserved or an additional invariant may be needed to complete the proof)

In addition, for each obligation, I provide an annotated version of the program indicating what assertion or invariant failed to be proved (`GOAL`) and what parts of the program provide relevant assumptions (`premise`).

## Advice

Here is some advice for finding invariants:

- To find invariant candidates, look for formulas that imply the final assertion when assuming the negation of the loop guard.
- If an invariant cannot be proved to hold initially, it must be discarded.
- If an invariant cannot be proved to be preserved by the loop body, it might be wrong (in the sense that there exists an execution that serves as a counterexample), but it might also be true and other invariants are needed to provide additional assumptions for proving preservation.
- Whenever a variable `x` is only incremented (resp. decremented), an invariant of the form `x >= c` (resp. `x <= c`) is likely to hold, for `c` a constant.
- If a property `P` always holds after the loop but cannot be proved as an invariant because `P` does not hold initially, consider proposing `P || loop_guard` as an invariant instead.
- If proving an invariant `inv` requires assuming a global assumption `assum` that is only made _after_ the loop, consider proposing `assum -> inv` as an invariant instead.
- If proving the preservation of an invariant candidate requires proving that a specific branch in the code cannot be taken (or is always taken), consider proposing an invariant that establishes this fact.
- Suppose the loop guard is an inequality such as `expr < c` with `expr` an expression and `c` a constant. Then, if quantity `expr` cannot increase more than a constant amount `d` at each iteration, consider proposing `expr < c + d` as an invariant (and similarly for <=, > and >=).