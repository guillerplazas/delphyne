#####
##### Incremental Invariant Generation
#####

##### Example 1

- strategy: annotate_invariants_incrementally
  args:
    prog: |
      use int.Int

      let example1 () diverges =
        let ref x = any int in
        let ref y = 3 in
        let ref z = 0 in
        assume { x < 0 };
        while x < 10 do
          x <- x + 1;
          z <- z - 1;
          if z < 0 then y <- y + 1
        done;
        assert { x <> y }
  tests:
    - run | success
  queries:
    - query: ProposeInvariant
      args:
        prog: |
          use int.Int

          let example1 () diverges =
            let ref x = any int in
            let ref y = 3 in
            let ref z = 0 in
            assume { x < 0 };
            while x < 10 do
              x <- x + 1;
              z <- z - 1;
              if z < 0 then y <- y + 1
            done;
            assert { x <> y }
        feedback:
          error: null
          obligations:
            - name: VC for example1 (assertion)
              annotated: |-
                use int.Int

                let example1 () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = 3 in
                  let ref z = 0 in
                  assume { x < 0 };  (* premise *)
                  while x < 10 do  (* premise *)
                    x <- x + 1;
                    z <- z - 1;
                    if z < 0 then y <- y + 1
                  done;
                  assert { x <> y }  (* GOAL *)
              context: |-
                constant o : int

                axiom Assume : o < 0

                constant z : int

                constant y : int

                constant x : int

                axiom H : not x < 10
              goal: "goal example1'vc : not x = y"
              message: |-
                Unknown (unknown)
                (0.01s, 8 steps)
        proposed_already: []
      answers:
      - answer: |
          Why3 failed to prove that `x <> y` assuming `x >= 10`. Formula `x <> y` appears to hold throughout the program so we propose it as an invariant.

          Proposed invariant:
          ```
          x <> y
          ```
    - query: ProposeInvariant
      args:
        prog: |-
          use int.Int

          let example1 () diverges =
            let ref x = any int in
            let ref y = 3 in
            let ref z = 0 in
            assume { x < 0 };
            while x < 10 do
              invariant { x <> y }
              x <- x + 1;
              z <- z - 1;
              if z < 0 then y <- y + 1
            done;
            assert { x <> y }
        feedback:
          error: null
          obligations:
            - name: VC for example1 (loop invariant preservation)
              annotated: |-
                use int.Int

                let example1 () diverges =  (* GOAL *)
                  let ref x = any int in  (* premise *)
                  let ref y = 3 in
                  let ref z = 0 in
                  assume { x < 0 };  (* premise *)
                  while x < 10 do  (* premise *)
                    invariant { x <> y }  (* GOAL, premise *)
                    x <- x + 1;  (* premise *)
                    z <- z - 1;  (* premise *)
                    if z < 0 then y <- y + 1  (* premise *)
                  done;
                  assert { x <> y }
              context: |-
                constant o : int

                axiom Assume : o < 0

                constant z : int

                constant y : int

                constant x : int

                axiom LoopInvariant : not x = y

                axiom H1 : x < 10

                axiom H2 : not (z - 1) < 0
              goal: "goal example1'vc1 : not (x + 1) = y"
              message: |-
                Unknown (unknown)
                (0.01s, 12 steps)
        proposed_already: []
      answers:
      - answer: |
          Why3 failed to prove that `x + 1 <> y` assuming `x <> y`, `x < 10` and `z - 1 >= 0`. Assumption `z - 1 >= 0` does not appear to ever hold in the program since `z` starts at 0 and is then only decremented. Thus, we propose its negation as an invariant, which is `z - 1 < 0` and which simplifies to `z < 1`.

          Proposed invariant:
          ```
          z < 1
          ```

##### Example 2

- strategy: annotate_invariants_incrementally
  args:
    prog: |
      use int.Int

      let main () diverges =
        let n = any int in
        let ref x = 0 in
        assume { n > 0 };
        while x < n do
          x <- x + 1;
        done;
        assert { x = n }
  tests:
    - run | success
  queries:
    - query: ProposeInvariant
      args:
        prog: |
          use int.Int

          let main () diverges =
            let n = any int in
            let ref x = 0 in
            assume { n > 0 };
            while x < n do
              x <- x + 1;
            done;
            assert { x = n }
        feedback:
          error: null
          obligations:
            - name: VC for main (assertion)
              annotated: |-
                use int.Int

                let main () diverges =  (* GOAL *)
                  let n = any int in
                  let ref x = 0 in
                  assume { n > 0 };  (* premise *)
                  while x < n do  (* premise *)
                    x <- x + 1;
                  done;
                  assert { x = n }  (* GOAL *)
              context: |-
                constant n : int

                axiom Assume : n > 0

                constant x : int

                axiom H : not x < n
              goal: "goal main'vc : x = n"
              message: |-
                Unknown (unknown)
                (0.01s, 7 steps)
        proposed_already: []
      answers:
      - answer: |
          Why3 failed to prove that `x = n` assuming `x >= n`. The simplest way to make it true would be to also establish `x <= n`, which happens to be true throughout the program.

          Proposed invariant:
          ```
          x <= n
          ```
